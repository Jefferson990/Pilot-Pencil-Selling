<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vertriebs-Dashboard - Freunde werben & Druck-Fix</title>
    
    <!-- 1. Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- 3. Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/html2pdf.js@0.10.1/dist/html2pdf.bundle.min.js"></script>

<style>
        /* Global Visual Boost */
        html {
            filter: saturate(1.4) contrast(1.05);
            -webkit-font-smoothing: antialiased;
            -moz-osx-osx-font-smoothing: grayscale;
            font-family: ui-sans-serif, system-ui, sans-serif;
        }

        .custom-scrollbar::-webkit-scrollbar { width: 6px; height: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background-color: #cbd5e1; border-radius: 3px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background-color: #94a3b8; }
        
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .animate-in { animation: fadeIn 0.3s ease-out forwards; }
        
        /* Animation definitions */
        @keyframes flow { from { stroke-dashoffset: 20; } to { stroke-dashoffset: 0; } }
        .flow-anim { stroke-dasharray: 10, 10; animation: flow 1s linear infinite; }
        
        @keyframes signal { 0% { opacity: 1; r: 5; } 100% { opacity: 0; r: 30; } }
        .signal-wave { animation: signal 2s infinite ease-out; opacity: 0; transform-origin: center; }
        .delay-1 { animation-delay: 0.5s; }

        @keyframes beam { 0% { stroke-dashoffset: 20; opacity: 0.5; } 50% { opacity: 1; } 100% { stroke-dashoffset: 0; opacity: 0.5; } }
        .beam-anim { animation: beam 1.5s linear infinite; }

        /* General Layout */
        /* General Layout */
/* Screen/layout MUST be fluid (fix for Android/Tablet Fullscreen clipping).
   Print/PDF keeps its fixed A4-landscape widths inside @media print / pdf-share-mode blocks. */
html, body, #root{
  min-width: 0 !important;          /* important: remove 297mm hard-lock on screen */
  width: 100% !important;
  height: 100% !important;
  margin: 0 !important;
  padding: 0 !important;
  overflow-x: hidden !important;    /* avoid horizontal scrollbars */
  overflow-y: hidden !important;    /* keep original no-scroll behavior */
  background-color: #f0f6ff !important;
  box-sizing: border-box;
}
/* Ensure nothing forces a wider-than-viewport layout in fullscreen */
#root{ max-width: 100vw !important; }

/* === FULLSCREEN/ROTATE: prevent canvas distortion === */
.drawing-canvas{ width:100% !important; height:100% !important; }


        
        

/* ===== EXPORT/PRINT COLOR SAFETY (satte Farben, kein transparenter Hintergrund) ===== */
body.pdf-share-mode,
body.pdf-share-mode *{
    -webkit-print-color-adjust: exact !important;
    print-color-adjust: exact !important;
    color-adjust: exact !important;
}

/* =====================================================
   PRINT PATCH v15 – Seite 1 Canvas breiter
   Nutzt den bisher freien rechten Rand (rot markiert)
   ===================================================== */
@media print {
  /* Gesamter Seiten-Wrapper von Seite 1 */
  .print-situation-view {
      padding-right: 6mm !important;
  }

  /* Zentrale Zeichen-/Inhaltsfläche auf Seite 1 */
  .print-situation-view .canvas,
  .print-situation-view .canvas-area,
  .print-situation-view .situation-canvas,
  .print-situation-view .content-area {
      max-width: calc(100% + 6mm) !important;
  }
}
body.pdf-share-mode{
    background-color:#ffffff !important;
}
body.pdf-share-mode .canvas-image{
    opacity:1 !important;
    -webkit-filter:none !important;
    filter:none !important;
}
/* Auch außerhalb von Print: niemals transparent exportieren */
html, body{
    background-color: #f0f6ff;
}
/* Canvas Layer: touch-action none is crucial for pen handling */
        .canvas-layer { pointer-events: auto; touch-action: none; }
        .input-layer { pointer-events: auto; z-index: 30; }
        
        /* --- WLAN PLANER STYLES --- */
        .wlan-chip {
            padding: 8px 16px; border-radius: 8px; border: 1px solid #e2e8f0; background: white; 
            color: #64748b; font-weight: 600; font-size: 13px; cursor: pointer; transition: all 0.2s;
        }
        .wlan-chip:hover { background: #f8fafc; }
        .wlan-chip.toggled { background: #eff6ff; border-color: #3b82f6; color: #2563eb; }
        .wlan-num { width: 40px; height: 40px; display: flex; items-center; justify-content: center; padding: 0; }
        
        .wlan-badge {
            padding: 4px 12px; border-radius: 999px; font-size: 11px; font-weight: 700; 
            text-transform: uppercase; letter-spacing: 0.05em; background: #f1f5f9; color: #94a3b8;
        }
        .wlan-badge.glow { background: #dbeafe; color: #1e40af; box-shadow: 0 0 10px rgba(59, 130, 246, 0.3); }
        
        .wifi-glow { animation: pulse-blue 2s infinite; }
        @keyframes pulse-blue { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }

        /* SVG Styles */
        .wlan-svg .roof { fill: #e0f2fe; stroke: #94a3b8; }
        .wlan-svg .house-body { fill: #ffffff; stroke: #94a3b8; }
        .wlan-svg .keller { fill: #f1f5f9; stroke: #94a3b8; }
        .wlan-svg .floor-line { stroke: #e2e8e0; }
        
        /* Offer Canvas Styling */
        .offer-canvas-container {
            border: 4px solid #e5e5e5;
            border-radius: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
            background: white;
            min-height: 550px; 
            transition: all 0.25s ease; 
        }
        
        .canvas-lines {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: repeating-linear-gradient(to bottom, transparent, transparent 19px, #cbd5e1 20px);
            pointer-events: none;
            z-index: 1; 
        }
        
        .drawing-canvas { position: relative; z-index: 3; }
        
        .canvas-image {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: contain; pointer-events: none; z-index: 1; transform-origin: center center;
        }

        /* --- STIFT-FÄHIGE INPUTS --- */
        .small-canvas-wrapper {
            position: relative; width: 100%; height: 100%;
            background-color: white; border: 1px solid #e5e7eb; border-radius: 0.5rem;
            overflow: hidden; flex-grow: 1;
        }
        
        /* Unterschrifts-Canvas im Modal */
        .signature-canvas-container {
            width: 100%; height: 200px; background: #fff; border: 1px solid #e2e8f0; border-radius: 0.5rem;
            position: relative;
            background-image: linear-gradient(to bottom, transparent 90%, #6b7280 91%, transparent 92%);
            background-size: 100% 100%; background-repeat: no-repeat; background-position: 0 90%;
            overflow: hidden; touch-action: none;
        }
        

        /* Print-Header wird nur zur Druckzeit per JS eingefügt */
        .print-page-header{ display:none; }

        /* --- PRINT STYLES (EXAKT 2 SEITEN A4 mit GRAFIKEN) --- */
        
        
@media print {
    @page { size: A4 landscape; margin: 0.5cm; }

    /* Farben + Hintergrundgrafiken drucken */
    * {
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
        color-adjust: exact !important;
    }

    

    /* Safari/iOS: Filter im Print deaktivieren (sonst können Farben „verfälscht“/reduziert wirken) */
    html {
        -webkit-filter: none !important;
        filter: none !important;
    }

    /* Sicherheit: Hintergrundfarben/Gradienten wirklich behalten */
    html, body, #root {
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
        color-adjust: exact !important;
    }
html, body {
        width: 100% !important;
        min-width: 1120px !important;
        height: auto !important;
        overflow: visible !important;
        margin: 0 !important;
        padding: 0 !important;
        background: #ffffff !important;
    }

    /* Bilder in Canva-Bereichen nie durchsichtig drucken */
    .canvas-image, .canvas-images*{
        opacity: 1 !important;
        -webkit-filter: none !important;
        filter: none !important;
    }


    /* Globalen Header im Print ausblenden (wir erzeugen pro Seite einen Print-Header) */
    header { display: none !important; }

    .print-page-header{ display:flex !important; align-items:center; justify-content:space-between; gap:12px; padding:10px 14px; background:#eff6ff !important; border:1px solid #e2e8f0; border-radius:14px; margin:0 0 10px 0; }
    .print-page-header .title{ font-size:28px; font-weight:900; color:#0b1e42; letter-spacing:-0.02em; }
    .print-page-header .badge{ background:#2563eb; color:#ffffff; padding:4px 10px; border-radius:999px; font-size:10px; font-weight:800; border:1px solid #1d4ed8; }

    /* HIDA Logo (Screen + Print) */
    .hida-logo-screen{
        position:absolute;
        right:16px;
        top:50%;
        transform:translateY(-50%);
        width:180px;
        height:48px;
        display:flex;
        align-items:center;
        justify-content:flex-end;
        pointer-events:none;
        z-index:60;
    }
    .hida-logo-screen svg{ width:180px; height:48px; }

    .print-page-header .print-header-right{
        display:flex;
        align-items:center;
        gap:10px;
    }
    .print-page-header .hida-logo-print{
        height:34px;
        width:auto;
        object-fit:contain;
    }

    @media print{
        .hida-logo-screen{ display:none !important; } /* Screen-Header wird beim Druck ersetzt */
    }

    /* Interaktive UI/Overlays ausblenden */
    .situation-view-wrapper button,
    .print-offer-view button { display: none !important; }

        /* Status-Pills im Angebot sollen MITGEDRUCKT werden */
    .print-offer-view button[data-print-keep="1"]{ display: inline-flex !important; }
    /* Icons in der Situation (links) sollen im Druck sichtbar bleiben */
    .situation-view-wrapper button[data-print-keep="1"]{ display: inline-flex !important; }


    .footer-bar,
    .fixed.inset-0.z-50,
    .fixed.inset-0.z-\[60\],
    input[type="file"] {
        display: none !important;
    }


    /* Toasts / schwarze Hinweis-Kästen (z.B. "WLAN kopiert", "Schrift hinzugefügt") im Print dauerhaft ausblenden */
    .print-hide-toast,
    .fixed.bottom-4,
    .fixed.bottom-5,
    .fixed.bottom-6,
    .fixed.bottom-8 {
        display: none !important;
    }

    /* Roaming/Blende im Print ausblenden */
    .print-hide-roaming{ display:none !important; }


    #root {
        display: block !important;
        width: 100% !important;
        min-width: 1120px !important;
        height: auto !important;
        overflow: visible !important;
        background: #ffffff !important;
    }

    /* Bilder in Canva-Bereichen nie durchsichtig drucken */
    .canvas-image, .canvas-images*{
        opacity: 1 !important;
        -webkit-filter: none !important;
        filter: none !important;
    }


    /* -------- Seite 1: Situation (voll sichtbar) -------- */
    .situation-view-wrapper {
        display: flex !important;
        flex-direction: row !important;
        flex-wrap: wrap !important;
        align-items: stretch !important;
        gap: 0 !important;
        visibility: visible !important;
        opacity: 1 !important;
        position: relative !important;

        /* FIX: Breite auf 100% des Papiers setzen statt 1120px */
        width: 100% !important;
        max-width: 100% !important;
        min-width: 0 !important;

        /* FIX (v12): Keine vertikale Komprimierung auf Seite 1.
           Statt "zoom" (skaliert X+Y und schiebt alles nach oben) nutzen wir nur eine X-Skalierung,
           damit rechts nichts abgeschnitten wird, aber die Hoehe/Position optisch gleich bleibt. */
        zoom: 1 !important;
        transform: scaleX(0.92) !important;
        transform-origin: top left !important;

        height: auto !important;
        overflow: visible !important;

        break-after: page !important;
        page-break-after: always !important;

        margin: 0 !important;
        padding: 0 !important;
        padding-left: 0px !important; /* Safe-Shift für links (Print + Share identisch) */
        /* Seite 1 im Print wie Seite 2: hellblauer Seitenhintergrund */
        background: #eff6ff !important;
        background-color: #eff6ff !important;
        box-shadow: inset 0 0 0 1000px #eff6ff !important;
    }

    /* Print-Header soll volle Breite oben einnehmen */
    .situation-view-wrapper > .print-page-header {
        flex: 0 0 100% !important;
        max-width: 100% !important;
        width: 100% !important;
        order: 0 !important;
        /* Seite 1 Header wie Seite 2: weiße, abgerundete Header-Kapsel */
        background: #ffffff !important;
        background-color: #ffffff !important;
        box-shadow: inset 0 0 0 1000px #eff6ff !important;
    }

    /* FIX: Linke Label-Spalte (w-[30%]) = hellblau wie Seite 2 */
    .situation-view-wrapper [class*="w-[30%]"]{
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
        color-adjust: exact !important;

        background: #eff6ff !important;
        background-color: #eff6ff !important;
        box-shadow: inset 0 0 0 1000px #eff6ff !important;
    }

    /* Falls Tailwind-Klassen auf der linken Spalte andere Farben setzen, trotzdem blau erzwingen */
    .situation-view-wrapper [class*="w-[30%]"][class*="bg-slate-100"],
    .situation-view-wrapper [class*="w-[30%]"][class*="bg-blue-50"],
    .situation-view-wrapper [class*="w-[30%]"][class*="bg-white"]{
        background: #eff6ff !important;
        background-color: #eff6ff !important;
        box-shadow: inset 0 0 0 1000px #eff6ff !important;
    }

    /* Main (Links+Mitte) = 80% */
    .situation-view-wrapper > div.flex-1.flex.items-stretch {
        
        /* Sicherstellen, dass die Spalten innerhalb flexibel bleiben */
        flex: 1 1 auto !important;
        width: 74% !important; /* Haupttabelle bekommt ca. 3/4 des Platzes */
        max-width: 74% !important;
        order: 1 !important;
    }

    /* Rechte Sidebar = 20% (im Print sichtbar) */
    .situation-view-wrapper > aside {
        
        display: flex !important;
        flex: 0 0 26% !important; /* Sidebar bekommt ca. 1/4 */
        width: 26% !important;
        max-width: 26% !important;
        min-width: 0 !important;
        height: auto !important;
        overflow: visible !important;
        order: 2 !important;
    }



    /* Print: Stammdaten/Sidebar etwas dünner, damit alles auf 2 Seiten passt */
    .situation-view-wrapper > aside {
        padding: 8px !important;
    }
    .situation-view-wrapper > aside .gap-2 {
        gap: 6px !important;
    }
    .situation-view-wrapper > aside .bg-white {
        padding: 8px !important;
    }
    .situation-view-wrapper > aside h3 {
        margin-bottom: 4px !important;
    }


    /* In Print darf nichts "viewport-locked" sein */
    .situation-view-wrapper .overflow-hidden,
    .situation-view-wrapper .h-full,
    .situation-view-wrapper .min-h-0 {
        overflow: visible !important;
        height: auto !important;
        min-height: 0 !important;
    }


    /* Fix: Kleine Eingabefelder (E-Mail etc.) dürfen im Print NICHT auf height:auto kollabieren */
    .situation-view-wrapper .small-input-fixed{
        height: 64px !important;
        min-height: 64px !important;
        overflow: hidden !important;
        position: relative !important;
    }

    /* Die 10 Zeilen sollen sauber auf eine Seite passen */
    .situation-view-wrapper .flex.w-full.flex-1.min-h-0.relative {
        flex: none !important;
        height: 62px !important;
        min-height: 62px !important;
    }

    /* Canvas-Overlay in Print sichtbar + volle Höhe */
    .situation-view-wrapper canvas.drawing-canvas {
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
    }

    /* Karten-Hintergründe erzwingen */
    .bg-white { background-color: #ffffff !important; }
    .bg-slate-100 {
        background-color: #f1f5f9 !important;
        box-shadow: inset 0 0 0 1000px #f1f5f9 !important;
    }
    .bg-blue-50 {
        background-color: #eff6ff !important;
        box-shadow: inset 0 0 0 1000px #eff6ff !important;
    }

    /* === HARD-FIX (Chrome/Edge): Wenn "Hintergrundgrafiken" im Druckdialog AUS ist,
       werden reine background-colors oft nicht gedruckt.
       Lösung: Wir legen im Printmodus ein SVG-IMG als Layer unter den Inhalt (Bilder drucken immer).
       JS injiziert dieses IMG dynamisch in alle .bg-blue-50 / .bg-slate-100 Container.
    */
    .print-bg-host { position: relative !important; }
    .print-bg-host > img.print-bg-img-layer {
        position: absolute !important;
        inset: 0 !important;
        width: 100% !important;
        height: 100% !important;
        object-fit: cover !important;
        z-index: 0 !important;
        pointer-events: none !important;
    }
    .print-bg-host > :not(img.print-bg-img-layer) {
        position: relative !important;
        z-index: 1 !important;
    }

    /* -------- Seite 2: Angebot (voll sichtbar) -------- */
    .print-offer-view {
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
        position: relative !important;

        width: 1120px !important;
        max-width: 1120px !important;
        min-width: 1120px !important;
        height: auto !important;
        overflow: visible !important;

        zoom: 0.80;

        margin: 0 !important;
        padding: 0 !important;
        /* FIX: Seite 2 IMMER hellblau im Print */
        background: #eff6ff !important;
        background-color: #eff6ff !important;
        box-shadow: inset 0 0 0 1000px #eff6ff !important;
    }

    .print-offer-view .overflow-hidden,
    .print-offer-view .h-full,
    .print-offer-view .min-h-0 {
        overflow: visible !important;
        height: auto !important;
        min-height: 0 !important;
    }

    .offer-canvas-container {
        box-shadow: none !important;
        /* Rahmenfarbe kommt aus Status-Klassen (border-red-500 / border-green-500 / border-slate-300) */
        border-width: 4px !important;
        border-style: solid !important;
        background: #ffffff !important;
    }

    /* Bilder in Canva-Bereichen nie durchsichtig drucken */
    .canvas-image, .canvas-images*{
        opacity: 1 !important;
        -webkit-filter: none !important;
        filter: none !important;
    }


    /* Fallback: erzwinge Status-Rahmenfarben im Print (falls Tailwind-Utilities im Print nicht greifen) */
    .print-offer-view .offer-canvas-container.border-red-500{ border-color:#ef4444 !important; }
    .print-offer-view .offer-canvas-container.border-green-500{ border-color:#22c55e !important; }
    .print-offer-view .offer-canvas-container.border-slate-300{ border-color:#cbd5e1 !important; }


    /* Keine Umbrüche mitten im Offer-Block */
    .offer-canvas-container {
        break-inside: avoid !important;
        page-break-inside: avoid !important;
    }

    .canvas-lines {
        background-image: repeating-linear-gradient(to bottom, transparent, transparent 19px, #e2e8f0 20px) !important;
    }

    .drawing-canvas, .canvas-image {
        opacity: 1 !important;
        display: block !important;
        visibility: visible !important;
    }



    /* Print-Compact: Angebot + Kosten müssen auf 1 Seite passen (ohne Screen zu ändern) */
    .print-offer-view .offer-canvas-container {
        min-height: 260px !important;
        margin-bottom: 12px !important;
    }
    .print-offer-view .print-page-header {
        margin-bottom: 8px !important;
        padding: 8px 12px !important;
    }
    .print-offer-view .print-page-header .title {
        font-size: 24px !important;
    }
    /* Weniger vertikaler Abstand in Karten */
    .print-offer-view .gap-4 {
        gap: 10px !important;
    }

    /* Inputs sollen lesbar bleiben */
    textarea, input, select {
        color: #000000 !important;
        -webkit-text-fill-color: #000000 !important;
    }

    /* Platzhaltertexte ("Skizze aktiv...", "Eingabe...") im Druck ausblenden */
    input::placeholder, textarea::placeholder{
        color: transparent !important;
        opacity: 0 !important;
    }
    input::-webkit-input-placeholder, textarea::-webkit-input-placeholder{
        color: transparent !important;
        opacity: 0 !important;
    }

    /* ---- PRINT: Seite 1 Breitensteuerung (Links/Mitte/Rechts = 30/50/20) ---- */

    /* Optional: inner columns slightly smaller for safety (34/64) */
    .situation-view-wrapper [class*="w-[30%]"]{
        width: 34% !important;
        flex: 0 0 34% !important;
        max-width: 34% !important;
    }
    .situation-view-wrapper [class*="w-[70%]"]{
        width: 64% !important;
        flex: 0 0 64% !important;
        max-width: 64% !important;
    }

    /* Da Main (Links+Mitte) im Print 80% hat, müssen die Zellbreiten 37.5% / 62.5% sein */
    .situation-view-wrapper [class*="w-[30%]"]{
        width: 35% !important;
        flex: 0 0 35% !important;
        max-width: 35% !important;
    }
    .situation-view-wrapper [class*="w-[70%]"]{
        width: 65% !important;
        flex: 0 0 65% !important;
        max-width: 65% !important;
    }
    /* Inline-Overlay (left:30%/width:70%) für Stylus im Print überschreiben */
    .situation-view-wrapper .flex.w-full.flex-1.min-h-0.relative .absolute.inset-0.z-20{
        left: 30% !important;
        width: 70% !important;
    }
    /* Scroll-Container in Sidebar im Print auflösen */
    .situation-view-wrapper .overflow-y-auto{
        overflow: visible !important;
    }

    /* ---- PRINT: Seite 2 Layout-Optimierung (Angebote größer, Kostenblock minimal) ---- */
    /* 3 Angebots-Canvas deutlich höher (ca. doppelt) */
    .print-offer-view .offer-canvas-container{
        min-height: 550px !important; /* ~2x gegenüber 260px */
        margin-bottom: 10px !important;
    }

    /* Damit Seite 2 trotzdem sauber auf 1 Seite passt: Kostenblock kompakt */
    .print-offer-view .cost-overview-print{
        padding: 10px 12px !important;
        box-shadow: none !important;
    }

    /* Print-Safety: Kostenfelder (1./2. Jahr) bleiben immer nebeneinander -> verhindert zusätzliche Druck-Seite */
    @media print{
        .print-offer-view .cost-grid-years {
    display: grid !important;
    /* Wir nutzen 1fr statt minmax, damit die Spalten flexibel schrumpfen */
    grid-template-columns: repeat(3, 1fr) !important; 
    /* Reduzierter Abstand, damit alles unter die Mine passt */
    gap: 6px !important; 
}

.print-offer-view .cost-grid-years > * {
    min-width: 0 !important;
    width: 100% !important;
}

/* Sicherstellen, dass die Inputs zentriert bleiben und nicht ausbrechen */
.offer-cost-input {
    width: 100% !important;
    text-align: center !important;
    padding: 0 !important;
}
    }
    .print-offer-view .cost-overview-print h3{
        margin-bottom: 6px !important;
        font-size: 16px !important;
    }
    /* Inputs im Kostenblock flacher */
    .print-offer-view .cost-overview-print input,
    .print-offer-view .cost-overview-print textarea,
    .print-offer-view .cost-overview-print select{
        padding-top: 6px !important;
        padding-bottom: 6px !important;
        height: 34px !important;
        min-height: 34px !important;
        font-size: 12px !important;
    }

    /* Disclaimer/Infobalken unten: so klein wie möglich, aber noch lesbar */
    .print-offer-view .cost-overview-print .text-\[10px\],
    .print-offer-view .cost-overview-print .text-xs{
        font-size: 7px !important;
        line-height: 1.1 !important;
    }
    .print-offer-view .cost-overview-print p{
        margin-top: 4px !important;
        margin-bottom: 0 !important;
    }

    /* Optional: minimal mehr Platz für Angebote durch leichtes Print-Zoom nur auf Seite 2 */
    .print-offer-view{ zoom: 0.78 !important; }



    /* --- PRINT: Papier-robust (gerade Linien) --- */
    .situation-view-wrapper .bg-white.border.border-slate-200,
    .print-offer-view .bg-white.border.border-slate-200,
    .situation-view-wrapper .bg-white.border.border-slate-200.shadow-sm,
    .print-offer-view .bg-white.border.border-slate-200.shadow-sm {
        box-shadow: none !important;
        border-width: 2px !important;
    }
    /* Safety: entferne Schatten-Klassen im Print, falls sie irgendwo greifen */
    .situation-view-wrapper .shadow,
    .situation-view-wrapper .shadow-sm,
    .situation-view-wrapper .shadow-md,
    .situation-view-wrapper .shadow-lg,
    .situation-view-wrapper .shadow-xl,
    .situation-view-wrapper .shadow-2xl,
    .print-offer-view .shadow,
    .print-offer-view .shadow-sm,
    .print-offer-view .shadow-md,
    .print-offer-view .shadow-lg,
    .print-offer-view .shadow-xl,
    .print-offer-view .shadow-2xl {
        box-shadow: none !important;
    }

    /* ===== PRINT ONLY: Select-Felder größer & besser lesbar ===== */
    select {
        height: 48px !important;          /* +2 Höhe */
        padding-left: 12px !important;    /* +1 Breite */
        padding-right: 32px !important;   /* +1 Breite */
        font-size: 11px !important;       /* minimal größer für Papier */
        line-height: 1.2 !important;
    }

    select option {
        color: #000000 !important;
    }

    /* ===== PRINT ONLY: Stammdaten Selects untereinander & volle Breite ===== */
    @media print {

        /* Container der beiden Selects (Kundentyp / Segment) */
        .stammdaten-select-row,
        .stammdaten-selects,
        .stammdaten select {
            width: 100% !important;
        }

        /* Falls sie in einer Flex-Row liegen: untereinander stapeln */
        .stammdaten-select-row,
        .stammdaten-selects {
            display: flex !important;
            flex-direction: column !important;
            gap: 10px !important;
        }

        /* Selects selbst */
        .stammdaten-select-row select,
        .stammdaten-selects select {
            width: 100% !important;
            height: 48px !important;
        }
    }



    /* ===== Share-PDF: Inhaltsseiten (Seite 2 & 3) zweispaltig + Sidebar erzwingen ===== */
    body.pdf-share-mode .situation-view-wrapper,
    body.pdf-share-mode .print-offer-view{
        display:flex !important;
        flex-direction:row !important;
        flex-wrap:nowrap !important;
        width:1050px !important;
        min-width:1050px !important;
        max-width:1050px !important;
        margin: 0 auto !important;
        margin-left: auto !important;
        margin-right: auto !important;
        padding:20px !important;
        padding-left:30px !important; /* +10px CENTERFIX gegen linken Anschnitt */
        gap:20px !important;
        transform:none !important;
        zoom:0.95 !important; /* leicht kleiner, damit rechts garantiert Platz bleibt */
        box-sizing:border-box !important;
        overflow:hidden !important;
        page-break-after:always !important;
    }

    body.pdf-share-mode .situation-view-wrapper > aside > div:first-of-type {
        margin-top: 70px !important;
    }


    /* Linke Spalte (Share) */
    body.pdf-share-mode .situation-view-wrapper > div.flex-1,
    body.pdf-share-mode .print-offer-view > div.flex-1{
        flex:0 0 750px !important;
        width:750px !important;
        max-width:750px !important;
        box-sizing:border-box !important;
        overflow:hidden !important;
    }

    /* Rechte Sidebar (Share) */
    body.pdf-share-mode .situation-view-wrapper > aside,
    body.pdf-share-mode .print-offer-view > aside{
        display:flex !important;
        flex:0 0 300px !important;
        width:300px !important;
        max-width:300px !important;
        box-sizing:border-box !important;
        background:#f3f4f6 !important;
        padding:15px !important;
        border-radius:8px !important;
        overflow:hidden !important;
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
    }

    /* ===== Share-PDF: Cover & Feedback vollflächig ===== */
    body.pdf-share-mode .share-cover,
    body.pdf-share-mode .share-outro{
        width:1122px !important;
        height:794px !important;
        min-width:1122px !important;
        max-width:1122px !important;
        min-height:794px !important;
        max-height:794px !important;
        margin:0 !important;
        page-break-after:always !important;
        overflow:hidden !important;
    }


/* ===== SHARE PDF: Intro/Outro vertikal sauber & besser gefüllt ===== */
body.pdf-share-mode .share-page-content > .share-cover{
  height:100% !important;
  min-height:100% !important;
  display:flex !important;
  align-items:center !important;
  justify-content:center !important;
}
body.pdf-share-mode .share-page-content > .share-cover .share-cover-inner{
  transform: scale(1.06) !important;
  transform-origin: center !important;
}
/* Outro: keine Folgeseite erzwingen */
body.pdf-share-mode .share-page:last-child{
  page-break-after:auto !important;
  break-after:auto !important;
}


    /* ===== PRINT: Seite 2 Canvas-Mehrplatz Patch v1 ===== */
    /* Farben/Hintergründe im Druck erzwingen */
    *{
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
        color-adjust: exact !important;
    }

    /* Seite 2: Hintergrund wieder aktiv (falls transparent/weiß) */
    .print-offer-view{
        background: #f0f6ff !important;
    }

    /* "Kostenübersicht & Abschluss" vertikal stauchen (Breite bleibt gleich) */
    .situation-view-wrapper aside .bg-white.rounded-xl.p-4.shadow-sm{
        padding-top: 6px !important;
        padding-bottom: 6px !important;
        margin-top: auto !important;
        transform: none !important;
    }

    .situation-view-wrapper aside h3{
        margin: 0 0 4px 0 !important;
        padding: 0 !important;
        font-size: 0.85rem !important;
        line-height: 1.1 !important;
    }

    .cost-grid-years{
        gap: 3px !important;
    }
    .cost-grid-years > div{
        padding: 2px 4px !important;
        font-size: 0.75rem !important;
        line-height: 1.05 !important;
    }

    .situation-view-wrapper aside input,
    .situation-view-wrapper aside select{
        padding-top: 2px !important;
        padding-bottom: 2px !important;
        height: 26px !important;
        font-size: 0.75rem !important;
    }

    /* Canvas 1/2/3 sollen den gewonnenen Platz nach unten nutzen */
    .situation-view-wrapper > aside{
        display: flex !important;
        flex-direction: column !important;
        align-items: stretch !important;
        height: 100% !important;
    }

    .situation-view-wrapper aside .flex.flex-col.gap-4{
        gap: 8px !important;
        flex: 1 1 auto !important;
        min-height: 0 !important;
    }

    .offer-canvas-container{
        flex: 1 1 auto !important;
        min-height: 320px !important;
        margin-bottom: 6px !important;
    }



    /* ================================
       PRINT PATCH: Kostenblock in Seite 2 nach UNTEN schieben
       (Breite bleibt gleich)
       ================================ */
    .situation-view-wrapper > aside{
        display: flex !important;
        flex-direction: column !important;
        align-items: stretch !important;
        justify-content: flex-start !important; /* Canvas oben, Kosten unten via margin-top:auto */
        height: 100% !important;
        min-height: 0 !important;
    }

    /* Canvas-Stack soll den Raum oben füllen */
    .situation-view-wrapper > aside .flex.flex-col.gap-4{
        flex: 1 1 auto !important;
        min-height: 0 !important;
    }

    /* Kostenübersicht-Block (weiße Karte) an den unteren Rand */
    .situation-view-wrapper > aside .bg-white.rounded-xl.p-4.shadow-sm{
        margin-top: auto !important;
        order: 99 !important;
    }

    /* Canvas-Container: bleiben oberhalb, dürfen wachsen */
    .offer-canvas-container{
        order: 1 !important;
        flex: 1 1 auto !important;
        min-height: 300px !important;
    }
}



    /* ===== PRINT ONLY: Stammdaten (Kundentyp + Segment) untereinander & volle Breite ===== */
    @media print {
        /* Der echte Wrapper in deiner Datei: grid grid-cols-2 gap-2 mb-2 shrink-0 */
        .situation-view-wrapper .grid.grid-cols-2.gap-2.mb-2.shrink-0{
            grid-template-columns: 1fr !important; /* statt 2 Spalten -> 1 Spalte */
            gap: 10px !important;
        }
        .situation-view-wrapper .grid.grid-cols-2.gap-2.mb-2.shrink-0 > div{
            width: 100% !important;
        }
        .situation-view-wrapper .grid.grid-cols-2.gap-2.mb-2.shrink-0 select{
            width: 100% !important;
        }
    }

    
    /* --- PATCH v50_23: Zentrierung + digitale Sichtbarkeit --- */
    .offer-cost-input{
        width:100% !important;
        padding-top:0 !important;
        padding-bottom:0 !important;
        line-height:3rem !important; /* h-12 */
        text-align:center !important;
    }
    .offer-meta-input{
        padding-top:0 !important;
        padding-bottom:0 !important;
        line-height:3rem !important; /* h-12 */
    }

    /* --- FIX: Kosten-Grid bleibt "on point" (statische 3-Spalten-Struktur, Screen + Share) --- */
.cost-grid-years{
    display: grid !important;
    width: 100% !important;
    grid-template-columns: repeat(3, 1fr) !important; /* 3 Spalten IMMER vorhanden */
    gap: 1rem !important;
    transition: none !important;
}

/* 2. Jahr: Container bleibt im Layout, wird nur unsichtbar geschaltet */
.year-2-container{
    transition: opacity 0.2s ease-in-out;
}
.year-2-container.hidden-layer{
    opacity: 0 !important;
    visibility: hidden !important;
    pointer-events: none !important;
    /* KEIN display:none -> Grid darf nicht kollabieren */
}

/* nichts darf ausbrechen -> verhindert Versatz */
.cost-grid-years > *{
    min-width: 0 !important;
    width: 100% !important;
}
.offer-cost-input{
    width: 100% !important;
    text-align: center !important;
}

/* ===== SHARE COVER/OUTRO STYLES (nur im Iframe Share-PDF) ===== */
.share-cover, .share-outro{
  width:100%;
  box-sizing:border-box;
  min-height:520px;
  border-radius:22px;
  padding:28px;
  background: linear-gradient(135deg,#001942 0%,#0050ff 100%);
  color:#fff;
  overflow:hidden;
}
.share-cover-inner{max-width:980px;margin:0 auto;text-align:center;}
.share-cover-badge{font-weight:900;font-size:11px;letter-spacing:0.45em;color:rgba(255,255,255,0.70);margin-top:10px;}
.share-cover-title{font-weight:1000;font-size:78px;line-height:0.92;letter-spacing:-0.04em;margin-top:18px;}
.share-cover-title-accent{color:#7dd3fc;}
.share-cover-date{margin-top:14px;font-weight:900;letter-spacing:0.25em;font-size:13px;color:rgba(255,255,255,0.80);}
.share-cover-card{margin:34px auto 0 auto;max-width:760px;background:rgba(255,255,255,0.10);border:1px solid rgba(255,255,255,0.18);border-radius:28px;padding:26px;position:relative;}
.share-cover-chip{position:absolute;left:50%;top:-14px;transform:translateX(-50%);background:#2563eb;color:#fff;padding:6px 16px;border-radius:999px;font-weight:900;font-size:10px;letter-spacing:0.18em;}
.share-cover-shop-name{font-size:26px;font-weight:1000;letter-spacing:-0.02em;}
.share-cover-shop-addr{margin-top:6px;color:rgba(255,255,255,0.82);font-weight:600;font-size:13px;}

.share-outro-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:18px;max-width:1060px;margin:0 auto;}
.share-outro-card{background:rgba(255,255,255,0.10);border:1px solid rgba(255,255,255,0.18);border-radius:28px;padding:22px;text-align:center;}
.share-outro-card-focus{border-color:rgba(59,130,246,0.55);background:rgba(255,255,255,0.12);transform:scale(1.02);}
.share-outro-icon{width:56px;height:56px;border-radius:18px;background:rgba(255,255,255,0.12);display:flex;align-items:center;justify-content:center;margin:0 auto 14px auto;font-weight:1000;}
.share-outro-h{font-size:18px;font-weight:1000;letter-spacing:-0.02em;}
.share-outro-p{margin-top:8px;font-size:11px;color:rgba(255,255,255,0.80);line-height:1.35;}
.share-outro-small{font-size:10px;color:rgba(255,255,255,0.70);font-weight:700;}
.share-outro-qr{margin:14px auto 10px auto;width:140px;height:140px;background:#fff;border-radius:18px;padding:10px;box-shadow:0 12px 30px rgba(0,0,0,0.25);}
.share-outro-qr img{width:100%;height:100%;object-fit:contain;display:block;}
.share-outro-link{font-size:9px;word-break:break-all;color:rgba(255,255,255,0.65);margin-top:6px;font-weight:800;}
.share-outro-amount{margin-top:6px;font-size:44px;font-weight:1000;color:#93c5fd;}
.share-outro-voucher{margin-top:10px;padding:12px 10px;border:2px dashed rgba(255,255,255,0.35);border-radius:18px;font-family:monospace;font-size:16px;font-weight:1000;background:rgba(0,0,0,0.18);letter-spacing:0.12em;}
/* ===== MANUELLER SHARE OFFSET (FINAL) ===== */
:root{
  --SHARE_OFFSET_X: 0px; /* + = rechts | - = links */
}

.share-cover,
.share-outro{
  margin-left: var(--SHARE_OFFSET_X);
  margin-right: auto;
}


/* ===== SHARE OFFSET OVERRIDE (wirkt beim Teilen / PDF-Share) ===== */
:root{
  --SHARE_OFFSET_X:  0px; /* + = rechts | - = links */
}
/* In Share-PDF werden Seiten als .share-page gerendert – daher hier verschieben */
.pdf-share-mode .share-page,
.pdf-share-mode .share-cover,
.pdf-share-mode .share-outro{
  margin-left: 0 !important;
  margin-right: 0 !important;
  transform: translateX(var(--SHARE_OFFSET_X)) !important;
  transform-origin: top left;
}


/* ===== SHARE PDF SAFETY (no right-cut) ===== */
.pdf-share-mode :root{ --SHARE_OFFSET_X: 0px !important; }
.pdf-share-mode .share-page,
.pdf-share-mode .share-cover,
.pdf-share-mode .share-outro{
  transform: none !important;
  margin-left: 0 !important;
  margin-right: 0 !important;
}
.pdf-share-mode html,
.pdf-share-mode body{
  overflow: visible !important;
}



    /* ================================
       FINAL PRINT PATCH (Chrome + Edge):
       Seite 2 (Ihre Aktuelle Situation)
       - definierte Seitenhoehe, damit "unten" existiert
       - Kostenblock wirklich nach unten + 30px tiefer
       - Breiten bleiben unveraendert
       ================================ */
    @media print {
      /* Seite 2: Unten definieren */
      .situation-view-wrapper{
        height: 190mm !important;
        min-height: 190mm !important;
        overflow: visible !important;
      }

      /* Rechte Spalte nutzt volle Hoehe */
      .situation-view-wrapper > aside{
        display: flex !important;
        flex-direction: column !important;
        height: 100% !important;
        min-height: 100% !important;
        overflow: visible !important;
      }

      /* Canvas-Stack fuellt den Raum oberhalb der Kosten */
      .situation-view-wrapper aside .flex.flex-col.gap-4{
        flex: 1 1 auto !important;
        min-height: 0 !important;
      }

      /* Kostenblock: ganz nach unten + extra 30px tiefer */
      .situation-view-wrapper aside .bg-white.rounded-xl.p-4.shadow-sm{
        margin-top: auto !important;
        margin-bottom: -30px !important;
        overflow: visible !important;
        transform: none !important; /* transform wird im Print oft ignoriert */
      }
    }

/* ===== PRINT PATCH: rechte Padding-Freigabe Seite 1 ===== */
@media print {
  .print-situation-view {
    padding-right: 0mm !important; /* vorher 6mm -> volle Breite */
  }
}



/* =====================================================
   PRINT PATCH v30 – Chrome: enforce 2 pages (tighter scale)
   ===================================================== */
@media print{
  /* Make offer page slightly smaller in Chrome so it never spills to an extra page */
  .print-offer-view{
    zoom: 0.76 !important; /* was 0.80-ish in Chrome */
    transform-origin: top left !important;
  }

  /* Prevent Kostenübersicht block from being pushed to a new page */
  .grid.grid-cols-2.gap-4.mt-6{
    margin-top: 0.5rem !important;
    page-break-inside: avoid !important;
    break-inside: avoid !important;
  }

  /* Reduce excessive vertical padding in offer page (Chrome is sensitive) */
  .p-6.space-y-6{
    padding: 1rem !important;
  }
}


        /* === PORTRAIT TABLET/MOBILE: Stack canvases vertically regardless of width === */
        @media (orientation: portrait){
            .offer-print-grid{
                display: flex !important;
                flex-direction: column !important;
                grid-template-columns: none !important;
                overflow-y: auto !important;
            }
            .offer-print-grid > div{
                width: 100% !important;
            }
            /* Make sure the cost section is not sticky/fixed in portrait */
            .cost-overview-print{
                position: static !important;
                bottom: auto !important;
            }
        }


/* ================================
   RESPONSIVE FIX (Portrait / schmale Displays):
   Verhindert "rechts abgeschnitten" in Hochformat,
   indem Sidebar unter den Inhalt stapelt.
   ================================ */
@media (max-width: 1024px){
  .situation-view-wrapper{
    flex-direction: column !important;
    overflow-y: auto !important;
    overflow-x: hidden !important;
  }
  /* Hauptbereich (links + Canvas) auf volle Breite */
  .situation-view-wrapper > div{
    width: 100% !important;
    max-width: 100% !important;
  }
  /* Sidebar unten statt rechts */
  .situation-view-wrapper > aside{
    display: flex !important;        /* überschreibt Tailwind "hidden" auf Mobile */
    width: 100% !important;
    min-width: 0 !important;
    height: auto !important;
    max-height: 45vh !important;     /* bleibt bedienbar */
    overflow: auto !important;
    border-left: none !important;
    border-top: 1px solid #e2e8f0 !important;
    margin-top: 10px !important;
  }
}






  /* Mittelgroße Tablets */
  @media (min-width: 700px) and (max-width: 899px) {
    .situation-view-wrapper,
    .print-situation-view,
    .print-offer-view { margin-left: -24px !important; }
  }

  /* Kleine Tablets & große Phones */
  @media (max-width: 699px) {
    .situation-view-wrapper,
    .print-situation-view,
    .print-offer-view { margin-left: -30px !important; }
  }

  .situation-view-wrapper .grid,
  .print-offer-view .grid {
    margin-left: -12px !important;
  }
}


/* === SMART Portrait Pixel-Fix (Auto) ===
   Berechnet eine dynamische Linksverschiebung per CSS-Variable
   -> nutzt linken Platz
   -> verhindert Abschneiden rechts
*/
:root{
  --PORTRAIT_SHIFT_PX: 0px;
}
@media (orientation: portrait){
  .situation-view-wrapper,
  .print-situation-view,
  .print-offer-view{
    transform: translateX(var(--PORTRAIT_SHIFT_PX)) !important;
    will-change: transform;
  }
  /* Formulare etwas weiter links (wie vorher) */
  .situation-view-wrapper .grid,
  .print-offer-view .grid{
    margin-left: -12px !important;
  }
}


/* === PORTRAIT SMART SHIFT (AUTO) ===
   Schiebt im Hochformat automatisch nach links, NUR wenn rechts etwas abgeschnitten wird.
   Die JS-Logik setzt --PORTRAIT_SHIFT_PX dynamisch (z.B. -18px / -24px / -30px).
*/
:root{ --PORTRAIT_SHIFT_PX: 0px; }

@media (orientation: portrait){
  .situation-view-wrapper,
  .print-situation-view,
  .print-offer-view{
    margin-left: var(--PORTRAIT_SHIFT_PX) !important;
  }
}



/* ================================================
   FULLSCREEN LANDSCAPE FIX
   Verhindert Rechts-Abschneiden im Vollbildmodus
   (nur Landscape + breite Viewports)
   ================================================ */
:root{
  --FULLSCREEN_SHIFT_X: -26px;   /* Feintuning: -18px bis -32px möglich */
}
@media (orientation: landscape) and (min-width: 1100px){
  .situation-view-wrapper,
  .print-situation-view,
  .print-offer-view{
    transform: translateX(var(--FULLSCREEN_SHIFT_X)) !important;
    will-change: transform;
  }
  .situation-view-wrapper .grid,
  .print-offer-view .grid{
    margin-left: calc(var(--FULLSCREEN_SHIFT_X) * 0.5) !important;
  }
}

/* === PRINT HARD FIX: FORCE A4 LANDSCAPE (NO LETTER) === */
@media print {

  @page {
    size: A4 landscape;
    margin: 0;
  }

  html, body {
    width: 297mm !important;
    height: 210mm !important;
    margin: 0 !important;
    padding: 0 !important;
    overflow: visible !important;
    -webkit-print-color-adjust: exact !important;
    print-color-adjust: exact !important;
  }

  #root {
    width: 297mm !important;
    min-width: 297mm !important;
    max-width: 297mm !important;
    transform: none !important;
  }

  /* Hide UI while printing */
  .no-print, button, .toolbar, .top-toolbar, .floating-toolbar {
    display: none !important;
  }
}






/* =============================================================================
   FINAL_LOCK v7 – Share-PDF CENTERFIX (minimal, sicher)
   NUR beim Teilen/PDF (body.pdf-share-mode)
   -> behebt linken Anschnitt, ohne Layout/Background/Zoom zu überschreiben
   -> STRG+P bleibt unberührt
============================================================================= */
body.pdf-share-mode .situation-view-wrapper{
  padding-left: 30px !important; /* +10px Puffer links */
}
body.pdf-share-mode .print-offer-view{
  padding-left: 30px !important; /* +10px Puffer links */
}


/* =============================================================================
   FINAL_LOCK v8 – Share-PDF FULLBLEED (keine weißen Flächen)
   NUR beim Teilen/PDF (body.pdf-share-mode)
   -> füllt Seite 2 & 3 vollflächig mit Hintergrund (ohne zu schneiden)
   -> STRG+P bleibt unberührt
============================================================================= */
body.pdf-share-mode .share-page{
  background: #f0f6ff !important; /* gleiche Fläche wie deine Inhaltsseiten */
}
body.pdf-share-mode .share-page-content{
  width: 100% !important;
  height: 100% !important;
  margin: 0 !important;
  padding: 0 !important;
  box-sizing: border-box !important;
}
/* Wrapper von Seite 2 & 3 auf volle Seitenbreite ziehen (kein fixed 1050px) */
body.pdf-share-mode .situation-view-wrapper,
body.pdf-share-mode .print-offer-view{
  width: 100% !important;
  max-width: 100% !important;
  min-width: 0 !important;
  height: 100% !important;
  box-sizing: border-box !important;
  background: transparent !important; /* Hintergrund kommt von .share-page */
  /* bestehenden Padding behalten, inkl. +10px Centerfix links */
  padding-right: 20px !important;
}


/* ===== Share-PDF: Rechte Seiten-Header vertikal ===== */
body.pdf-share-mode .share-vertical-header {
    position: absolute;
    top: 50%;
    right: 8px;
    transform: translateY(-50%) rotate(90deg);
    transform-origin: center;
    font-size: 18px;
    font-weight: 700;
    letter-spacing: 0.5px;
    color: #1e3a8a;
    opacity: 0.85;
    pointer-events: none;
    white-space: nowrap;
}


/* ===== Share PDF: Rechter Rand – Weißer Rahmen + zentrierter vertikaler Text ===== */
.side-header-vertical {
    position: absolute;
    right: 4px;
    top: 6px;
    bottom: 6px;
    width: 46px;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    z-index: 50;
    background: white;
    border-radius: 16px;
    box-shadow: 0 0 0 1px rgba(0,0,0,0.08);
}

.side-header-text {
    writing-mode: vertical-rl;
    text-orientation: upright;
    transform: none;
    white-space: nowrap;
    font-size: 22px;
    font-weight: 900;
    color: #0b1e42;
    text-transform: uppercase;
    letter-spacing: 2px;
    opacity: 0.9;
    display: flex;
    align-items: center;
    justify-content: center;
}

</style>

<style id="export-hardlock-patch-v1">
/* === EXPORT HARDLOCK: kills milky/transparent look in print/share engines === */
@media print {
  html, body, #root {
    background-color: #ffffff !important;
    background: #ffffff !important;
    -webkit-print-color-adjust: exact !important;
    print-color-adjust: exact !important;
    filter: none !important; /* disable global page filters during print */
    min-width: 1120px !important;
  }
  *, *::before, *::after {
    -webkit-print-color-adjust: exact !important;
    print-color-adjust: exact !important;
  }
  @page { size: A4 landscape !important; margin: 0.5cm !important; }
  .situation-view-wrapper, .print-offer-view {
    /* PRINT-FIT: nicht hart auf 1120px fixieren */
    width: 100% !important;
    max-width: 100% !important;
    margin: 0 auto !important;
    background: #ffffff !important;
  }
}

/* Share/PDF mode (html2pdf clone sets body.pdf-share-mode) */
body.pdf-share-mode, body.pdf-share-mode #root, body.pdf-share-mode .pdf-share-pdf-container,
body.pdf-share-mode .situation-view-wrapper, body.pdf-share-mode .print-offer-view {
  background-color: #ffffff !important;
  background: #ffffff !important;
  filter: none !important;
  -webkit-print-color-adjust: exact !important;
  print-color-adjust: exact !important;
}
body.pdf-share-mode *, body.pdf-share-mode *::before, body.pdf-share-mode *::after {
  -webkit-print-color-adjust: exact !important;
  print-color-adjust: exact !important;
}

/* Optional: manual export flag */
body.exporting, body.exporting #root { filter:none !important; background:#fff !important; }
</style>


<!-- === PRINT CHROME FIX v28: force A4 landscape on ALL pages + hard page breaks === -->
<style id="print-chrome-fix-v28">
@page { size: A4 landscape; margin: 0.5cm; }

/* Chrome sometimes applies @page only to first page when multiple conflicting print blocks exist.
   This override enforces landscape sizing + deterministic 2-page layout. */
@media print{
  html, body{
    width: 297mm !important;
    max-width: 297mm !important;
    margin: 0 !important;
    padding: 0 !important;
    background: #ffffff !important;
  }

  /* Ensure our main print pages behave like real pages */
  .print-page{
    width: 287mm !important; /* 297mm - margins */
    max-width: 287mm !important;
    box-sizing: border-box !important;
    break-after: page !important;
    page-break-after: always !important;
    break-inside: avoid !important;
    page-break-inside: avoid !important;
  }
  .print-page:last-of-type{
    break-after: auto !important;
    page-break-after: auto !important;
  }

  /* Fallback: if your layout uses named wrappers instead of .print-page */
  .print-situation-view, .print-offer-view{
    break-inside: avoid !important;
    page-break-inside: avoid !important;
  }

  /* Avoid nested @media print side-effects: kill any accidental nested print zoom scaling */
  .bundle-import-wrap{
    zoom: 1 !important;
    transform: none !important;
  }
}

  /* v29: Chrome prints 4 pages because share-safe-stage (pdf-share pages) are still present.
     For paper print (Ctrl+P) we hide the share stage completely. */
  body.force-paper-print .share-safe-stage,
  body.force-paper-print .share-safe-stage *{
    display: none !important;
  }
</style>

</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useMemo, useCallback } = React;

        // --- 0. ICONS ---
        const Icon = ({ d, size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <g dangerouslySetInnerHTML={{ __html: d }} />
            </svg>
        );

        const ICONS = {
            Search: '<circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/>',
            User: '<path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/>',
            Activity: '<path d="M22 12h-4l-3 9L9 3l-3 9H2"/>',
            Smartphone: '<rect width="14" height="20" x="5" y="2" rx="2" ry="2"/><path d="M12 18h.01"/>',
            Plus: '<path d="M5 12h14"/><path d="M12 5v14"/>',
            Home: '<path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/>',
            Monitor: '<rect width="20" height="14" x="2" y="3" rx="2"/><line x1="8" x2="16" y1="21" y2="21"/><line x1="12" x2="12" y1="17" y2="21"/>',
            Cast: '<path d="M2 16.1A5 5 0 0 1 5.9 20"/><path d="M2 12.05A9 9 0 0 1 9.95 20"/><path d="M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6"/><line x1="2" x2="2.01" y1="20" y2="20"/>',
            Menu: '<line x1="4" y1="12" x2="20" y2="12"/><line x1="4" y1="6" x2="20" y2="6"/><line x1="4" y1="18" x2="20" y2="18"/>',
            Wallet: '<path d="M20 12V8H6a2 2 0 0 1-2-2c0-1.1.9-2 2-2h12v4"/><path d="M4 6v12c0 1.1.9 2 2 2h14v-4"/><path d="M18 12a2 2 0 0 0 0 4h4v-4z"/>',
            X: '<path d="M18 6 6 18"/><path d="m6 6 18 18"/>',
            Pen: '<path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/>',

            Fountain: '<path d="M12 2l4 8-4 12-4-12 4-8Z"/><path d="M12 10v10"/><path d="M9.5 13.5h5"/>',
            Ballpen: '<path d="M7 3h10l1 4H6l1-4Z"/><path d="M8 7v12l4 2 4-2V7"/><path d="M10 11h4"/><path d="M12 21v1"/>',
            Keyboard: '<rect width="20" height="16" x="2" y="4" rx="2"/><path d="M12 18h.01"/><path d="M8 8h.01"/><path d="M12 8h.01"/><path d="M16 8h.01"/><path d="M8 12h.01"/><path d="M12 12h.01"/><path d="M16 12h.01"/><path d="M8 16h.01"/><path d="M12 16h.01"/><path d="M16 16h.01"/>',
            Eraser: '<path d="m2.9 15.8a2.9 2.9 0 0 0 9.9 0l5.6-5.6a2.9 2.9 0 0 0-4.2-4.2l-5.6 5.6c-.4.4-.5 1.05-.2 1.6"/><path d="m11 7 5.3 5.3"/><path d="M22 21H7"/>',
            Palette: '<circle cx="13.5" cy="6.5" r=".5" fill="currentColor"/><circle cx="17.5" cy="10.5" r=".5" fill="currentColor"/><circle cx="8.5" cy="7.5" r=".5" fill="currentColor"/><circle cx="6.5" cy="12.5" r=".5" fill="currentColor"/><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"/>',
            Wifi: '<path d="M5 12.55a11 11 0 0 1 14.08 0"/><path d="M1.42 9a16 16 0 0 1 21.16 0"/><path d="M8.53 16.11a6 6 0 0 1 6.95 0"/><line x1="12" x2="12.01" y1="20" y2="20"/>',
            Zap: '<polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/>',
            Globe: '<circle cx="12" cy="12" r="10"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10z"/><path d="M2 12h20"/>',
            Gauge: '<path d="m12 15 3.5-3.5"/><path d="M20.3 18c.6-1 .9-2.2.9-3.5a9 9 0 1 0-9 9c1.3 0 2.5-.3 3.5-.9"/>',
            Calculator: '<rect width="16" height="20" x="4" y="2" rx="2"/><line x1="8" x2="16" y1="6" y2="6"/><line x1="16" x2="16" y1="14" y2="18"/><path d="M16 10h.01"/><path d="M12 10h.01"/><path d="M8 10h.01"/><path d="M12 14h.01"/><path d="M8 14h.01"/><path d="M12 18h.01"/><path d="M8 18h.01"/>',
            ArrowRight: '<path d="M5 12h14"/><path d="m12 5 7 7-7 7"/>',
            ArrowLeft: '<path d="m12 19-7-7 7-7"/><path d="M19 12H5"/>',
            Highlighter: '<path d="m9 11-6 6v3h9l3-3"/><path d="m22 12-4.6-4.6a2 2 0 0 0-2.8 0l-5.2 5.2a2 2 0 0 0 0 2.8l4.6 4.6"/><path d="m5.7 5.7 3.1 3.1"/>',
            FileText: '<path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><line x1="16" x2="8" y1="13" y2="13"/><line x1="16" x2="8" y1="17" y2="17"/><line x1="10" x2="8" y1="9" y1="9"/>',
            CheckCircle: '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><path d="m9 11 3 3L22 4"/>',
            AlertCircle: '<circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="12"/><line x1="12" x2="12.01" y1="16" y2="16"/>',
            Phone: '<path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/>',
            Tv: '<rect width="20" height="15" x="2" y="7" rx="2" ry="2"/><polyline points="17 2 12 7 7 2"/>',
            Router: '<rect width="20" height="8" x="2" y="14" rx="2"/><path d="M6.01 18h.01"/><path d="M10.01 18h.01"/><path d="M15 10v4"/><path d="M17.84 7.17a4 4 0 0 0-5.66 0"/><path d="M20.66 4.34a8 8 0 0 0-11.31 0"/>',
            Layers: '<path d="m12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83Z"/><path d="m22 17.65-9.17 4.16a2 2 0 0 1-1.66 0L2 17.65"/><path d="m22 12.65-9.17 4.16a2 2 0 0 1-1.66 0L2 12.65"/>',
            Disc: '<circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="3"/>',
            Lock: '<rect width="18" height="11" x="3" y="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/>',
            Trash: '<path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/>',
            Bold: '<path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"/><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"/>',
            Italic: '<line x1="19" y1="4" x2="10" y2="4"/><line x1="14" y1="20" x2="5" y2="20"/><line x1="15" y1="4" x2="9" y1="20"/>',
            Type: '<polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/>',
            List: '<line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line>',
            Clipboard: '<rect x="9" y="4" width="6" height="6" rx="1"/><path d="M15 8h.01"/><path d="M15 12h.01"/><path d="M15 16h.01"/><path d="M9 8h.01"/><path d="M9 12h.01"/><path d="M9 16h.01"/><rect x="3" y="2" width="18" height="20" rx="2"/>',
            Sun: '<circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/>',
            Users: '<path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/>',
            Maximize: '<path d="M8 3v3a2 2 0 0 1-2 2H3"/><path d="M21 8h-3a2 2 0 0 1-2-2V3"/><path d="M3 16h3a2 2 0 0 1 2 2v3"/><path d="M16 21v-3a2 2 0 0 1 2-2h3"/>',
            Minimize: '<path d="M8 3v3a2 2 0 0 1-2 2H3"/><path d="M21 8h-3a2 2 0 0 1-2-2V3"/><path d="M3 16h3a2 2 0 0 1 2 2v3"/><path d="M16 21v-3a2 2 0 0 1 2-2h3"/>', 
            ZoomIn: '<circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/>', 
            ZoomOut: '<circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/>', 
            RotateCcw: '<path d="M3 6.02v0a8 8 0 1 0 17.65 4.39"/>', 
            Camera: '<path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/>',
            Folder: '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>', 
            RefreshCw: '<path d="M21 2v6h-6"/><path d="M21 13a9 9 0 1 1-3-7.7L21 8"/>', 
            Square: '<rect width="18" height="18" x="3" y="3" rx="2" ry="2"/>',
            Book: '<path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1-2.5-2.5zM20 18H6.5a.5.5 0 0 0-.5.5V20h14z"/>',
            Signature: '<path d="M17 3a2.85 2.85 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/>', 
            Share: '<path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/><polyline points="16 6 12 2 8 6"/><line x1="12" x2="12" y1="2" y2="15"/>',
            EraserLine: '<path d="m5 20 5-5-2-2-5 5-2 2z"/><path d="M22 12 18 8 14 12 18 16Z"/><path d="M5 20 9 16"/><path d="M18 8 22 12"/>',
            Gift: '<polyline points="20 12 20 22 4 22 4 12"/><rect x="2" y="7" width="20" height="5"/><line x1="12" y1="22" x2="12" y2="7"/><path d="M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z"/><path d="M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z"/>',
            Print: '<polyline points="6 9 6 2 18 2 18 9"></polyline><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><rect x="6" y="14" width="12" height="8"></rect>'
        };

        // ===== Pencil Analytics (local, DSGVO-safe: no content stored) =====
        const ANALYTICS_STORAGE_KEY = 'pencil_analytics_v1';
        const STATS_PASSWORD = 'hetec2026'; // <-- ändern

        const loadAnalyticsRows = () => {
            try { return JSON.parse(localStorage.getItem(ANALYTICS_STORAGE_KEY) || '[]'); } catch(e){ return []; }
        };
        const saveAnalyticsRows = (rows) => {
            localStorage.setItem(ANALYTICS_STORAGE_KEY, JSON.stringify(rows));
        };
        const clearAnalyticsRows = () => {
            localStorage.removeItem(ANALYTICS_STORAGE_KEY);
        };

        const buildCanvasStatsFromDrawnStrokes = (drawnStrokes, textData = {}, extra = {}) => {
            const stats = {};
            const ensure = (key) => {
                if (!stats[key]) stats[key] = { used: false, strokes: 0 };
                return stats[key];
            };
            // 1) Ink / strokes
            if (drawnStrokes) {
// Helper: sum of distances between consecutive points (canvas CSS px)
const calcInkLengthPx = (strokesArr) => {
    if (!Array.isArray(strokesArr)) return 0;
    let len = 0;
    for (const s of strokesArr) {
        const pts = (s && Array.isArray(s.points)) ? s.points : [];
        for (let i = 1; i < pts.length; i++) {
            const p0 = pts[i-1] || {};
            const p1 = pts[i] || {};
            const dx = (p1.x ?? 0) - (p0.x ?? 0);
            const dy = (p1.y ?? 0) - (p0.y ?? 0);
            // Ignore NaN
            if (!Number.isFinite(dx) || !Number.isFinite(dy)) continue;
            len += Math.hypot(dx, dy);
        }
    }
    return len;
};

for (const [key, strokes] of Object.entries(drawnStrokes)) {
    const count = Array.isArray(strokes) ? strokes.length : 0;
    // nur relevante Felder loggen (Situation/Offer/Cost/Signature/Skip)
    const allowed = (
        key.startsWith('sit_') ||
        key.startsWith('offer') ||
        key.startsWith('cost_') ||
        key.startsWith('agent_') ||
        key.startsWith('date_') ||
        key.startsWith('signature') ||
        key.startsWith('skip_') ||
        key.startsWith('skip') || // safety
        key === 'skip_reason'       // small input canvas
    );
    if (!allowed) continue;

    ensure(key).strokes = count;

    // ✅ Anti-Cheat (Pen): counts as "used" only if strokes ≥ 2 AND ink length ≥ 80px.
    // Signature stays relaxed (any stroke counts), otherwise customers get stuck.
    const inkLen = calcInkLengthPx(strokes);
    if (key.startsWith('signature')) {
        if (count > 0) ensure(key).used = true;
    } else {
        if (count >= 2 && inkLen >= 80) ensure(key).used = true;
    }
}

            }

            // 2) Digital text -> counts as "used" when >= 5 Zeichen
            const minChars = 5;
            const getTextLen = (v) => {
                if (v == null) return 0;
                const s = String(v).trim();
                return s.length;
            };

            const map = {
                sit_Kundenname: () => textData.Kundenname,
                sit_Rufnummer: () => textData.Rufnummer,
                sit_Anbieter: () => textData.Anbieter,
                sit_Hardware: () => textData.Hardware,
                sit_Nutzung: () => textData.Nutzung,
                sit_Haushalt: () => textData.Haushalt,
                sit_WeitereProdukte: () => (textData['Weitere Produkte'] ?? textData.WeitereProdukte),
                sit_Fernsehen: () => textData.Fernsehen,
                sit_WiFi: () => textData.WiFi,
                sit_Gesamtkosten: () => textData.Gesamtkosten,
                offer1: () => textData.offer1,
                offer2: () => textData.offer2,
                offer3: () => textData.offer3,
                cost_einmalig: () => textData.cost_einmalig,
                cost_monatlich1: () => textData.cost_monatlich1,
                cost_monatlich2: () => textData.cost_monatlich2,
                agent_name: () => textData.AgentName,
                date_field: () => textData.DateValue,
                skip_reason: () => (extra.skipReason ?? textData.skip_reason)
            };

            for (const [key, getter] of Object.entries(map)) {
                const len = getTextLen(getter());
                // ensure key exists (so it appears as column even if empty)
                ensure(key);
                // only upgrade used flag; do not downgrade pen usage
                if (len >= minChars) stats[key].used = true;
            }

            return stats;
        };

        const appendAnalyticsRow = (row) => {
            const rows = loadAnalyticsRows();
            rows.push(row);
            saveAnalyticsRows(rows);
            return row;
        };

        const downloadTextFile = (filename, text, mime='text/plain') => {
            const blob = new Blob([text], { type: mime });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        };

        const rowsToCSV_Summary = (rows) => {
            // Compact, Excel-friendly export:
            // - one row per Vorgang
            // - per field only *_used (0/1)
            // - totals for quick pivots
            if (!rows || !rows.length) return 'ts,date,user,shop,result,used_total,strokes_total\n';
            const flat = rows.map(r => {
                const base = { ts: r.ts, date: (r.ts||'').slice(0,10), user: r.user, shop: r.shop, result: r.result };
                const cs = r.canvasStats || {};
                let usedTotal = 0;
                let strokesTotal = 0;
                for (const [k,v] of Object.entries(cs)) {
                    const used = v && v.used ? 1 : 0;
                    const strokes = Number(v && v.strokes ? v.strokes : 0) || 0;
                    base[`${k}_used`] = used;
                    usedTotal += used;
                    strokesTotal += strokes;
                }
                base.used_total = usedTotal;
                base.strokes_total = strokesTotal;
                return base;
            });

            const colsSet = new Set();
            flat.forEach(o => Object.keys(o).forEach(k => colsSet.add(k)));
            // keep common columns first, then the rest alpha
            const preferred = ['ts','date','user','shop','result','used_total','strokes_total'];
            const rest = Array.from(colsSet).filter(c => !preferred.includes(c)).sort((a,b)=>a.localeCompare(b));
            const cols = [...preferred.filter(c=>colsSet.has(c)), ...rest];

            const esc = (v) => {
                const s = String(v ?? '');
                return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
            };
            const header = cols.join(',');
            const lines = flat.map(o => cols.map(c => esc(o[c])).join(','));
            return [header, ...lines].join('\n');
        };

        const rowsToCSV_Fields = (rows) => {
            // Long / tidy export:
            // one row per (Vorgang x Field) for easy pivot charts
            const header = 'ts,date,user,shop,result,field,used,strokes\n';
            if (!rows || !rows.length) return header;
            const lines = [];
            for (const r of rows) {
                const base = [r.ts, (r.ts||'').slice(0,10), r.user, r.shop, r.result];
                const cs = r.canvasStats || {};
                for (const [k,v] of Object.entries(cs)) {
                    const used = v && v.used ? 1 : 0;
                    const strokes = Number(v && v.strokes ? v.strokes : 0) || 0;
                    const row = [...base, k, used, strokes];
                    // basic CSV escaping
                    lines.push(row.map(x => {
                        const s = String(x ?? '');
                        return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
                    }).join(','));
                }
            }
            return header.trimEnd() + '\n' + lines.join('\n');
        };

        const exportAnalyticsJSON = () => {
            const rows = loadAnalyticsRows();
            const ym = new Date().toISOString().slice(0,7);
            downloadTextFile(`Analytics_${ym}.json`, JSON.stringify(rows, null, 2), 'application/json');
        };
        const exportAnalyticsCSV = () => {
            const rows = loadAnalyticsRows();
            const ym = new Date().toISOString().slice(0,7);
            // 1) compact summary (recommended)
            downloadTextFile(`Analytics_${ym}_summary.csv`, rowsToCSV_Summary(rows), 'text/csv');
            // 2) long format (perfect for Pivot by field)
            downloadTextFile(`Analytics_${ym}_fields.csv`, rowsToCSV_Fields(rows), 'text/csv');
        };


        // --- HIDA / HeTec Logo (inline SVG, print-safe) ---
        const HIDA_LOGO_SVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 720 190">
  <rect width="100%" height="100%" fill="transparent"/>
  <text x="360" y="55" text-anchor="middle" font-size="36" letter-spacing="6"
        fill="#9ca3af" font-family="Arial, Helvetica, sans-serif">— SHOP —</text>
  <text x="360" y="120" text-anchor="middle" font-size="96" font-weight="600"
        fill="#9ca3af" font-family="Arial, Helvetica, sans-serif">HeTec</text>
  <text x="360" y="170" text-anchor="middle" font-size="34" letter-spacing="8"
        fill="#2dd4bf" font-family="Arial, Helvetica, sans-serif">WIR GESTALTEN ZUKUNFT</text>
</svg>`;
        const HIDA_LOGO_DATA_URI = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(HIDA_LOGO_SVG);


        // --- 1. DATA CONFIG ---
        const ALL_LANGUAGES = [{code:'de',name:'Deutsch',flag:'🇩🇪',languageCode:'de'},{code:'ar',name:'Arabisch',flag:'🇸🇦',languageCode:'ar'},{code:'en',name:'Englisch',flag:'🇬🇧',languageCode:'en'},{code:'el',name:'Griechisch',flag:'🇬🇷',languageCode:'el'},{code:'it',name:'Italienisch',flag:'🇮🇹',languageCode:'it'},{code:'pl',name:'Polnisch',flag:'🇵🇱',languageCode:'pl'},{code:'pt',name:'Portugiesisch',flag:'🇵🇹',languageCode:'pt'},{code:'ro',name:'Rumänisch',flag:'🇷🇴',languageCode:'ro'},{code:'es',name:'Spanisch',flag:'🇪🇸',languageCode:'es'},{code:'tr',name:'Türkisch',flag:'🇹🇷',languageCode:'tr'}];
        const SORTED_LANGUAGES = [ALL_LANGUAGES.find(l=>l.code==='de'),...ALL_LANGUAGES.filter(l=>l.code!=='de').sort((a,b)=>a.name.localeCompare(b.name))];
        const SITUATION_ITEMS = [
            { id: 'Kundenname', label: 'Kundenname', icon: ICONS.Search }, { id: 'Rufnummer', label: 'Rufnummer', icon: ICONS.User }, { id: 'Anbieter', label: 'Anbieter', icon: ICONS.Activity }, { id: 'Hardware', label: 'Hardware', icon: ICONS.Smartphone },
            { id: 'Nutzung', label: 'Nutzung', icon: ICONS.Plus }, { id: 'Haushalt', label: 'Haushalt', icon: ICONS.Home }, { id: 'Weitere Produkte', label: 'Weitere Produkte', icon: ICONS.Monitor }, { id: 'Fernsehen', label: 'Fernsehen', icon: ICONS.Cast },
            { id: 'WiFi', label: 'WiFi', icon: ICONS.Menu }, { id: 'Gesamtkosten', label: 'Gesamtkosten', icon: ICONS.Wallet }
        ];
        
        const STATIC_LABELS = { 
            'Offer1Title': '1. Hardware, Anbieter & Nutzung', 
            'Offer2Title': '2. Haushalt und weitere Produkte', 
            'Offer3Title': '3. Fernsehen & Wi-Fi', 
            'CostHeader': 'Kostenübersicht & Abschluss', 'CostEinmalig': 'EINMALIG (€)', 'CostMonatlich1': 'MONATLICH IM 1. JAHR (€)', 'CostMonatlich': 'MONATLICH (€)', 'CostMonatlich2': 'MONATLICH IM 2. JAHR (€)', 'AgentLabel': 'PERSÖNLICHER AGENT', 'DateLabel': 'DATUM', 'ValidUntilLabel': 'ANGEBOT GÜLTIG BIS', 'Kundenname_Label': 'Kundenname', 'Rufnummer_Label': 'Rufnummer', 'Anbieter_Label': 'Anbieter', 'Hardware_Label': 'Hardware', 'Nutzung_Label': 'Nutzung', 'Haushalt_Label': 'Haushalt', 'Weitere Produkte_Label': 'Weitere Produkte', 
            'Fernsehen_Label': 'Fernsehen', 'WiFi_Label': 'WiFi', 'Gesamtkosten_Label': 'Gesamtkosten', 'StatusOpen': 'Offen', 'StatusClosed': 'Abgeschlossen', 'StatusNeutral': 'Neutral'
        };
        
        const INITIAL_QUESTIONS_DATA = { 'Kundenname': ["Wie lautet der Name?", "Rechnungsempfänger?", "Bestandskunde?"], 'Rufnummer': ["Rufnummer behalten?", "Portierung?", "Multi-SIM?"], 'Anbieter': ["Welcher Anbieter?", "Laufzeit?", "Gekündigt?"], 'Hardware': ["Aktuelles Handy?", "iOS oder Android?", "Kamera wichtig?", "Zubehör?", "Kaufdatum?"], 'Nutzung': ["Datenvolumen?", "Ausland?", "Hotspot?", "Streaming?", "5G?"], 'Haushalt': ["Personenanzahl?", "Geräte im WLAN?", "Jugendschutz?", "Smarthome?", "Partnerkarte?"], 'Weitere Produkte': ["Smartwatch?", "Tablet?", "Versicherung?", "Cloud?", "Music?"], 'Fernsehen': ["Streaming?", "Lineares TV?", "HD?", "Aufnahme?", "Mobile TV?"], 'WiFi': ["Empfang?", "Repeater?", "Router Standort?", "Wände?", "Geschwindigkeit?"], 'Gesamtkosten': ["Aktuelle Kosten?", "Budget?", "Mehrleistung?", "Zahlungsweise?", "Preisgarantie?"], 'default': ["Offene Fragen?", "Details?"] };
        const COLORS = [{ id: 'black', value: '#000000', label: 'Schwarz' }, { id: 'pencil', value: '#374151', label: 'Bleistift' }, { id: 'blue', value: '#0044ff', label: 'Blau' }, { id: 'red', value: '#ff0000', label: 'Rot' }, { id: 'green', value: '#00cc00', label: 'Grün' }, { id: 'yellow', value: '#ffcc00', label: 'Gelb' }, { id: 'pink', value: '#ff00cc', label: 'Rosa' }, { id: 'purple', value: '#8800ff', label: 'Lila' }];
        const STROKE_SIZES = [{ id: 1, width: 2, label: 'Dünn' }, { id: 2, width: 4, label: 'Mittel' }, { id: 3, width: 8, label: 'Dick' }];
        
        const MOCK_TRANSLATIONS = {
            en: {
                Offer1Title: '1. Hardware, Provider & Usage',
                Offer2Title: '2. Household and other products',
                Offer3Title: '3. TV & Wi-Fi',
                CostHeader: 'Cost Overview & Conclusion',
                CostEinmalig: 'ONE-TIME (€)',
                CostMonatlich1: 'MONTHLY IN 1ST YEAR (€)', CostMonatlich: 'MONTHLY (€)', CostMonatlich2: 'MONTHLY IN 2ND YEAR (€)',
                AgentLabel: 'PERSONAL AGENT',
                DateLabel: 'DATE',
                Kundenname_Label: 'Customer Name',
                Rufnummer_Label: 'Phone Number',
                Anbieter_Label: 'Provider',
                Hardware_Label: 'Hardware',
                Nutzung_Label: 'Usage',
                Haushalt_Label: 'Household',
                'Weitere Produkte_Label': 'Other Products',
                Fernsehen_Label: 'Television',
                WiFi_Label: 'WiFi',
                Gesamtkosten_Label: 'Total Cost',
                StatusOpen: 'Open',
                StatusClosed: 'Closed',
                StatusNeutral: 'Neutral',
                AgentName: 'Max Sampleman',
                DateValue: new Date().toLocaleDateString('en-US', { year: 'numeric', month: '2-digit', day: '2-digit' }),
                offer1: 'Example text for Offer 1: Mobile plan with unlimited data and new smartphone included.',
                offer2: 'Example text for Offer 2: Internet 1000 MBit/s fiber connection and additional devices.',
                offer3: 'Example text for Offer 3: TV streaming package and Mesh Wi-Fi solution for the entire house.',
            },
            es: {
                Offer1Title: '1. Hardware, Proveedor y Uso',
                Offer2Title: '2. Hogar y otros productos',
                CostHeader: 'Resumen de Costos y Cierre',
                CostEinmalig: 'PAGO ÚNICO (€)',
                AgentLabel: 'AGENTE PERSONAL',
                Kundenname_Label: 'Nombre del Cliente',
                AgentName: 'Max Muestras',
                offer1: 'Texto de ejemplo para Oferta 1 en español.',
            }
        };

        const SectionCard = ({ title, children, className = "" }) => (<div className={`bg-white p-3 rounded-xl border border-slate-200 shadow-sm ${className}`}><h3 className="font-bold text-slate-800 mb-2 text-[10px] uppercase tracking-wide text-slate-500 flex items-center gap-2 shrink-0">{title}</h3><div className="flex-1 min-h-0 flex flex-col justify-center">{children}</div></div>);
        const copyToClipboard = (text) => { const ta = document.createElement("textarea"); ta.value = text; document.body.appendChild(ta); document.execCommand("copy"); document.body.removeChild(ta); };

        const ImagePlacementModal = ({ isOpen, onClose, onPlace, imageName }) => { if (!isOpen) return null; const handleSelect = (key) => { onPlace(key); }; return (<div className="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/60 backdrop-blur-sm p-4 animate-in fade-in"><div className="bg-white w-full max-w-lg rounded-2xl shadow-2xl p-6 relative border border-slate-200"><h3 className="text-xl font-black text-slate-800 mb-2 flex items-center gap-2"><Icon d={ICONS.Folder} size={24} className="text-blue-600"/> Bild platzieren</h3><p className="text-sm text-slate-600 mb-6">Wählen Sie den Abschnitt, in den das Bild "<span className="font-bold truncate">{imageName}</span>" eingefügt werden soll.</p><div className="grid grid-cols-3 gap-4">{['offer1', 'offer2', 'offer3'].map((key, index) => (<button key={key} onClick={() => handleSelect(key)} className="p-4 bg-slate-50 border border-slate-200 rounded-xl text-center hover:bg-blue-100 transition-colors flex flex-col items-center justify-center min-h-[100px]"><Icon d={index === 0 ? ICONS.Smartphone : index === 1 ? ICONS.Users : ICONS.Router} size={30} className="text-slate-500 mb-1"/><span className="font-bold text-slate-700 text-sm">{index + 1}. Angebot</span></button>))}</div><div className="flex justify-end mt-6"><button onClick={() => onClose(true)} className="px-4 py-2 text-slate-500 font-medium hover:bg-slate-100 rounded-lg transition-colors">Abbrechen</button></div></div></div>); };
        
        const SignatureModal = ({ isOpen, onClose, onSign }) => {
            const canvasRef = useRef(null);
            const [isDrawingSig, setIsDrawingSig] = useState(false);
            const [hasSigned, setHasSigned] = useState(false);
            const sigConfig = { strokeWidth: 4, color: '#000000', points: [], baseWidth: 0 };
            const currentStrokeRef = useRef(null); 
            const getRelativeCoords = (e, canvas) => {
                const ne = e?.nativeEvent || e;
                // Prefer offsetX/offsetY when available (handles transformed/animated containers more reliably)
                const ox = ne?.offsetX;
                const oy = ne?.offsetY;
                if (Number.isFinite(ox) && Number.isFinite(oy)) return { x: ox, y: oy };

                const rect = canvas.getBoundingClientRect();
                const clientX = ne?.clientX ?? ne?.touches?.[0]?.clientX;
                const clientY = ne?.clientY ?? ne?.touches?.[0]?.clientY;
                if (clientX === undefined || clientY === undefined) return null;

                const cssX = clientX - rect.left;
                const cssY = clientY - rect.top;
                return { x: cssX, y: cssY };
            };
            const startDrawing = (e) => { e.preventDefault(); const canvas = canvasRef.current; if (!canvas) return; const pt = e.pointerType; if (pt && pt !== 'pen' && pt !== 'touch' && pt !== 'mouse') return; const { x: cssX, y: cssY } = getRelativeCoords(e, canvas) || {}; if (cssX == null || cssY == null) return; const ctx = canvas.getContext('2d'); /* Canvas-Context ist bereits im resizeCanvas() auf DPR skaliert, daher hier NICHT nochmal mit DPR multiplizieren. */ ctx.lineWidth = sigConfig.strokeWidth; ctx.strokeStyle = sigConfig.color; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.beginPath(); ctx.moveTo(cssX, cssY); currentStrokeRef.current = { tool: 'pen', color: sigConfig.color, width: sigConfig.strokeWidth, points: [{ x: cssX, y: cssY }], baseWidth: canvas.getBoundingClientRect().width, baseHeight: canvas.getBoundingClientRect().height }; if (canvas.setPointerCapture && e.pointerId != null) { try { canvas.setPointerCapture(e.pointerId); } catch(_) {} } setIsDrawingSig(true); };
            const draw = (e) => { if (!isDrawingSig || !currentStrokeRef.current) return; e.preventDefault(); const canvas = canvasRef.current; if (!canvas) return; const { x: cssX, y: cssY } = getRelativeCoords(e, canvas) || {}; if (cssX == null || cssY == null) return; const ctx = canvas.getContext('2d'); ctx.lineTo(cssX, cssY); ctx.stroke(); currentStrokeRef.current.points.push({ x: cssX, y: cssY }); setHasSigned(true); };
            const stopDrawing = (e) => { if (!isDrawingSig) return; e.preventDefault(); const canvas = canvasRef.current; if (!canvas) return; if (canvas.releasePointerCapture && e.pointerId != null) { try { canvas.releasePointerCapture(e.pointerId); } catch(_) {} } setIsDrawingSig(false); };
            const clearCanvas = () => { const canvas = canvasRef.current; if (!canvas) return; const ctx = canvas.getContext('2d'); ctx.clearRect(0, 0, canvas.width, canvas.height); setHasSigned(false); currentStrokeRef.current = null; };
            const handleSave = () => { const canvas = canvasRef.current; if (!canvas || !hasSigned) { onClose(); return; } const dataUrl = canvas.toDataURL('image/png'); onSign(dataUrl); onClose(); };
            const handlePaperSignature = () => { onSign('PAPER_SIGNATURE'); onClose(); };
            useEffect(() => {
            if (!isOpen) return;
            const canvas = canvasRef.current;
            if (!canvas) return;

            const resizeCanvas = () => {
                const rect = canvas.getBoundingClientRect();
                if (!rect.width || !rect.height) return;

                const dpr = window.devicePixelRatio || 1;

                // Preserve existing drawing while resizing
                const temp = document.createElement('canvas');
                temp.width = canvas.width;
                temp.height = canvas.height;
                const tctx = temp.getContext('2d');
                if (tctx) tctx.drawImage(canvas, 0, 0);

                canvas.width = Math.round(rect.width * dpr);
                canvas.height = Math.round(rect.height * dpr);

                const ctx = canvas.getContext('2d');
                if (!ctx) return;

                // Reset transform (avoid cumulative scaling) and scale once for DPR
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Draw back the preserved content into CSS pixel space
                ctx.drawImage(temp, 0, 0, rect.width, rect.height);
            };

            // Important: wait until modal layout is fully settled (animations/reflow) before measuring
            requestAnimationFrame(() => {
                requestAnimationFrame(resizeCanvas);
            });

            window.addEventListener('resize', resizeCanvas);
            return () => window.removeEventListener('resize', resizeCanvas);
        }, [isOpen]);
            if (!isOpen) return null;
            return (<div className="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/70 backdrop-blur-sm p-4 animate-in fade-in"><div className="bg-white w-full max-w-xl rounded-2xl shadow-2xl p-6 relative border border-slate-200"><h3 className="text-xl font-black text-slate-800 mb-2 flex items-center gap-2"><Icon d={ICONS.Signature} size={24} className="text-green-600"/> Kundenunterschrift</h3><p className="text-sm text-slate-600 mb-1">Bitte unterschreiben Sie mit Ihrem Finger oder Stylus in der dafür vorgesehenen Fläche.</p><button type="button" onClick={handlePaperSignature} className="text-xs text-slate-500 hover:text-slate-700 underline decoration-dotted mb-3">Papier-Unterschrift – Kunde unterschreibt klassisch auf Papier und wir machen weiter</button><div className="relative aspect-[3/2] bg-slate-50 border-2 border-dashed border-slate-300 rounded-2xl overflow-hidden mb-6 group">
    <canvas
        ref={canvasRef}
        onPointerDown={startDrawing}
        onPointerMove={draw}
        onPointerUp={stopDrawing}
        onPointerLeave={stopDrawing}
        style={{ touchAction: 'none', cursor: 'crosshair' }}
        className="absolute inset-0 w-full h-full"
    />
    {!hasSigned && (
        <div className="absolute inset-0 flex flex-col items-center justify-center pointer-events-none text-slate-400">
            <Icon d={ICONS.Pen} size={40} className="mb-2 opacity-20" />
            <p className="text-sm font-medium">Hier mit Stylus oder Finger unterschreiben</p>
        </div>
    )}
</div><div className="flex justify-between items-center mt-4"><button onClick={clearCanvas} className="px-4 py-2 text-slate-500 font-medium hover:bg-slate-100 rounded-lg transition-colors flex items-center gap-2" disabled={!hasSigned}><Icon d={ICONS.Trash} size={16}/> Löschen</button><div className="flex gap-2"><button onClick={() => onClose(true)} className="px-4 py-2 text-slate-500 font-medium hover:bg-slate-100 rounded-lg transition-colors">Abbrechen</button><button onClick={handleSave} className={`px-6 py-2 rounded-lg font-bold shadow-md transition-all flex items-center gap-2 ${hasSigned ? 'bg-green-600 text-white hover:bg-green-700' : 'bg-slate-300 text-slate-500 cursor-not-allowed'}`} disabled={!hasSigned}>Übernehmen <Icon d={ICONS.CheckCircle} size={16}/></button></div></div></div></div>);
        };

        const FinishTypeModal = ({ isOpen, onClose, onSelect }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-[60] flex items-center justify-center bg-slate-900/70 backdrop-blur-sm p-4 animate-in fade-in">
                    <div className="bg-white w-full max-w-2xl rounded-2xl shadow-2xl p-8 relative border border-slate-200">
                        <button onClick={onClose} className="absolute top-4 right-4 p-2 hover:bg-slate-100 rounded-full text-slate-400"><Icon d={ICONS.X} size={20}/></button>
                        <h3 className="text-2xl font-black text-slate-800 mb-2 text-center">Wie möchten Sie fortfahren?</h3>
                        <p className="text-slate-500 text-center mb-8">Bitte wählen Sie den Status dieses Vorgangs, um die entsprechenden Schritte einzuleiten.</p>
                        
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <button onClick={() => onSelect('deal')} className="group flex flex-col items-center justify-center p-8 bg-green-50 border-2 border-green-200 rounded-2xl hover:bg-green-100 hover:border-green-400 hover:shadow-xl transition-all">
                                <div className="w-20 h-20 bg-green-200 rounded-full flex items-center justify-center text-green-700 mb-4 group-hover:scale-110 transition-transform shadow-sm">
                                    <Icon d={ICONS.CheckCircle} size={40} />
                                </div>
                                <h4 className="text-xl font-black text-green-900 mb-2">Vertrag / Abschluss</h4>
                                <p className="text-sm text-green-700 text-center leading-relaxed">Der Kunde möchte abschließen.<br/>• Unterschrift erfassen<br/>• Freunde werben<br/>• Dokument drucken</p>
                            </button>

                            <button onClick={() => onSelect('quote')} className="group flex flex-col items-center justify-center p-8 bg-slate-50 border-2 border-slate-200 rounded-2xl hover:bg-white hover:border-blue-400 hover:shadow-xl transition-all">
                                <div className="w-20 h-20 bg-white border border-slate-200 rounded-full flex items-center justify-center text-slate-500 mb-4 group-hover:scale-110 transition-transform shadow-sm group-hover:text-blue-600">
                                    <Icon d={ICONS.Print} size={36} />
                                </div>
                                <h4 className="text-xl font-black text-slate-800 mb-2">Nur Angebot</h4>
                                <p className="text-sm text-slate-500 text-center leading-relaxed">Der Kunde benötigt Bedenkzeit.<br/>• Keine Unterschrift<br/>• Status "Offen"<br/>• Direkt drucken/speichern</p>
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const FollowUpModal = ({ isOpen, onCancel, onSave, followUpDraft, setFollowUpDraft, currentLabel, stepInfo }) => {
            if (!isOpen) return null;

            const reasonOk = (followUpDraft.reason || "").trim().length >= 3;
            const canSave = !!followUpDraft.date && !!followUpDraft.time && reasonOk;

            return (
                <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4">
                    <div className="w-full max-w-xl bg-white rounded-2xl shadow-2xl overflow-hidden">
                        <div className="p-6 border-b">
                            <div className="flex items-start justify-between gap-4">
                                <div>
                                    <h3 className="text-xl font-black text-slate-900">Folgetermin erfassen</h3>
                                    <p className="text-sm text-slate-600 mt-1">
                                        {currentLabel ? <>Offener Punkt: <span className="font-bold text-red-700">{currentLabel}</span></> : "Offener Punkt"}
                                        {stepInfo ? <span className="ml-2 text-slate-400">({stepInfo})</span> : null}
                                    </p>
                                </div>
                                <button onClick={onCancel} className="px-3 py-1.5 rounded-lg bg-slate-100 hover:bg-slate-200 text-slate-700 font-bold">Abbrechen</button>
                            </div>
                        </div>

                        <div className="p-6 space-y-4">
                            <div className="grid grid-cols-2 gap-3">
                                <div>
                                    <label className="text-xs font-bold text-slate-600">Datum *</label>
                                    <input type="date" value={followUpDraft.date} onChange={(e) => setFollowUpDraft(prev => ({ ...prev, date: e.target.value }))} className="w-full h-11 mt-1 px-3 rounded-xl border border-slate-200 bg-white focus:ring-2 focus:ring-blue-500 outline-none" />
                                </div>
                                <div>
                                    <label className="text-xs font-bold text-slate-600">Uhrzeit *</label>
                                    <input type="time" value={followUpDraft.time} onChange={(e) => setFollowUpDraft(prev => ({ ...prev, time: e.target.value }))} className="w-full h-11 mt-1 px-3 rounded-xl border border-slate-200 bg-white focus:ring-2 focus:ring-blue-500 outline-none" />
                                </div>
                            </div>

                            <div>
                                <label className="text-xs font-bold text-slate-600">Grund *</label>
                                <textarea value={followUpDraft.reason} onChange={(e) => setFollowUpDraft(prev => ({ ...prev, reason: e.target.value }))} rows="3" placeholder="z.B. Tarifvergleich, Rückruf, Unterlagen fehlen..." className="w-full mt-1 p-3 rounded-xl border border-slate-200 bg-white focus:ring-2 focus:ring-blue-500 outline-none" />
                                {!reasonOk && followUpDraft.reason.length > 0 ? <div className="text-xs text-red-600 mt-1 font-bold">Bitte einen kurzen Grund angeben.</div> : null}
                            </div>
                        </div>

                        <div className="p-6 border-t flex items-center justify-end gap-3">
                            <button onClick={onCancel} className="px-5 py-2.5 rounded-xl bg-slate-100 hover:bg-slate-200 text-slate-700 font-bold">Abbrechen</button>
                            <button onClick={onSave} disabled={!canSave} className={`px-5 py-2.5 rounded-xl font-bold text-white ${canSave ? "bg-blue-600 hover:bg-blue-700" : "bg-slate-300 cursor-not-allowed"}`}>Speichern</button>
                        </div>
                    </div>
                </div>
            );
        };

        
        const ReferralModal = ({ isOpen, onClose, onPrint }) => {
            if (!isOpen) return null;
            const handlePrintAction = () => {
                // Wichtig: ohne Timeout, damit Drucken auf Mobile nicht durch fehlende User-Activation blockiert wird
                onClose('print');
                onPrint();
            };

            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/60 backdrop-blur-sm p-4 animate-in fade-in">
                    <div className="bg-white w-full max-w-md rounded-2xl shadow-2xl p-6 relative border border-slate-200 flex flex-col items-center text-center">
                        <div className="w-16 h-16 bg-purple-100 rounded-full flex items-center justify-center mb-4 text-purple-600">
                            <Icon d={ICONS.Gift} size={32}/>
                        </div>
                        <h3 className="text-2xl font-black text-slate-800 mb-2">Freunde werben & Prämie sichern</h3>
                        <p className="text-sm text-slate-600 mb-6 leading-relaxed">
                            Empfehlen Sie uns weiter! Für jeden geworbenen Neukunden erhalten Sie eine <strong>50€ Prämie</strong> gutgeschrieben.
                        </p>
                        
                        <div className="w-full bg-slate-50 border border-slate-200 rounded-xl p-4 mb-6">
                             <div className="flex flex-col gap-3">
                                <div className="flex items-center justify-between gap-2">
                                    <a href="https://jefferson990.github.io/Freunde-Werben-Freunde/" target="_blank"
                                       className="text-xs font-mono text-slate-500 bg-white px-2 py-1 rounded border border-slate-200 truncate flex-1 hover:bg-slate-50 transition">
                                        https://jefferson990.github.io/Freunde-Werben-Freunde/
                                    </a>
                                    <button className="p-2 hover:bg-slate-200 rounded text-slate-500" title="Link kopieren"
                                            onClick={() => { copyToClipboard('https://jefferson990.github.io/Freunde-Werben-Freunde/'); alert('Link kopiert!'); }}>
                                        <Icon d={ICONS.Clipboard} size={16}/>
                                    </button>
                                </div>
</div>
                        </div>

                        <div className="flex flex-col w-full gap-3">
                            <button onClick={handlePrintAction} className="w-full py-3 bg-blue-600 text-white font-bold rounded-xl hover:bg-blue-700 transition-colors shadow-lg flex items-center justify-center gap-2">
                                Weiter zum Druck <Icon d={ICONS.ArrowRight} size={18}/>
                            </button>
                            <button onClick={() => onClose('cancel')} className="w-full py-3 text-slate-500 font-bold hover:bg-slate-50 rounded-xl transition-colors">
                                Abbrechen
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const WlanModal=({isOpen,onClose,triggerToast,onRecommendation})=>{const[floors,setFloors]=useState(2);const[router,setRouter]=useState('eg');const[needs,setNeeds]=useState(new Set(['eg','og1']));const[thickWalls,setThickWalls]=useState(false);const toggleNeed=(f)=>setNeeds(prev=>prev.has(f)?new Set([...prev].filter(x=>x!==f)):new Set([...prev,f]));const{sugg,reason,badgeId}=useMemo(()=>{let s='Repeater';let r='Standard zur Flächenabdeckung';let b='bRep';if(floors>2){s='Mesh / Powerline';r='Größere Fläche';b='bMesh';}if(thickWalls){s='Repeater';r='Dicke Wände (Verstärkung notwendig)';b='bRep';}return{sugg:s,reason:r,badgeId:b};},[floors,router,needs,thickWalls]);const yForFloor=(f)=>{if(f==='keller')return 495;const houseBottom=460;const houseHeight=300;const floorHeight=houseHeight/floors;let index=0;if(f==='eg')index=0;else if(f==='og1')index=1;else if(f==='og2')index=2;else if(f==='dg')index=floors-1;return houseBottom-(index*floorHeight)-(floorHeight/2);};const handleCopy=()=>{const recText=`${sugg} (${reason})`;copyToClipboard(`Empfehlung: ${recText}`);if(typeof onRecommendation==='function'){onRecommendation(recText);}triggerToast('WLAN-Empfehlung kopiert!');};if(!isOpen)return null;const availableFloors=['KELLER','EG'];if(floors>=2)availableFloors.push('OG1');if(floors>=3)availableFloors.push('DG');if(floors>=4){availableFloors[3]='OG2';availableFloors.push('DG');}return(<div className="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/60 backdrop-blur-sm p-4 animate-in fade-in"><div className="bg-white w-full max-w-[1000px] max-h-[90vh] overflow-y-auto relative rounded-2xl border border-[#cbd5e1] shadow-2xl flex flex-col md:flex-row"><button onClick={onClose} className="absolute top-4 right-4 z-50 p-2 hover:bg-slate-100 rounded-full text-slate-500"><Icon d={ICONS.X} size={20}/></button><div className="w-full md:w-1/2 bg-blue-50/50 p-8 flex flex-col justify-center border-b md:border-b-0 md:border-r border-slate-100 relative"><div className="absolute top-4 left-4 text-slate-400 font-bold text-xs tracking-widest">VORSCHAU</div><svg viewBox="0 0 560 560" className="w-full h-auto house-svg drop-shadow-xl wlan-svg"><path d="M80 160 L280 70 L480 160" className="roof" strokeWidth="2"/><rect x="80" y="160" width="400" height="300" rx="12" className="house-body" strokeWidth="2"/>{Array.from({length:floors-1}).map((_,i)=><line key={i} x1="90" x2="470" y1={460-(300/floors)*(i+1)} y2={460-(300/floors)*(i+1)} className="floor-line" strokeWidth="2"/>)}<rect x="80" y="470" width="400" height="50" rx="8" className="keller" strokeWidth="2"/><text x="90" y="502" fontSize="12" fontWeight="700" fill="#64748b">Keller</text><defs><clipPath id="aboveClip"><rect x="80" y="160" width="400" height="300"/></clipPath><clipPath id="basementClip"><rect x="80" y="470" width="400" height="50"/></clipPath></defs><g clipPath="url(#aboveClip)">{router!=='keller'&&<g transform={`translate(140, ${yForFloor(router)-16})`}><rect x="-20" y="-12" width="40" height="24" rx="6" fill="#0f172a"/><circle cx="0" cy="-2" r="2" fill="#22c55e"/></g>}{Array.from(needs).filter(n=>n!=='keller').map(n=>(<g key={n} transform={`translate(390, ${yForFloor(n)-24})`} className="wifi-glow"><path d="M-10 -10 L0 0 L10 -10" stroke="#3b82f6" strokeWidth="3" fill="none"/><circle r="3" fill="#3b82f6"/></g>))}</g><g clipPath="url(#basementClip)">{router==='keller'&&<g transform={`translate(140, ${yForFloor('keller')-16})`}><rect x="-20" y="-12" width="40" height="24" rx="6" fill="#0f172a"/><circle cx="0" cy="-2" r="2" fill="#22c55e"/></g>}{needs.has('keller')&&<g transform={`translate(390, ${yForFloor('keller')-24})`} className="wifi-glow"><path d="M-10 -10 L0 0 L10 -10" stroke="#3b82f6" strokeWidth="3" fill="none"/><circle r="3" fill="#3b82f6"/></g>}</g></svg></div><div className="w-full md:w-1/2 p-8 overflow-y-auto relative"><h2 className="text-2xl font-black text-slate-800 mb-6 flex items-center gap-2"><Icon d={ICONS.Wifi} className="text-blue-600"/> WLAN Haus-Planer</h2><div className="space-y-6"><div><label className="block text-sm font-bold text-slate-700 mb-2">Anzahl Etagen</label><div className="flex gap-2">{[1,2,3,4].map(n=><button key={n} onClick={()=>setFloors(n)} className={`wlan-num wlan-chip ${floors===n?'toggled':''}`}>{n}</button>)}</div><label className="flex gap-2 items-center mt-2 cursor-pointer"><input type="checkbox" checked={thickWalls} onChange={(e)=>setThickWalls(e.target.checked)} className="accent-blue-600"/> <span className="text-xs text-slate-500">Dicke Wände / Stahlbeton</span></label></div><div><h3 className="font-bold text-slate-700 mb-2">Router Standort</h3><div className="flex flex-wrap gap-2">{availableFloors.map(f=><button key={f} onClick={()=>setRouter(f.toLowerCase())} className={`wlan-chip ${router===f.toLowerCase()?'toggled':''}`}>{f.toUpperCase()}</button>)}</div></div><div><h3 className="font-bold text-slate-700 mb-2">WLAN Bedarf</h3><div className="flex flex-wrap gap-2">{availableFloors.map(f=><button key={f} onClick={()=>toggleNeed(f.toLowerCase())} className={`wlan-chip ${needs.has(f.toLowerCase())?'toggled':''}`}>{f.toUpperCase()}</button>)}</div></div><div className="p-4 bg-white border border-blue-100 rounded-xl shadow-sm"><div className="text-xs text-slate-400 uppercase tracking-wider font-bold mb-1">EMPFEHLUNG</div><div className="text-xl font-black text-blue-900 mb-1">{sugg}</div><div className="text-sm text-slate-600">{reason}</div><div className="flex gap-2 mt-3">{['Mesh','Repeater','Powerline'].map(t=><span key={t} className={`wlan-badge ${badgeId===(t==='Mesh'?'bMesh':t==='Repeater'?'bRep':'bPow')?'glow':''}`}>{t}</span>)}</div><button onClick={handleCopy} className="w-full py-3 bg-blue-600 text-white font-bold rounded-xl hover:bg-blue-700 transition-colors shadow-md mt-4">Empfehlung kopieren</button></div></div></div></div></div>);};
        const SpeedModal=({isOpen,onClose,triggerToast,onRecommendation})=>{const[simDl,setSimDl]=useState(100);const[simUl,setSimUl]=useState(40);const[tiers,setTiers]=useState([{dl:16,ul:2.4,on:true},{dl:50,ul:10,on:true},{dl:100,ul:40,on:true},{dl:250,ul:40,on:true},{dl:1000,ul:100,on:true}]);const[customDl,setCustomDl]=useState('');const[activities,setActivities]=useState([{k:'surf',label:'Surfen',dl:1.5,ul:0.2,n:2},{k:'video',label:'Videotelefonie',dl:3,ul:1.5,n:1},{k:'stream',label:'Streaming HD',dl:5,ul:1,n:1},{k:'stream4k',label:'4K‑Streaming',dl:25,ul:2,n:0},{k:'gaming',label:'Online‑Gaming',dl:3,ul:0.5,n:1},{k:'home',label:'Home‑Office',dl:4,ul:2,n:1}]);const[prefs,setPrefs]=useState(new Set());const{rec,needDl,needUl,gaugePct}=useMemo(()=>{let nDl=0,nUl=0;activities.forEach(a=>{nDl+=a.n*a.dl;nUl+=a.n*a.ul;});nDl=Math.ceil(nDl*1.2);nUl=Math.ceil(nUl*1.2);const avail=tiers.filter(t=>t.on).sort((a,b)=>a.dl-b.dl);let r=avail.find(t=>t.dl>=nDl&&t.ul>=Math.max(nUl,2));if(!r&&avail.length>0)r=avail[avail.length-1];const pct=r?Math.min(100,Math.round((nDl/r.dl)*100)):0;return{needDl:nDl,needUl:nUl,rec:r,gaugePct:pct};},[activities,tiers,prefs]);useEffect(()=>{if(rec){setSimDl(rec.dl);setSimUl(Math.max(rec.ul,1));}},[rec]);const toggleTier=(i)=>{const newT=[...tiers];newT[i].on=!newT[i].on;setTiers(newT);};const updateAct=(k,delta)=>{setActivities(prev=>prev.map(a=>a.k===k?{...a,n:Math.max(0,a.n+delta)}:a));};const togglePref=(k)=>{const p=new Set(prefs);if(p.has(k))p.delete(k);else p.add(k);setPrefs(p);};const secsToStr=(s)=>{if(!isFinite(s)||s<0)return'–';const m=Math.floor(s/60),sec=Math.round(s%60);return m>=60?`${Math.floor(m/60)} h ${m%60} min`:m>=1?`${m} min ${sec} s`:`${sec} s`;};const handleCopy=()=>{const recText=`${rec?.dl}/${rec?.ul} MBit/s`;copyToClipboard(`Empfehlung: ${recText}`);if(typeof onRecommendation==='function'){onRecommendation(recText);}triggerToast('Speed-Empfehlung kopiert!');};const addCustomTier=()=>{const val=parseInt(customDl);if(!isNaN(val)&&val>0){const newTier={dl:val,ul:Math.round(val/5),on:true};if(!tiers.find(t=>t.dl===val))setTiers(prev=>[...prev,newTier].sort((a,b)=>a.dl-b.dl));setCustomDl('');}};if(!isOpen)return null;return(<div className="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/60 backdrop-blur-sm p-4 animate-in fade-in duration-200"><style>{` .sp-modal { --primary: #3949AB; --bg: #FFFFFF; --panel: #F5F5F5; --border: #E0E0E0; --text: #424242; --muted: #757575; font-family: system-ui,-apple-system,sans-serif; } .sp-modal .card { background: var(--panel); border: 1px solid var(--border); border-radius: 16px; padding: 14px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); } .sp-modal h3 { margin: 0 0 10px 0; font-size: 14px; font-weight: 800; color: #1A237E; letter-spacing:.2px; } .sp-modal .chip { background: #ffffff; border: 1px solid var(--border); color: #424242; border-radius: 999px; padding: 6px 12px; cursor: pointer; font-size: 13px; transition: all 0.2s; } .sp-modal .chip:hover { background: #e0e0e0; } .sp-modal .chip.toggled { background: #BBDEFB; color: #1A237E; border-color: #3949AB; box-shadow: 0 2px 4px rgba(57, 73, 171, 0.2); font-weight: 600; } .sp-modal .gauge { width: 280px; aspect-ratio: 1/1; margin: 0 auto; position: relative; background: conic-gradient(from -90deg, #3949AB 0 var(--p), #E0E0E0 var(--p) 360deg); border-radius: 999px; border: 12px solid #F5F5F5; box-shadow: 0 4px 12px rgba(0,0,0,0.05); } .sp-modal .gauge .inner { position: absolute; inset: 40px; background: #ffffff; border-radius: 999px; display: grid; place-items: center; border: 6px solid #F5F5F5; } .sp-modal .val { font-size: 36px; font-weight: 900; line-height: 1; color: #3949AB; } .sp-modal .val-ul { font-size: 20px; color: #424242; } .sp-modal .text-label { font-size: 10px; uppercase; tracking-widest; color: #757575; } .sp-modal .btn { padding: 8px 12px; border-radius: 10px; border: 1px solid var(--border); background: #ffffff; color: #424242; cursor: pointer; font-size: 13px; font-weight: 600; } .sp-modal .btn:hover { background: #f0f0f0; } .sp-modal .btn.primary { background: #3949AB; border-color: #3949AB; color: #ffffff; } .sp-modal input[type=range] { width: 100%; accent-color: #3949AB; } .sp-modal table { width: 100%; font-size: 14px; border-collapse: collapse; color: #424242; } .sp-modal td, .sp-modal th { padding: 8px 10px; border-bottom: 1px solid var(--border); text-align: left; } .sp-modal th { color: #757575; } .sp-modal .metric { background: #ffffff; border: 1px solid var(--border); padding: 8px 10px; border-radius: 12px; text-align: center; font-size: 13px; color: var(--muted); } .sp-modal .metric b { color: #424242; display: block; font-size: 14px; margin-top: 2px; } .sp-modal .rowlabel { display: flex; align-items: center; justify-content: space-between; padding: 4px 0; } .sp-modal .act-btn { width: 28px; height: 28px; border-radius: 8px; border: 1px solid var(--border); background: #ffffff; color: #424242; display: grid; place-items: center; cursor: pointer; } .sp-modal .act-val { width: 30px; text-align: center; font-weight: bold; color: #0f172a; } `}</style><div className="sp-modal bg-white w-full max-w-[1100px] max-h-[95vh] overflow-y-auto rounded-2xl relative border border-[#E0E0E0] shadow-2xl flex flex-col text-[#424242]"><button onClick={onClose} className="absolute top-4 right-4 p-2 rounded-full bg-[#F5F5F5] hover:bg-[#E0E0E0] text-[#424242] border border-[#E0E0E0]"><Icon d={ICONS.X} size={20}/></button><div className="p-6 pb-2 text-center"><div className="inline-flex items-center gap-2 bg-[#F5F5F5] px-4 py-2 rounded-full border border-[#E0E0E0] shadow-sm mb-2"><span className="w-2.5 h-2.5 rounded-full bg-[#3949AB] shadow-[0_0_0_3px_rgba(57,73,171,0.2)]"></span><span className="font-bold text-sm text-[#1A237E] tracking-wide">Speed-Rechner</span></div><h1 className="text-2xl font-black mt-2 text-[#1A237E]">Tarifempfehlung</h1><p className="text-sm text-[#757575] mt-1">{rec?`${rec.dl} MBit/s Download`:'Bitte wählen'}</p></div><div className="grid grid-cols-1 lg:grid-cols-[1fr_340px_1fr] gap-4 p-6 pt-2"><div className="flex flex-col gap-4"><div className="card"><h3>Verfügbares Breitband</h3><div className="flex flex-wrap gap-2">{tiers.map((t,i)=><button key={i} onClick={()=>toggleTier(i)} className={`chip ${t.on?'toggled':''}`}>{t.dl}</button>)}<div className="flex items-center gap-1 bg-white rounded-full px-2 border border-[#E0E0E0] h-[33px]"><input type="number" placeholder="+" className="w-10 h-6 text-xs bg-transparent text-center outline-none text-slate-600" value={customDl} onChange={(e)=>setCustomDl(e.target.value)} onKeyDown={(e)=>{if(e.key==='Enter')addCustomTier()}} /><button onClick={addCustomTier} className="w-6 h-6 rounded-full bg-[#3949AB] text-white font-bold flex items-center justify-center text-xs hover:bg-[#303F9F] shadow-sm" title="Hinzufügen">+</button></div></div></div><div className="card"><h3>Wichtige Themen?</h3><div className="flex flex-wrap gap-2">{['download','upload','stability','latency'].map(k=>(<button key={k} onClick={()=>togglePref(k)} className={`chip ${prefs.has(k)?'toggled':''}`}>{k==='download'?'Download':k==='upload'?'Upload':k==='stability'?'Stabilität':'Ping'}</button>))}</div></div></div><div className="flex flex-col items-center gap-4"><div className="gauge" style={{'--p':`${Math.max(0,Math.min(100,gaugePct))*3.6}deg`}}><div className="inner"><div className="text-center"><div className="val" style={{color:'#3949AB'}}>{rec?rec.dl:0}</div><div className="text-label mb-2">MBit/s Down</div><div className="val-ul" style={{fontSize:'20px',color:'#424242'}}>{rec?rec.ul:0}</div><div className="text-label">MBit/s Up</div></div></div></div><div className="w-full bg-[#F5F5F5] border border-[#E0E0E0] rounded-xl p-4 text-center shadow-sm"><div className="text-lg font-bold text-[#3949AB] mb-3">{rec?`Empfehlung: ${rec.dl} / ${rec.ul}`:'Keine Empfehlung'}</div><div className="grid grid-cols-2 gap-2 text-xs"><div className="metric">Bedarf Down <b>{needDl}</b></div><div className="metric">Bedarf Up <b>{needUl}</b></div></div></div><button onClick={handleCopy} className="btn primary w-full py-3 shadow-md">Empfehlung kopieren</button></div><div className="flex flex-col gap-4"><div className="card"><h3>Aktivitäten (gleichzeitig)</h3><div className="flex flex-col gap-2">{activities.map(a=>(<div key={a.k} className="rowlabel"><span className="text-sm text-[#424242]">{a.label}</span><div className="flex items-center gap-2"><button className="act-btn" onClick={()=>updateAct(a.k,-1)}>-</button><span className="act-val">{a.n}</span><button className="act-btn" onClick={()=>updateAct(a.k,1)}>+</button></div></div>))}</div></div><div className="card"><h3>Simulation</h3><div className="mb-3 space-y-2 text-xs"><div className="flex justify-between"><span className="text-[#757575]">Download</span> <b className="text-[#3949AB]">{simDl} MBit</b></div><input type="range" min="10" max="1000" value={simDl} onChange={(e)=>setSimDl(parseInt(e.target.value))}/></div><table><thead><tr><th>Datei</th><th>Größe</th><th>Zeit</th></tr></thead><tbody>{[{l:'Film HD',gb:4},{l:'Game',gb:50},{l:'Cloud',gb:2,up:true}].map((row,i)=>{const rate=row.up?simUl*125000:simDl*125000;const time=(row.gb*1024*1024*1024)/rate;const hours = Math.floor(time / 3600); const minutes = Math.floor((time % 3600) / 60); const seconds = Math.round(time % 60); const timeStr = hours > 0 ? `${hours} h ${minutes} min` : minutes > 0 ? `${minutes} min ${seconds} s` : `${seconds} s`; return<tr key={i}><td>{row.l}</td><td>{row.gb} GB</td><td className="font-mono text-[#3949AB]">{timeStr}</td></tr>;})}</tbody></table></div></div></div></div></div>);};
        const TechVisualizer = ({ type }) => { function CableOutlet() { return (<g transform="translate(0, 0)"><rect x="0" y="20" width="60" height="80" rx="4" fill="#f1f5f9" stroke="#94a3b8" strokeWidth="2"/><rect x="5" y="30" width="50" height="60" rx="8" fill="#ffffff" stroke="#cbd5e1" strokeWidth="2"/><circle cx="30" cy="45" r="6" fill="#f1f5f9" stroke="#94a3b8" strokeWidth="2"/><circle cx="20" cy="75" r="6" fill="#f1f5f9" stroke="#94a3b8" strokeWidth="2"/><circle cx="40" cy="75" r="6" fill="#f1f5f9" stroke="#94a3b8" strokeWidth="2"/><text x="30" y="115" textAnchor="middle" fontSize="10" fill="#64748b" fontWeight="bold">DATA - TV - RADIO</text></g>); } function TaeOutlet() { return (<g transform="translate(0, 0)"><rect x="0" y="20" width="60" height="80" rx="4" fill="#f1f5f9" stroke="#94a3b8" strokeWidth="2"/><rect x="10" y="30" width="40" height="60" rx="8" fill="#ffffff" stroke="#cbd5e1" strokeWidth="2"/><rect x="15" y="40" width="8" height="40" rx="2" fill="#d1d5db" stroke="#9ca3af" strokeWidth="0.5"/><rect x="26" y="40" width="8" height="40" rx="2" fill="#d1d5db" stroke="#9ca3af" strokeWidth="0.5"/><rect x="37" y="40" width="8" height="40" rx="2" fill="#d1d5db" stroke="#9ca3af" strokeWidth="0.5"/><text x="30" y="115" textAnchor="middle" fontSize="10" fill="#64748b" fontWeight="bold">TAE-Dose</text></g>); } const [fiberVariant, setFiberVariant] = useState('ont'); const FiberVisualization = ({ variant }) => { if (variant === 'sfp') { return (<g transform="translate(30,40)"><g transform="translate(20, 0)"><rect x="0" y="20" width="60" height="60" rx="4" fill="#f8fafc" stroke="#cbd5e1" strokeWidth="2"/><rect x="15" y="45" width="10" height="10" fill="#94a3b8"/><rect x="35" y="45" width="10" height="10" fill="#94a3b8"/><text x="30" y="95" textAnchor="middle" fontSize="10" fill="#64748b" fontWeight="bold">GF-Dose</text></g><path d="M80 50 L380 50" stroke="#22c55e" strokeWidth="3" strokeDasharray="4,4" fill="none" className="flow-anim"/><g transform="translate(380, 20)"><rect x="0" y="0" width="100" height="60" rx="8" fill="#ffffff" stroke="#94a3b8" strokeWidth="2"/><rect x="10" y="0" width="80" height="5" rx="2" fill="#22c55e" opacity="0.8"/><circle cx="30" cy="40" r="3" fill="#22c55e"/><circle cx="50" cy="40" r="3" fill="#22c55e"/><circle cx="70" cy="40" r="3" fill="#cbd5e1"/><text x="50" y="80" textAnchor="middle" fontSize="10" fill="#64748b" fontWeight="bold">Router (SFP)</text></g><text x="250" y="15" textAnchor="middle" fontSize="10" fill="#15803d" fontWeight="bold">Variante A: Direkt</text></g>); } else { return (<g transform="translate(30,40)"><g transform="translate(20, 0)"><rect x="0" y="20" width="60" height="60" rx="4" fill="#f8fafc" stroke="#cbd5e1" strokeWidth="2"/><rect x="15" y="45" width="10" height="10" fill="#94a3b8"/><rect x="35" y="45" width="10" height="10" fill="#94a3b8"/><text x="30" y="95" textAnchor="middle" fontSize="10" fill="#64748b" fontWeight="bold">GF-Dose</text></g><path d="M80 50 Q 150 30, 220 50" stroke="#22c55e" strokeWidth="3" strokeDasharray="4,4" fill="none" className="flow-anim"/><g transform="translate(220, 20)"><rect x="0" y="0" width="70" height="60" rx="4" fill="#f1f5f9" stroke="#94a3b8" strokeWidth="2"/><text x="35" y="35" textAnchor="middle" fontSize="12" fontWeight="bold">ONT</text><rect x="10" y="60" width="50" height="10" rx="2" fill="#cbd5e1"/><text x="35" y="80" textAnchor="middle" fontSize="8" fill="#64748b">230V</text></g><path d="M290 50 L380 50" stroke="#3b82f6" strokeWidth="3" fill="none" strokeDasharray="6,6"/><g transform="translate(380, 20)"><rect x="0" y="0" width="100" height="60" rx="8" fill="#ffffff" stroke="#94a3b8" strokeWidth="2"/><rect x="10" y="0" width="80" height="5" rx="2" fill="#fca5a5" opacity="0.8"/><circle cx="30" cy="40" r="3" fill="#22c55e"/><circle cx="50" cy="40" r="3" fill="#22c55e"/><circle cx="70" cy="40" r="3" fill="#cbd5e1"/><text x="50" y="80" textAnchor="middle" fontSize="10" fill="#64748b" fontWeight="bold">Router</text></g><text x="250" y="15" textAnchor="middle" fontSize="10" fill="#2563eb" fontWeight="bold">Variante B: Über ONT</text></g>); } }; const renderContent = () => { switch(type) { case 'dsl': return (<g transform="translate(50,40)"><TaeOutlet /><path d="M60 60 L180 60" stroke="#3b82f6" strokeWidth="4" fill="none"/><rect x="180" y="52" width="40" height="16" rx="4" fill="#ffffff" stroke="#94a3b8" strokeWidth="2"/><text x="200" y="62" textAnchor="middle" fontSize="8" fill="#64748b" fontWeight="bold">RJ11</text><path d="M220 60 L340 60" stroke="#3b82f6" strokeWidth="4" fill="none"/><path d="M60 60 L340 60" stroke="#bfdbfe" strokeWidth="2" fill="none" className="flow-anim"/><g transform="translate(340, 30)"><rect x="0" y="0" width="100" height="60" rx="8" fill="#ffffff" stroke="#94a3b8" strokeWidth="2"/><rect x="10" y="0" width="80" height="5" rx="2" fill="#fca5a5" opacity="0.8"/><circle cx="30" cy="40" r="3" fill="#22c55e"/><circle cx="50" cy="40" r="3" fill="#22c55e"/><circle cx="70" cy="40" r="3" fill="#cbd5e1"/><text x="50" y="80" textAnchor="middle" fontSize="10" fill="#64748b" fontWeight="bold">DSL Router</text></g></g>); case 'cable': return (<g transform="translate(50,40)"><CableOutlet /><path d="M60 45 L340 60" stroke="#3b82f6" strokeWidth="4" fill="none"/><rect x="180" y="42" width="40" height="16" rx="4" fill="#ffffff" stroke="#94a3b8" strokeWidth="2"/><text x="200" y="52" textAnchor="middle" fontSize="8" fill="#64748b" fontWeight="bold">F-Stecker</text><path d="M60 45 L340 60" fill="none" stroke="#bfdbfe" strokeWidth="2" className="flow-anim"/><g transform="translate(340, 30)"><rect x="0" y="0" width="100" height="60" rx="8" fill="#ffffff" stroke="#94a3b8" strokeWidth="2"/><rect x="10" y="0" width="80" height="5" rx="2" fill="#fca5a5" opacity="0.8"/><circle cx="30" cy="40" r="3" fill="#22c55e"/><circle cx="50" cy="40" r="3" fill="#22c55e"/><circle cx="70" cy="40" r="3" fill="#cbd5e1"/><text x="50" y="80" textAnchor="middle" fontSize="10" fill="#64748b" fontWeight="bold">Kabel Router</text></g></g>); case 'fiber': return (<g transform="translate(0, 0)"><FiberVisualization variant={fiberVariant} /></g>); case 'mobile': return (<g transform="translate(60,40)"><g transform="translate(50, 20)"><path d="M20 80 L50 0 L80 80" stroke="#475569" strokeWidth="4" fill="none"/><line x1="35" y1="40" x2="65" y2="40" stroke="#475569" strokeWidth="3"/><circle cx="50" cy="0" r="5" fill="#ef4444"/><text x="50" y="100" textAnchor="middle" fontSize="10" fill="#64748b">5G Mast</text><path d="M20 -10 A 40 40 0 0 1 20 50" stroke="#3b82f6" strokeWidth="3" fill="none" className="signal-wave"/><path d="M40 -20 A 60 60 0 0 1 40 70" stroke="#3b82f6" strokeWidth="3" fill="none" className="signal-wave delay-1"/></g><g transform="translate(200, 40)"><rect x="0" y="0" width="60" height="60" rx="4" fill="#f1f5f9" stroke="#94a3b8" strokeWidth="2"/><circle cx="20" cy="30" r="5" fill="#ffffff" stroke="#94a3b8" strokeWidth="2"/><circle cx="40" cy="30" r="5" fill="#ffffff" stroke="#94a3b8" strokeWidth="2"/><text x="30" y="80" textAnchor="middle" fontSize="10" fill="#64748b" fontWeight="bold">Schuko</text></g><path d="M260 55 L350 55" stroke="#3b82f6" strokeWidth="3" fill="none" strokeDasharray="6,6"/><g transform="translate(350, 30)"><rect x="0" y="0" width="80" height="60" rx="6" fill="#ffffff" stroke="#cbd5e1" strokeWidth="2"/><rect x="45" y="65" width="40" height="10" rx="2" fill="#ffbf00"/><text x="65" y="72" textAnchor="middle" fontSize="8" fill="#ffffff" fontWeight="bold">SIM</text><circle cx="40" cy="30" r="4" fill="#22c55e" className="animate-pulse"/><text x="40" y="80" textAnchor="middle" fontSize="10" fill="#64748b" fontWeight="bold">5G Router</text></g></g>); case 'hybrid': return (<g transform="translate(40,40)"><TaeOutlet /><g transform="translate(200, -20)"><path d="M-10 80 L10 20 L30 80" stroke="#ef4444" strokeWidth="3" fill="none"/><circle cx="10" cy="20" r="3" fill="#ef4444"/></g><path d="M60 60 L340 60" stroke="#3b82f6" strokeWidth="3" fill="none" strokeDasharray="8,4" className="flow-anim"/><path d="M200 40 Q 300 20, 340 40" stroke="#ef4444" strokeWidth="2" fill="none" strokeDasharray="4,4" className="beam-anim"/><g transform="translate(340, 30)"><rect x="0" y="0" width="100" height="60" rx="8" fill="#ffffff" stroke="#94a3b8" strokeWidth="2"/><rect x="10" y="65" width="40" height="10" rx="2" fill="#ffbf00"/><text x="30" y="72" textAnchor="middle" fontSize="8" fill="#ffffff" fontWeight="bold">SIM</text><rect x="10" y="0" width="80" height="5" rx="2" fill="#fca5a5" opacity="0.8"/><circle cx="30" cy="40" r="3" fill="#22c55e"/><circle cx="50" cy="40" r="3" fill="#22c55e"/><circle cx="70" cy="40" r="3" fill="#cbd5e1"/><text x="50" y="80" textAnchor="middle" fontSize="10" fill="#64748b" fontWeight="bold">Hybrid Router</text></g></g>); case 'sat': return (<g transform="translate(60,20)"><g transform="translate(100, 20)"><rect x="-30" y="-5" width="60" height="10" fill="#3b82f6"/><circle cx="0" cy="0" r="8" fill="#1e40af"/><text x="0" y="-15" textAnchor="middle" fontSize="10" fill="#64748b">Satellit</text></g><g transform="translate(100, 150)"><path d="M-40 0 C -20 -30, 20 -30, 40 0" fill="none" stroke="#475569" strokeWidth="3"/><line x1="0" y1="0" x2="0" y2="-50" stroke="#475569" strokeWidth="2"/><line x="0" y="0" x="0" y="40" stroke="#475569" strokeWidth="4"/><text x="0" y="55" textAnchor="middle" fontSize="10" fill="#64748b" fontWeight="bold">Sat-Schüssel</text></g><path d="M100 20 L100 120" stroke="#bfdbfe" strokeWidth="2" strokeDasharray="4,4" className="beam-anim"/><path d="M100 150 L250 150" stroke="#3b82f6" strokeWidth="2" fill="none" strokeDasharray="6,6"/><g transform="translate(250, 120)"><rect x="0" y="0" width="80" height="60" rx="6" fill="#f1f5f9" stroke="#94a3b8" strokeWidth="2"/><text x="40" y="35" textAnchor="middle" fontSize="10" fill="#64748b" fontWeight="bold">PoE-Injektor</text><rect x="15" y="60" width="50" height="10" rx="2" fill="#cbd5e1"/><text x="40" y="80" textAnchor="middle" fontSize="8" fill="#64748b">230V</text></g><path d="M330 150 L420 150" stroke="#3b82f6" strokeWidth="2" fill="none" strokeDasharray="6,6"/><g transform="translate(420, 120)"><rect x="0" y="0" width="100" height="60" rx="8" fill="#ffffff" stroke="#94a3b8" strokeWidth="2"/><text x="50" y="80" textAnchor="middle" fontSize="10" fill="#64748b" fontWeight="bold">Router</text></g></g>); default: return null; } }; return (<div className="w-full h-[200px] bg-blue-50/30 rounded-2xl border border-blue-100 flex items-center justify-center overflow-hidden relative mb-6"><svg viewBox="0 0 500 180" width="100%" height="100%" preserveAspectRatio="xMidYMid meet">{renderContent()}</svg>{type === 'fiber' && (<div className="absolute top-2 right-2 flex gap-2 bg-white p-1 rounded-lg border border-slate-200 shadow-md"><button onClick={() => setFiberVariant('ont')} className={`px-3 py-1 text-xs font-bold rounded-md transition-colors ${fiberVariant === 'ont' ? 'bg-blue-600 text-white' : 'bg-slate-100 text-slate-600 hover:bg-slate-200'}`}>ONT</button><button onClick={() => setFiberVariant('sfp')} className={`px-3 py-1 text-xs font-bold rounded-md transition-colors ${fiberVariant === 'sfp' ? 'bg-blue-600 text-white' : 'bg-slate-100 text-slate-600 hover:bg-slate-200'}`}>Direkt (SFP)</button></div>)}</div>); }
        const TechModal = ({ isOpen, onClose }) => { const [selected, setSelected] = useState('dsl'); if (!isOpen) return null; const TECHS = { dsl: { id: 'dsl', label: 'DSL / VDSL (Kupfer)', Icon: ICONS.Phone, desc: 'Datenübertragung über die klassische Kupfer-Telefonleitung (TAE-Dose). Nutzt VDSL- und Supervectoring-Technologien.', speed: 'bis 250 MBit/s', ping: 'Gut (10-20ms)', pros: ['Hohe Verfügbarkeit (fast überall in Deutschland)', 'Geringe Anschlusskosten','Konstante Leistung bei kurzer Leitungslänge'], cons: ['Geschwindigkeit stark leitungsabhängig','Maximaler Upload oft begrenzt','Frequenzstörungen möglich'] }, cable: { id: 'cable', label: 'Kabel (Koax-Netz)', Icon: ICONS.Tv, desc: 'Internet über das TV-Kabelnetz (Koax-3-Loch-Dose). Nutzt DOCSIS 3.1 / 4.0 Standard.', speed: 'bis 1000 MBit/s', ping: 'Mittel (15-30ms)', pros: ['Sehr hohe Downloads möglich','Geringere Auslastung im ländlichen Raum','Keine neue Verkabelung in der Wohnung nötig'], cons: ['Shared Medium (geteilte Bandbreite im Segment)','Geringere Stabilität als Glasfaser','Upload oft asynchron (deutlich langsamer)'] }, fiber: { id: 'fiber', label: 'Glasfaser (FTTH)', Icon: ICONS.Zap, desc: 'Datenübertragung per Lichtsignal über Glasfaser bis in die Wohnung (FTTH). Zukunftssicher und nahezu störungsfrei.', speed: 'bis 1000+ MBit/s', ping: 'Exzellent (<5ms)', pros: ['Höchste Geschwindigkeiten und Stabilität', 'Symmetrische Uploads möglich', 'Zukunftssicher und störungsarm'], cons: ['Geringere Verfügbarkeit (Netzausbau nötig)','Installationsaufwand in der Wohnung'] }, mobile: { id: 'mobile', label: '5G / LTE (Mobilfunk)', Icon: ICONS.Smartphone, desc: 'Internet über das Mobilfunknetz per SIM-Karte im Router (CPE). Ideal für Standorte ohne Festnetz-Alternative.', speed: 'bis 500 MBit/s', ping: 'Variabel', pros: ['Sofort startklar (Plug & Play)', 'Flexible Standortwahl (ohne Kabelbindung)','Gute Geschwindigkeiten in 5G-Gebieten'], cons: ['Empfangs- und wetterabhängig','Datenvolumenbegrenzung möglich (je nach Tarif)'] }, hybrid: { id: 'hybrid', label: 'Hybrid (DSL + LTE/5G)', Icon: ICONS.Layers, desc: 'Kombiniert die DSL-Leitung mit dem Mobilfunksignal (LTE/5G), um Geschwindigkeit und Ausfallsicherheit zu erhöhen (Bonding).', speed: 'DSL + Mobilfunk-Boost', ping: 'Wie DSL', pros: ['Höhere Geschwindigkeit als reines DSL möglich','Verbesserte Ausfallsicherheit (Bleibt online bei DSL-Störung)','Nutzt bestehende TAE-Verkabelung'], cons: ['Spezial-Hardware (Hybrid-Router) nötig','Geschwindigkeit des Mobilfunk-Anteils variabel'] }, sat: { id: 'sat', label: 'Satellit (Starlink/etc.)', Icon: ICONS.Disc, desc: 'Breitband-Internet über LEO-Satelliten. Geeignet für sehr ländliche oder schwer zugängliche Gebiete.', speed: '50-200 MBit/s', ping: 'Mittel (ca. 40-70ms)', pros: ['Überall verfügbar (unabhängig vom Leitungsnetz)','Hohe Downloadraten im Vergleich zu altem DSL'], cons: ['Sichtverbindung zum Himmel erforderlich','Wetterabhängige Schwankungen','Höhere Latenz als Festnetz'] } }; const active = TECHS[selected]; return (<div className="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/60 backdrop-blur-md p-4 animate-in fade-in"><div className="bg-white w-full max-w-5xl h-[650px] rounded-2xl shadow-2xl overflow-hidden flex flex-col md:flex-row border border-slate-200"><div className="w-full md:w-64 bg-slate-50 border-r border-slate-200 p-4 flex flex-col gap-2 shrink-0 overflow-y-auto custom-scrollbar"><h3 className="font-black text-slate-800 text-lg mb-4 px-2">Technologie</h3>{Object.values(TECHS).map(t => (<button key={t.id} onClick={() => setSelected(t.id)} className={`w-full text-left px-4 py-3 rounded-xl transition-all flex items-center gap-3 border ${selected === t.id ? 'bg-white border-blue-500 shadow-sm ring-1 ring-blue-100' : 'border-transparent hover:bg-slate-100'}`}><div className={`p-1.5 rounded-lg ${selected===t.id ? 'bg-blue-50 text-blue-600' : 'bg-slate-200 text-slate-500'}`}><Icon d={t.Icon} size={16}/></div><span className={`text-sm ${selected===t.id ? 'font-bold text-blue-700' : 'font-medium text-slate-600'}`}>{t.label.split('(')[0].trim()}</span></button>))}<div className="mt-auto pt-4 border-t border-slate-200"><button onClick={onClose} className="w-full py-3 text-slate-400 font-bold text-xs uppercase tracking-wider hover:text-slate-600 hover:bg-slate-100 rounded-lg transition-colors">SCHLIESSEN</button></div></div><div className="flex-1 p-8 bg-white relative overflow-y-auto custom-scrollbar"><button onClick={onClose} className="absolute top-4 right-4 p-2 hover:bg-slate-50 rounded-full text-slate-400"><Icon d={ICONS.X} size={24}/></button><div className="flex items-start gap-4 mb-6"><div className="p-3 bg-blue-600 rounded-2xl text-white shadow-lg shadow-blue-200"><Icon d={active.Icon} size={32}/></div><div><h2 className="text-3xl font-black text-slate-900 mb-1">{active.label}</h2><p className="text-slate-500 leading-relaxed max-w-lg">{active.desc}</p></div></div><TechVisualizer type={selected} /><div className="grid grid-cols-2 gap-4 mb-8"><div className="p-4 bg-slate-50 rounded-2xl border border-slate-100"><div className="text-xs font-bold text-slate-400 uppercase tracking-wider mb-1">MAX. GESCHWINDIGKEIT</div><div className="text-xl font-black text-blue-600">{active.speed}</div></div><div className="p-4 bg-slate-50 rounded-2xl border border-slate-100"><div className="text-xs font-bold text-slate-400 uppercase tracking-wider mb-1">LATENZ / PING (REAKTIONSZEIT)</div><div className="text-xl font-black text-slate-700">{active.ping}</div></div></div><div className="grid grid-cols-2 gap-8"><div><h4 className="font-bold text-emerald-600 flex items-center gap-2 mb-3"><Icon d={ICONS.CheckCircle} size={18}/> Vorteile</h4><ul className="space-y-2">{active.pros.map((p,i) => <li key={i} className="text-sm text-slate-600 flex gap-2"><span className="text-emerald-400">•</span> {p}</li>)}</ul></div><div><h4 className="font-bold text-amber-600 flex items-center gap-2 mb-3"><Icon d={ICONS.AlertCircle} size={18}/> Nachteile</h4><ul className="space-y-2">{active.cons.map((c,i) => <li key={i} className="text-sm text-slate-600 flex gap-2"><span className="text-amber-400">•</span> {c}</li>)}</ul></div></div></div></div></div>); };
        const RoamingModal = ({ isOpen, onClose }) => { const [zone, setZone] = useState('de_eu'); if (!isOpen) return null; const Node = ({ x, y, label, icon, active }) => (<g transform={`translate(${x},${y})`} className={active ? "opacity-100" : "opacity-40"}><circle r="30" fill={active ? "#eff6ff" : "#f1f5f9"} stroke={active ? "#3b82f6" : "#cbd5e1"} strokeWidth="2" /><text x="0" y="6" textAnchor="middle" fontSize="20">{icon}</text><text x="0" y="45" textAnchor="middle" fontSize="12" fontWeight="bold" fill="#64748b">{label}</text></g>); return (<div className="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/60 backdrop-blur-sm p-4 animate-in fade-in duration-200">
        <div className="bg-white w-full max-w-4xl rounded-2xl shadow-2xl overflow-hidden flex flex-col md:flex-row h-[600px] border border-slate-200 relative">
            <button onClick={onClose} className="absolute top-4 right-4 z-50 p-2 hover:bg-slate-100 rounded-full text-slate-500"><Icon d={ICONS.X} size={20}/></button>
            <div className="w-full md:w-72 bg-slate-50 border-r border-slate-200 flex flex-col">
                <div className="p-6 border-b border-slate-200">
                    <h2 className="text-lg font-black text-slate-800 flex items-center gap-2"><Icon d={ICONS.Globe} size={20} className="text-blue-600"/> Roaming Check</h2>
                    <p className="text-xs text-slate-500 mt-1">Wählen Sie ein Szenario zur Analyse.</p>
                </div>
                <div className="p-4 flex flex-col gap-2 overflow-y-auto">
                    <button onClick={()=>setZone('de_eu')} className={`p-4 rounded-lg text-left border transition-all group ${zone==='de_eu' ? 'bg-white border-blue-500 shadow-md' : 'border-transparent hover:bg-slate-100'}`}><div className="flex items-center justify-between mb-1"><span className="font-bold text-slate-700 text-sm">Telefonie ins Ausland</span><span className="text-xs bg-slate-100 px-2 py-0.5 rounded text-slate-500">DE ➔ EU</span></div><div className="text-[11px] text-slate-500 leading-tight">Kostenanalyse für Anrufe von Deutschland in das EU-Ausland.</div></button><button onClick={()=>setZone('eu_roam')} className={`p-4 rounded-lg text-left border transition-all group ${zone==='eu_roam' ? 'bg-white border-blue-500 shadow-md' : 'border-transparent hover:bg-slate-100'}`}><div className="flex items-center justify-between mb-1"><span className="font-bold text-slate-700 text-sm">EU Roaming</span><span className="text-xs bg-slate-100 px-2 py-0.5 rounded text-slate-500">EU ➔ DE</span></div><div className="text-[11px] text-slate-500 leading-tight">Nutzung des Tarifs im EU-Ausland (Reise).</div></button><button onClick={()=>setZone('world')} className={`p-4 rounded-lg text-left border transition-all group ${zone==='world' ? 'bg-white border-blue-500 shadow-md' : 'border-transparent hover:bg-slate-100'}`}><div className="flex items-center justify-between mb-1"><span className="font-bold text-slate-700 text-sm">Weltreise (Zone 3)</span><span className="text-xs bg-slate-100 px-2 py-0.5 rounded text-slate-500">World</span></div><div className="text-[11px] text-slate-500 leading-tight">Nutzung außerhalb der EU.</div></button></div>
            </div><div className="flex-1 bg-slate-50 relative flex flex-col"><div className="flex-1 bg-slate-50 relative"><svg viewBox="0 0 600 300" className="w-full h-full"><pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse"><path d="M 40 0 L 0 0 0 40" fill="none" stroke="#f1f5f9" strokeWidth="1"/></pattern><rect width="600" height="300" fill="url(#grid)" /><Node x="150" y="150" label="Deutschland" icon="🇩🇪" active={true} /><Node x="450" y="100" label="EU Ausland" icon="🇪🇺" active={zone !== 'world'} /><Node x="450" y="220" label="Weltweit (Zone 3)" icon="🌏" active={zone === 'world'} />{zone === 'de_eu' && (<g><path d="M 180 150 L 420 100" fill="none" stroke="#cbd5e1" strokeWidth="2" /><path d="M 180 150 L 420 100" fill="none" stroke="#3b82f6" strokeWidth="2" strokeDasharray="10,10" className="flow-anim" /><rect x="275" y="110" width="50" height="24" rx="12" fill="#ef4444" /><text x="300" y="126" textAnchor="middle" fill="white" fontSize="12" fontWeight="bold">0,29 €</text></g>)}{zone === 'eu_roam' && (<g><path d="M 420 100 L 180 150" fill="none" stroke="#cbd5e1" strokeWidth="2" /><path d="M 420 100 L 180 150" fill="none" stroke="#22c55e" strokeWidth="2" strokeDasharray="10,10" className="flow-anim" /><circle cx="300" cy="125" r="14" fill="#22c55e" /><text x="300" y="130" textAnchor="middle" fill="white" fontSize="14">✓</text></g>)}{zone === 'world' && (<g><path d="M 420 220 L 180 150" fill="none" stroke="#cbd5e1" strokeWidth="2" /><path d="M 420 220 L 180 150" fill="none" stroke="#ef4444" strokeWidth="2" strokeDasharray="10,10" className="flow-anim" /><path d="M 300 175 L 290 195 L 310 195 Z" fill="#f59e0b" stroke="#b45309" strokeWidth="2" /><text x="300" y="192" textAnchor="middle" fill="#78350f">!</text></g>)}</svg></div><div className="h-48 border-t border-slate-200 bg-white p-6 flex flex-col justify-center"><div className="flex items-start gap-4 max-w-2xl mx-auto w-full"><div className={`w-12 h-12 shrink-0 rounded-full flex items-center justify-center text-xl ${zone === 'eu_roam' ? 'bg-emerald-100 text-emerald-600' : zone === 'de_eu' ? 'bg-blue-100 text-blue-600' : 'bg-amber-100 text-amber-600'}`}>{zone === 'eu_roam' ? <Icon d={ICONS.CheckCircle} /> : <Icon d={ICONS.AlertCircle} />}</div><div><h3 className={`font-bold text-lg mb-1 ${zone === 'eu_roam' ? 'text-emerald-800' : zone === 'de_eu' ? 'text-blue-800' : 'text-amber-800'}`}>{zone === 'de_eu' && "Status: Kostenpflichtig (International Call)"}{zone === 'eu_roam' && "Status: Roam like at Home (Inklusive)"}{zone === 'world' && "Status: Kostenrisiko (Zone 2/3)"}</h3><div className="text-sm text-slate-600 leading-relaxed">{zone === 'de_eu' && "Kosten fallen an (z.B. 0,29 €/Min)."}{zone === 'eu_roam' && "Keine Mehrkosten im EU-Ausland."}{zone === 'world' && "Hohe Kosten möglich! Option buchen!"}</div></div></div></div></div></div></div>); };
        
        const SkipReasonModal = ({ isOpen, onClose, onConfirm, reason, setReason, reasonMode, setReasonMode, drawnStrokes, setDrawnStrokes, canvasRef, startDrawing, draw, stopDrawing, MIN_LENGTH }) => {
            if (!isOpen) return null;
            const isPen = reasonMode === 'pen';
            const keyboardValid = reason.trim().length >= MIN_LENGTH;
            const penValid = drawnStrokes['skip_reason']?.length > 0;
            const isValid = isPen ? penValid : keyboardValid;
            const handleConfirm = () => { const reasonData = isPen ? 'HANDWRITING (Grund per Stift erfasst)' : reason; if (isValid) { onConfirm(reasonData); } };
            const clearCanvas = () => { const canvas = canvasRef.current; if (!canvas) return; const ctx = canvas.getContext('2d'); const dpr = window.devicePixelRatio || 1; ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr); setDrawnStrokes(prev => ({ ...prev, ['skip_reason']: [] })); };
            useEffect(() => { if (!isOpen || !isPen || !canvasRef.current || !drawnStrokes['skip_reason']) return; redrawCanvas(canvasRef.current, drawnStrokes['skip_reason'], 1, 'skip_reason'); }, [isOpen, isPen, drawnStrokes['skip_reason']]);
            return (<div className="fixed inset-0 z-[60] flex items-center justify-center bg-slate-900/70 backdrop-blur-sm p-4 animate-in fade-in"><div className="bg-white w-full max-w-xl rounded-2xl shadow-2xl p-6 relative border border-slate-200"><h3 className="text-xl font-black text-slate-800 mb-2 flex items-center gap-2"><Icon d={ICONS.AlertCircle} size={24} className="text-amber-600"/> Grund für Überspringen</h3><p className="text-sm text-slate-600 mb-4">Bitte geben Sie kurz an, warum die Situation-Analyse übersprungen wird (min. {MIN_LENGTH} Buchstaben/Stift-Eintrag).</p><div className="relative w-full h-32 border border-slate-300 rounded-lg bg-slate-50 overflow-hidden"><div className="absolute top-2 right-2 z-20 flex gap-1"><button onClick={() => setReasonMode(p => p === 'keyboard' ? 'pen' : 'keyboard')} className="p-1 hover:bg-slate-200 rounded text-slate-400 transition-colors" title={reasonMode === 'keyboard' ? 'Stift-Eingabe' : 'Tastatur-Eingabe'}><Icon d={reasonMode === 'keyboard' ? ICONS.Pen : ICONS.Keyboard} size={16}/></button>{isPen && drawnStrokes['skip_reason']?.length > 0 && (<button onClick={clearCanvas} className="p-1 hover:bg-slate-200 rounded text-slate-400" title="Löschen"><Icon d={ICONS.Trash} size={16}/></button>)}</div>{isPen ? (<canvas ref={canvasRef} className="absolute inset-0 w-full h-full cursor-crosshair z-10 drawing-canvas" style={{ touchAction: 'none' }} onPointerDown={(e) => startDrawing(e, canvasRef, 'skip_reason')} onPointerMove={(e) => draw(e, canvasRef, 'skip_reason')} onPointerUp={(e) => stopDrawing(e, canvasRef)} onPointerLeave={(e) => stopDrawing(e, canvasRef)}/>) : (<textarea value={reason} onChange={(e) => setReason(e.target.value)} onInput={(e) => setReason(e.target.value)} placeholder="Grund hier eingeben..." className="w-full h-full p-4 text-base font-medium text-slate-700 bg-transparent resize-none focus:ring-0 focus:outline-none pr-12" autoFocus maxLength={100}/>)}</div><div className="flex justify-between items-center mt-4"><span className={`text-xs font-bold transition-colors ${isValid ? 'text-green-600' : 'text-red-500'}`}>{isValid ? 'Anforderung erfüllt.' : `Mind. ${MIN_LENGTH} Buchstaben erforderlich.`}</span><div className="flex gap-2"><button onClick={onClose} className="px-4 py-2 text-slate-500 font-medium hover:bg-slate-100 rounded-lg transition-colors">Abbrechen</button><button onClick={handleConfirm} className={`px-6 py-2 rounded-lg font-bold shadow-md transition-all flex items-center gap-2 ${isValid ? 'bg-amber-600 text-white hover:bg-amber-700' : 'bg-slate-300 text-slate-500 cursor-not-allowed'}`} disabled={!isValid}>Bestätigen & Springen <Icon d={ICONS.ArrowRight} size={16}/></button></div></div></div></div>);
        };
        
        const AdminModal = ({ isOpen, onClose, questions, onUpdate, oneDriveLink, onUpdateLink }) => { 
            const [localData, setLocalData] = useState(questions); 
            const [localLink, setLocalLink] = useState(oneDriveLink || '');
            const [expandedCat, setExpandedCat] = useState(null); 
            useEffect(() => { setLocalData(questions); setLocalLink(oneDriveLink || ''); }, [questions, oneDriveLink, isOpen]); 
            const handleQuestionChange = (cat, index, val) => { const newQs = [...(localData[cat] || [])]; newQs[index] = val; setLocalData(prev => ({ ...prev, [cat]: newQs.filter(q => q.trim() !== '') })); }; 
            const handleAddQuestion = (cat) => { const newQs = [...(localData[cat] || []), "Neue Frage..."]; setLocalData(prev => ({ ...prev, [cat]: newQs })); }; 
            const handleSave = () => { const cleanedData = Object.keys(localData).reduce((acc, cat) => { acc[cat] = localData[cat].filter(q => q.trim() !== ''); return acc; }, {}); Object.keys(cleanedData).forEach(cat => onUpdate(cat, cleanedData[cat])); if (onUpdateLink) onUpdateLink(localLink.trim()); onClose(); }; 
            if (!isOpen) return null; 
            return (<div className="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/60 backdrop-blur-sm p-4 animate-in fade-in"> <div className="bg-white w-full max-w-2xl rounded-xl shadow-2xl flex flex-col max-h-[85vh]"> <div className="p-4 border-b border-slate-100 flex justify-between items-center bg-slate-50 rounded-t-xl"><h3 className="font-bold text-lg flex items-center gap-2 text-slate-800"><Icon d={ICONS.Lock} size={18}/> Admin: Fragen & Links</h3><button onClick={onClose} className="p-2 hover:bg-slate-200 rounded-full"><Icon d={ICONS.X} size={18}/></button></div> <div className="flex-1 overflow-y-auto p-6 space-y-6 custom-scrollbar"> <div className="border border-slate-200 rounded-lg p-4 bg-white shadow-sm"><h4 className="font-bold text-slate-700 mb-2 text-sm flex items-center gap-2"><Icon d={ICONS.Book} size={16} className="text-blue-500"/> Link zur Aktionsmappe (OneDrive)</h4><input type="url" value={localLink} onChange={(e) => setLocalLink(e.target.value)} placeholder="https://..." className="w-full border border-slate-300 p-2 rounded text-sm focus:ring-2 focus:ring-blue-200 outline-none text-slate-600"/><p className="text-[10px] text-slate-400 mt-1">Dieser Link wird beim Klick auf das Buch-Icon (Angebotsseite) geöffnet.</p></div><div className="border-t border-slate-100 pt-2"><h4 className="font-bold text-slate-700 mb-4 text-sm">Fragenkatalog bearbeiten</h4><div className="space-y-4">{Object.keys(localData).map(cat => ( <div key={cat} className="border border-slate-200 rounded-lg overflow-hidden"><button onClick={() => setExpandedCat(expandedCat === cat ? null : cat)} className={`w-full p-3 text-left font-bold flex justify-between items-center ${expandedCat === cat ? 'bg-blue-50 text-blue-700' : 'bg-white text-slate-700 hover:bg-slate-50'}`}><span>{cat === 'default' ? 'Standard Fragen' : cat}</span><Icon d={expandedCat === cat ? ICONS.ArrowLeft : ICONS.ArrowRight} className={`transform transition-transform ${expandedCat === cat ? '-rotate-90' : 'rotate-90'}`} size={16}/></button> {expandedCat === cat && (<div className="p-4 bg-slate-50/50 space-y-2 border-t border-slate-100">{localData[cat].map((q, i) => (<div key={i} className="flex gap-2"><input className="flex-1 border border-slate-300 p-2 rounded text-sm focus:ring-2 focus:ring-blue-200 outline-none" value={q} onChange={(e) => handleQuestionChange(cat, i, e.target.value)} /><button onClick={() => handleQuestionChange(cat, i, '')} className="p-2 text-red-400 hover:bg-red-100 rounded" title="Frage löschen"><Icon d={ICONS.Trash} size={16}/></button></div>))}<button onClick={() => handleAddQuestion(cat)} className="text-xs font-bold text-blue-600 hover:text-blue-800 mt-2 flex items-center gap-1"><Icon d={ICONS.Plus} size={14}/> Frage hinzufügen</button></div>)} </div> ))} </div></div></div> <div className="p-4 border-t border-slate-100 flex justify-end gap-2 bg-slate-50 rounded-b-xl"><button onClick={onClose} className="px-4 py-2 text-slate-500 font-medium hover:bg-slate-200 rounded-lg transition-colors">Abbrechen</button><button onClick={handleSave} className="px-6 py-2 bg-blue-600 text-white font-bold rounded-lg shadow-md hover:bg-blue-700 transition-colors">Alle Speichern</button></div> </div> </div> ); 
        };

const BundleModal = ({ isOpen, onClose, url, onImportToCanvas, triggerToast, targetKey = 'offer1' }) => {
    const iframeRef = useRef(null);
    const fileRef = useRef(null);
    const [isWorking, setIsWorking] = useState(false);

    const [currentUrl, setCurrentUrl] = useState(url || '');
    // NEW: do not auto-import on click. Preview first, then confirm via "Uebernehmen".
    const [pendingImport, setPendingImport] = useState(null); // { kind: "html"|"image", value: any }
    const [selectedBundleId, setSelectedBundleId] = useState('');


    const targetLabel = (targetKey === 'offer2') ? 'Canva 2' : (targetKey === 'offer3') ? 'Canva 3' : 'Canva 1';

    // Build a sharp, self-contained Bundle card HTML from a data payload (also used for DOM-extraction fallback)
    const buildHighResBundleHTML = (raw) => {
        const d = raw || {};
        // If the Aktionsmappe already provides the full card HTML (Tailwind classes), prefer it to keep the tile 1:1.
        // IMPORTANT: Pencil-Selling does not have the Tailwind stylesheet from the Aktionsmappe.
        // Therefore the original Laufzeit <select> can appear as an empty white bar. We inject a visible term badge
        // (24/36 Monate) right above 'ANGEBOTSPREIS' and apply minimal inline styles for selects.
        if (d && typeof d.cardHTML === 'string' && d.cardHTML.trim()) {
            const escInline = (s) => String(s ?? '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;');

            const rawTermInline = (d.laufzeit || d.term || d.duration || d.monate || d.months || '').toString().trim();
            const termBadgeInline = rawTermInline && !/mon/i.test(rawTermInline) ? (rawTermInline + ' Monate') : rawTermInline;

            let html = String(d.cardHTML);

            // Inject term badge above the label 'ANGEBOTSPREIS' (first occurrence only)
            if (termBadgeInline) {
                const badgeHTML = `<div data-ps-term-badge="1" style="display:inline-block;font-family:Arial,Helvetica,sans-serif;font-weight:900;font-size:13px;line-height:1;color:#fff;background:rgba(255,255,255,0.18);border:1px solid rgba(255,255,255,0.30);padding:6px 10px;border-radius:10px;margin-bottom:8px;">${escInline(termBadgeInline)}</div>`;
                // Insert right before the text 'ANGEBOTSPREIS'
                html = html.replace(/ANGEBOTSPREIS/i, `${badgeHTML}<div style="height:2px"></div>ANGEBOTSPREIS`);
            }

            const styleFix = `<style>
              
              /* === PS FIX: keep imported bundle card size consistent immediately === */
              .bundle-import-wrap{
                zoom: 0.78;
              }
              /* Fallback if zoom unsupported */
              @supports not (zoom:1){
                .bundle-import-wrap{
                  transform: scale(0.78);
                  transform-origin: top left;
                }
              }
/* Ensure term selector is readable even without Tailwind */
              .bundle-import-wrap select, .bundle-import-wrap option {
                color:#ffffff !important;
              }
              .bundle-import-wrap select {
                background: rgba(255,255,255,0.18) !important;
                border: 1px solid rgba(255,255,255,0.30) !important;
                border-radius: 10px !important;
                padding: 6px 10px !important;
                font-weight: 900 !important;
                font-size: 13px !important;
                appearance: none !important;
                -webkit-appearance: none !important;
              }
              /* If a select still renders as an empty white rectangle, hide it when we injected a badge */
              .bundle-import-wrap [data-ps-term-badge="1"] ~ select {
                display:none !important;
              }
            
/* ===== Share-PDF Center Override (kills FULLSCREEN_SHIFT_X translate) ===== */
@media (orientation: landscape) and (min-width: 1100px){
  body.pdf-share-mode .situation-view-wrapper,
  body.pdf-share-mode .print-situation-view,
  body.pdf-share-mode .print-offer-view{
    transform: none !important;
    margin-left: auto !important;
    margin-right: auto !important;
  }
}


/* === PATCH: Seite 5 Mini-Streifen Fix (Kostenblock + Unterschrift kompakt) === */
@media print {
    /* Seite 2/4: Angebot & Kosten-Kompaktierung */
    .print-offer-view {
        zoom: 0.76 !important; /* Minimal kleinerer Zoom (von 0.80) für mehr Puffer */
    }

    /* Der blaue Kasten (Unterschrift/Stempel) wird dünner gemacht */
    .cost-overview-print {
        padding-top: 6px !important;
        padding-bottom: 6px !important;
        margin-top: 4px !important;
        gap: 8px !important;
    }

    /* Die Eingabefelder im Kostenblock (EINMALIG / MONATLICH) schrumpfen um 2px */
    .cost-overview-print input, 
    .cost-overview-print select {
        height: 32px !important;
        padding-top: 2px !important;
        padding-bottom: 2px !important;
        font-size: 11px !important;
    }

    /* Abstand zwischen den Angebots-Canvas (1, 2, 3) reduzieren */
    .print-offer-view .offer-canvas-container {
        margin-bottom: 8px !important;
        min-height: 540px !important;
    }

    /* Disclaimer Text ganz unten noch etwas kleiner */
    .cost-overview-print .text-[10px], 
    .cost-overview-print p {
        font-size: 6.5pt !important;
        line-height: 1.0 !important;
        margin-top: 2px !important;
    }
}

</style>`;

            return `<div class="bundle-import-wrap" style="max-width:100%;">${styleFix}${html}</div>`;
        }
        const esc = (s) => String(s ?? '')
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;');

        const titel = esc(d.geraet || d.titel || d.bezeichnung || 'Bundle Angebot');
        const tarifName = esc(d.tarif || d.tarifName || d.artikelName || '');
        const preis = esc(d.preis || d.angebotspreis || '0,00 €');
        const validUntil = esc(d.validUntil || '');
        const detailsHTML = (d.detailsHTML || '');

        // Laufzeit/Term -> Badge (damit 24/36 korrekt sichtbar ist)
        const rawTerm = (d.laufzeit || d.term || d.duration || d.monate || d.months || '').toString().trim();
        const termBadge = rawTerm && !/mon/i.test(rawTerm) ? (rawTerm + ' Monate') : rawTerm;

        const baseBadges = Array.isArray(d.badges) ? d.badges : [];
        const badgesArr = (termBadge ? [termBadge, ...baseBadges] : baseBadges)
            .filter(Boolean)
            .map(esc)
            .slice(0, 6);

        const images = Array.isArray(d.images) ? d.images.slice(0, 3).map(esc)
            : (d.bildUrl ? [esc(d.bildUrl)] : (d.bild ? [esc(d.bild)] : []));

        // NOTE (v22): The Aktionsmappe often renders the SIM tile as an inline SVG / background
        // (not an <img>). Our importer extracts only <img> tags, so the 3rd picture can be missing
        // in Pencil-Selling even though it is visible in the popup.
        // We add a conservative fallback SIM image ONLY for o2 bundle cards when exactly 2 images
        // were found.
        const SIM_CARD_DATA_URI = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
          <svg xmlns="http://www.w3.org/2000/svg" width="256" height="256" viewBox="0 0 256 256">
            <defs>
              <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
                <stop offset="0" stop-color="#e5e7eb"/>
                <stop offset="1" stop-color="#f8fafc"/>
              </linearGradient>
            </defs>
            <rect x="28" y="42" width="200" height="172" rx="18" fill="url(#g)" stroke="#94a3b8" stroke-width="6"/>
            <path d="M176 42 L228 94 L228 42 Z" fill="#cbd5e1"/>
            <rect x="72" y="96" width="112" height="88" rx="12" fill="#ffffff" stroke="#cbd5e1" stroke-width="6"/>
            <rect x="92" y="118" width="40" height="20" rx="6" fill="#f59e0b"/>
            <rect x="142" y="118" width="40" height="20" rx="6" fill="#f59e0b"/>
            <rect x="92" y="148" width="90" height="20" rx="6" fill="#fbbf24"/>
          </svg>
        `);

        const titleOrTarif = `${(d.geraet || d.titel || d.bezeichnung || '')} ${(d.tarif || d.tarifName || '')}`.toLowerCase();
        const isLikelyO2Bundle = /\bo2\b/.test(titleOrTarif) || /o2\s*mobile/.test(titleOrTarif);
        if (isLikelyO2Bundle && images.length === 2) images.push(SIM_CARD_DATA_URI);

        const badgesHTML = badgesArr.map(b => `
            <span style="
                display:inline-flex;align-items:center;gap:6px;
                padding:6px 10px;border-radius:999px;
                background:#e7f2ff;color:#0b4aa2;
                font-size:12px;font-weight:800;
                border:1px solid #cfe5ff;
            ">${b}</span>
        `).join('');

        const imagesHTML = images.map(src => `
            <div style="
                background:#fff;border-radius:10px;
                border:1px solid #e5e7eb;
                padding:10px;
                width:220px;height:220px;
                display:flex;align-items:center;justify-content:center;
            ">
              <img src="${src}" style="max-width:100%;max-height:100%;object-fit:contain;display:block;" />
            </div>
        `).join('');

        return `
          <div style="
            width:100%; max-width:920px; margin:0 auto;
            background:#fff; border-radius:18px;
            border:2px solid #0b1e42;
            overflow:hidden;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
            pointer-events:none; user-select:none;
          ">
            <div style="
              background:#173a7a;
              color:#fff;
              padding:14px 18px;
              display:flex;
              align-items:center;
              justify-content:space-between;
              gap:14px;
            ">
              <div style="display:flex;align-items:center;gap:10px;min-width:0;">
                <span style="
                  width:28px;height:28px;
                  border-radius:8px;
                  background:rgba(255,255,255,.14);
                  display:flex;align-items:center;justify-content:center;
                  font-weight:900;
                ">📦</span>
                <div style="
                  font-size:22px;
                  font-weight:1000;
                  white-space:nowrap;
                  overflow:hidden;
                  text-overflow:ellipsis;
                  max-width:690px;
                ">${titel}</div>
              </div>

              ${validUntil ? `
                <div style="
                  padding:6px 10px;
                  border-radius:10px;
                  background:rgba(255,255,255,.12);
                  border:1px solid rgba(255,255,255,.22);
                  font-weight:800;
                  font-size:12px;
                  white-space:nowrap;
                ">Bis: ${validUntil}</div>
              ` : ``}
            </div>

            <div style="padding:18px 18px 16px 18px;">
              <div style="display:flex;align-items:flex-start;justify-content:space-between;gap:18px;">
                <div style="flex:1;min-width:0;">
                  ${tarifName ? `<div style="font-size:22px;font-weight:1000;color:#0b1e42;">${tarifName}</div>` : ``}
                  ${badgesArr.length ? `<div style="margin-top:10px;display:flex;gap:10px;flex-wrap:wrap;">${badgesHTML}</div>` : ``}
                </div>

                <div style="
                  width:170px;flex:0 0 170px;
                  background:#dc2626;
                  border-radius:12px;
                  color:#fff;
                  padding:12px 14px;
                  box-shadow:0 8px 20px rgba(0,0,0,.10);
                  text-align:center;
                ">
                  <div style="font-size:11px;font-weight:900;opacity:.95;letter-spacing:.06em;">PREIS</div>
                  <div style="font-size:30px;font-weight:1100;line-height:1.1;margin-top:6px;">${preis}</div>
                </div>
              </div>

              ${images.length ? `
                <div style="
                  margin-top:16px;
                  display:flex;
                  justify-content:center;
                  gap:18px;
                  flex-wrap:wrap;
                ">${imagesHTML}</div>
              ` : ``}

              ${detailsHTML ? `
                <div style="
                  margin-top:18px;
                  border-radius:14px;
                  border:1px solid #e5e7eb;
                  background:#f8fafc;
                  padding:14px 16px;
                ">
                  <div style="
                    border-left:4px solid #2563eb;
                    padding-left:12px;
                    color:#0f172a;
                    font-size:14px;
                    line-height:1.35;
                  ">${detailsHTML}</div>
                </div>
              ` : ``}
            </div>
          </div>
        `;
    };

    // Fallback: read the current selection (24/36 Monate) directly from the embedded Bundle page
    const tryExtractBundleDataFromIframe = () => {
        try {
            const doc = iframeRef.current?.contentDocument || iframeRef.current?.contentWindow?.document;
            if (!doc) return null;

            // 1) Laufzeit (aktuelle Auswahl 24/36 Monate)
            let termText = '';
            let termAnchor = null;

            // a) Klassisch: <select> (falls vorhanden)
            const selects = Array.from(doc.querySelectorAll('select'));
            const termSel = selects.find(s => {
                const name = ((s.getAttribute('name')||'') + ' ' + (s.getAttribute('id')||'') + ' ' + (s.getAttribute('class')||'')).toLowerCase();
                return /lauf|term|monat|dauer/.test(name);
            });
            if (termSel) {
                const opt = termSel.options[termSel.selectedIndex];
                termText = (opt && opt.textContent ? opt.textContent : '').trim();
                termAnchor = termSel;
            }

            // b) UI-Dropdown als Button/Badge (dein Fall: "36 Monate" sichtbar, aber kein <select>)
            if (!termText) {
                const rx = /\b(24|36)\s*monate\b/i;
                const candidates = Array.from(doc.querySelectorAll('*'))
                    .filter(el => {
                        if (!el) return false;
                        const t = (el.textContent || '').trim();
                        if (!t || t.length > 30) return false;
                        if (!rx.test(t)) return false;
                        try { return el.offsetParent !== null; } catch (_) { return false; }
                    });

                if (candidates.length) {
                    // Nimm das Element mit dem kuerzesten, passendsten Text (meist genau "36 Monate")
                    candidates.sort((a,b) => ((a.textContent||'').trim().length) - ((b.textContent||'').trim().length));
                    termText = (candidates[0].textContent || '').trim();
                    termAnchor = candidates[0];
                }
            }

// 2) Preis (nur der aktuell sichtbare Preis zur gewaehlten Laufzeit)
            let priceText = '';
            const euroRe = /\b\d{1,3}(?:[\.,]\d{2})\s?€\b/;

            const isVisibleEl = (el) => {
                try {
                    if (!el) return false;
                    const cs = doc.defaultView ? doc.defaultView.getComputedStyle(el) : null;
                    if (cs && (cs.display === 'none' || cs.visibility === 'hidden' || cs.opacity === '0')) return false;
                    const r = el.getBoundingClientRect ? el.getBoundingClientRect() : { width: 0, height: 0 };
                    return (r.width > 0 && r.height > 0);
                } catch (e) { return false; }
            };

            const pickVisiblePrice = (root) => {
                try {
                    const els = Array.from((root || doc.body).querySelectorAll('span,div,p,strong,b,td,li,h1,h2,h3,h4'))
                        .filter(isVisibleEl);
                    const hits = [];
                    for (const el of els) {
                        const t = (el.textContent || '').replace(/\s+/g,' ').trim();
                        if (!t || t.length > 80) continue;
                        const m = t.match(euroRe);
                        if (m) hits.push({ price: m[0], len: t.length, text: t });
                    }
                    if (!hits.length) return '';
                    hits.sort((a,b)=> a.len - b.len);
                    return hits[0].price || '';
                } catch (e) { return ''; }
            };

            // Erst im Umfeld der Laufzeit-Auswahl suchen (damit 36M nicht auf 24M faellt)
            let scope = doc.body;
            try {
                if (termSel && termSel.closest) {
                    scope = termSel.closest('section,form,main,article,div,[data-bundle-card],[data-bundle],[data-bundle-root],[data-tile],[role="dialog"]') || termSel.parentElement || doc.body;
                }
            } catch(e) {}

            // Robust: Preis zur aktuell gewaehlten Laufzeit finden
            const termNum = (termText && termText.match(/\b(24|36)\b/)) ? (termText.match(/\b(24|36)\b/)[1]) : '';
            const termRegex = termNum ? new RegExp('\\b' + termNum + '\\b.*monat', 'i') : null;

            const collectVisiblePrices = (root) => {
                const prices = [];
                try {
                    const walker = doc.createTreeWalker(root || doc.body, NodeFilter.SHOW_TEXT, null);
                    let n; let guard = 0;
                    while ((n = walker.nextNode()) && guard < 6000) {
                        guard += 1;
                        const txt = (n.nodeValue || '').replace(/\s+/g, ' ').trim();
                        if (!txt) continue;
                        const mm = txt.match(euroRe);
                        if (!mm) continue;
                        const el = n.parentElement;
                        if (!isVisibleEl(el)) continue;
                        prices.push({ value: mm[0], el });
                    }
                } catch(e) {}
                return prices;
            };

            const findBestPriceNearTerm = () => {
                if (!termRegex) return '';
                let best = '';
                try {
                    // 1) finde sichtbare Elemente, die "24/36 Monate" anzeigen
                    const termEls = Array.from((scope || doc.body).querySelectorAll('*'))
                        .filter(el => {
                            if (!isVisibleEl(el)) return false;
                            const t = (el.textContent || '').replace(/\s+/g, ' ').trim();
                            return t && termRegex.test(t);
                        })
                        .slice(0, 40);

                    // 2) pro Term-Element: im naechsten "Card/Tile"-Container Preis suchen
                    for (const tel of termEls) {
                        const container =
                            tel.closest('[data-bundle-card],[data-bundle],[data-bundle-root],article,section,main,div') || scope || doc.body;

                        const prices = collectVisiblePrices(container);
                        if (!prices.length) continue;

                        // Preis, der im DOM nach dem Term-Element kommt, bevorzugen
                        const after = prices.find(p => {
                            try { return !!(tel.compareDocumentPosition(p.el) & Node.DOCUMENT_POSITION_FOLLOWING); }
                            catch(e) { return false; }
                        });
                        best = (after ? after.value : prices[0].value) || best;
                        if (best) return best;
                    }
                } catch(e) {}
                return best;
            };

            priceText = findBestPriceNearTerm() || pickVisiblePrice(scope) || pickVisiblePrice(doc.body);

            // Heuristik: Wenn zwei Preise existieren und Laufzeit=36, nimm oft den guenstigeren (falls DOM nicht eindeutig)
            if (termNum === '36') {
                try {
                    const prices = collectVisiblePrices(scope);
                    if (prices && prices.length >= 2) {
                        const nums = prices.map(p => ({ raw: p.value, num: parseFloat(p.value.replace('€','').replace('.','').replace(',','.')) }))
                                         .filter(p => !isNaN(p.num))
                                         .sort((a,b) => a.num - b.num);
                        if (nums.length) priceText = nums[0].raw;
                    }
                } catch(e) {}
            }

            // Letzter Fallback: TreeWalker (falls alles als Canvas/ohne sichtbare Nodes gerendert ist)
            if (!priceText) {
                const walker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_TEXT, null);
                let n; let seen = 0;
                while ((n = walker.nextNode()) && seen < 3500) {
                    seen += 1;
                    const s = (n.nodeValue || '').replace(/\s+/g, ' ').trim();
                    if (!s) continue;
                    const m = s.match(euroRe);
                    if (m) { priceText = m[0]; break; }
                }
            }

            // 3) Titel (prefer header-like prominent text)
            let titleText = '';
            const headings = Array.from(doc.querySelectorAll('h1,h2,h3'));
            if (headings.length) {
                titleText = (headings[0].textContent || '').trim();
            }
            if (!titleText) {
                // fallback: longest "card header" text
                const candidates = Array.from(doc.querySelectorAll('div,span,strong'))
                    .map(el => (el.textContent || '').trim())
                    .filter(t => t.length >= 12 && t.length <= 90);
                titleText = candidates.sort((a,b)=>b.length-a.length)[0] || 'Bundle Angebot';
            }

            // 4) Tarif line (first short bold-ish line with "o2")
            let tarifText = '';
            const allTextEls = Array.from(doc.querySelectorAll('div,span,strong,p'));
            const o2Line = allTextEls.map(el => (el.textContent || '').replace(/\s+/g,' ').trim())
                .find(t => /^o2\s+/i.test(t) && t.length <= 40);
            if (o2Line) tarifText = o2Line;

            // 5) Images (up to 3 big visible imgs)
            const imgs = Array.from(doc.querySelectorAll('img'))
                .filter(img => {
                    const src = img.getAttribute('src') || '';
                    if (!src) return false;
                    const r = img.getBoundingClientRect ? img.getBoundingClientRect() : {width:0,height:0};
                    return (r.width >= 60 && r.height >= 60);
                })
                .slice(0, 3)
                .map(img => img.getAttribute('src'));

            // 6) Details (lines with GB/Internet/Partnerkarte)
            const detailLines = allTextEls
                .map(el => (el.textContent || '').replace(/\s+/g,' ').trim())
                .filter(t => /\b(GB|Internet|Partnerkarte)\b/i.test(t) && t.length <= 60);
            const uniq = []
            for (const t of detailLines) {
                if (!uniq.includes(t)) uniq.push(t);
                if (uniq.length >= 6) break;
            }
            const detailsHTML = uniq.map(t => `<div>${t}</div>`).join('');

            return {
                titel: titleText,
                tarif: tarifText,
                preis: priceText,
                term: termText,
                detailsHTML,
                images: imgs,
            };
        } catch (e) {
            return null;
        }
    };


    useEffect(() => {
        if (!isOpen) return;
        setCurrentUrl(ensureEmbedUrl(url || BUNDLE_URL || ''));
    }, [isOpen, url]);

    const ensureEmbedUrl = (rawUrl) => {
        const raw = String(rawUrl||'').trim();
        if (!raw) return '';
        try {
            const u = new URL(raw, window.location.href);
            u.hash = '';
            if (!u.searchParams.get('embed')) u.searchParams.set('embed','1');
            // cache-bust to avoid stale GitHub Pages / service worker cache
            u.searchParams.set('_ts', String(Date.now()));
            return u.toString();
        } catch (e) {
            const base = raw.split('#')[0];
            if (base.includes('?')) return base + '&embed=1&_ts=' + Date.now();
            return base + '?embed=1&_ts=' + Date.now();
        }
    };

    const buildBundleUrl = (bundleId) => {
        // IMPORTANT: always build from the stable base URL (url/BUNDLE_URL), not from currentUrl.
        // currentUrl may contain temporary states like #admin or user-edited params.
        const rawBase = String((url || BUNDLE_URL || currentUrl || '')).trim();
        if (!rawBase) return '';
        try {
            const u = new URL(rawBase, window.location.href);
            // normalize: drop hash and start fresh with query
            u.hash = '';
            u.search = '';
            u.searchParams.set('bundleId', bundleId);
            u.searchParams.set('embed', '1');
            // cache-bust to ensure latest cloud-synced content is fetched
            u.searchParams.set('_ts', String(Date.now()));
            return u.toString();
        } catch (e) {
            const base = rawBase.split('#')[0].split('?')[0];
            return base + '?bundleId=' + encodeURIComponent(bundleId) + '&embed=1&_ts=' + Date.now();
        }
    };

    const copyToClipboard = async (s) => {
        try {
            await navigator.clipboard.writeText(String(s||''));
            if (typeof triggerToast === 'function') triggerToast('Link kopiert.');
        } catch (_) {
            // fallback
            const ta = document.createElement('textarea');
            ta.value = String(s||'');
            document.body.appendChild(ta);
            ta.select();
            try { document.execCommand('copy'); } catch(e) {}
            document.body.removeChild(ta);
            if (typeof triggerToast === 'function') triggerToast('Link kopiert.');
        }
    };


    const gotAutoImportRef = useRef(false);

    
    const lastBundleDataRef = useRef(null);
    const lastBundleTsRef = useRef(0);
    const pendingBundleReqRef = useRef(null);
// Listen for screenshot messages from the iframe (optional: if the Bundle page supports it)
    // Robust: accepts {dataUrl} or {payload}. Also verifies sender (source window) + origin.
    useEffect(() => {
        if (!isOpen) return;

        gotAutoImportRef.current = false;

        const expectedWin = iframeRef.current?.contentWindow || null;
        let expectedOrigin = null;
        try { expectedOrigin = currentUrl ? (new URL(currentUrl)).origin : (url ? (new URL(url)).origin : null); } catch(_) {}

        const handler = (e) => {
            try {
                const d = e.data || {};
                if (!d || (d.type !== 'BUNDLE_SCREENSHOT' && d.type !== 'BUNDLE_DATA_TRANSFER')) return;

                // Security: accept only from our iframe window (if available) and/or from expected origin
                if (expectedWin && e.source && e.source !== expectedWin) return;
                if (expectedOrigin && e.origin && e.origin !== expectedOrigin) return;

                // 1) Legacy: Screenshot import (data:image...)
                if (d.type === 'BUNDLE_SCREENSHOT') {
                    const imageStr = d.dataUrl || d.payload;

                    if (typeof imageStr === 'string' && imageStr.startsWith('data:image')) {
                        gotAutoImportRef.current = true;
                        setPendingImport({ kind: 'image', value: imageStr });
                        if (typeof triggerToast === "function") triggerToast("Bundle geladen – bitte mit + Uebernehmen in " + targetLabel + " einfuegen.");
                        setIsWorking(false);
                    } else {
                        console.warn('BUNDLE_SCREENSHOT received but missing/invalid image data', d);
                    }
                    return;
                }

                // 2) NEW: Data transfer -> echtes HTML (scharf) in Canva 1
                if (d.type === 'BUNDLE_DATA_TRANSFER') {
                    const __now = Date.now();
                    lastBundleDataRef.current = d;
                    lastBundleTsRef.current = __now;
                    // If we are waiting for a fresh export, resolve when matching requestId or newer than request time
                    const __pend = pendingBundleReqRef.current;
                    if (__pend && !__pend.resolved) {
                        const matchId = (__pend.id && d.requestId && String(d.requestId) === String(__pend.id));
                        const newer = __now > (__pend.t0 || 0);
                        if (matchId || newer) {
                            __pend.resolved = true;
                            try { __pend.resolve(d); } catch(_) {}
                        }
                    }

const highResHTML = buildHighResBundleHTML(d);
                    gotAutoImportRef.current = true;
                    setPendingImport({ kind: "html", value: highResHTML });
                    if (typeof triggerToast === "function") triggerToast("Bundle geladen – bitte mit + Uebernehmen in " + targetLabel + " einfuegen.");
                    setIsWorking(false);
                    return;
                }
            } catch (err) {
                console.warn('BundleModal message handler failed', err);
            }
        };

        window.addEventListener('message', handler);
        return () => window.removeEventListener('message', handler);
    }, [isOpen, currentUrl, url, onImportToCanvas, triggerToast]);


    // --- CANVAS_LOCK_MODE: show ONLY the relevant slot buttons for the current Offer-Canvas ---
    // offer1 -> hw-01..03 | offer2 -> home-01..03 | offer3 -> tv-01..03
    const CANVAS_LOCK_MODE = true;
    const groupByTargetKey = (k) => {
        if (k === 'offer1') return 'hw';
        if (k === 'offer2') return 'home';
        if (k === 'offer3') return 'tv';
        // Fallback: try to infer from label
        const t = String(targetLabel || '').toLowerCase();
        if (t.includes('1')) return 'hw';
        if (t.includes('2')) return 'home';
        if (t.includes('3')) return 'tv';
        return 'hw';
    };
    const allowedIdsByGroup = {
        hw: ['hw-01','hw-02','hw-03'],
        home: ['home-01','home-02','home-03'],
        tv: ['tv-01','tv-02','tv-03'],
    };
    const activeGroup = groupByTargetKey(targetKey);
    const allowedIds = allowedIdsByGroup[activeGroup] || allowedIdsByGroup.hw;
    const defaultId = allowedIds[0];


    // When modal opens: always jump directly to the first slot of that canvas (e.g. hw-01)
    useEffect(() => {
        if (!isOpen) return;
        try {
            if (CANVAS_LOCK_MODE) {
                setSelectedBundleId(defaultId);
                setPendingImport(null);
                setIsWorking(false);
                setCurrentUrl(buildBundleUrl(defaultId));
            }
        } catch (_) {}
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isOpen, targetKey]);


    if (!isOpen) return null;

    const requestIframeScreenshot = () => {
        try {
            const win = iframeRef.current?.contentWindow;
            let targetOrigin = '*';
            try { targetOrigin = currentUrl ? (new URL(currentUrl)).origin : (url ? (new URL(url)).origin : '*'); } catch(_) {}
            if (win) {
                // Try to request structured data first (if supported), then screenshot fallback
                win.postMessage({ type: 'REQUEST_BUNDLE_DATA' }, targetOrigin);
                win.postMessage({ type: 'REQUEST_BUNDLE_SCREENSHOT' }, targetOrigin);
            }
        } catch (_) {}
    };

    const requestIframeBundleData = (requestId) => {
        try {
            const win = iframeRef.current?.contentWindow;
            let targetOrigin = '*';
            try { targetOrigin = currentUrl ? (new URL(currentUrl)).origin : (url ? (new URL(url)).origin : '*'); } catch(_) {}
            if (win) {
                // Ask the embedded bundle page to re-export the CURRENT selection (term/price) as data transfer
                win.postMessage({ type: 'REQUEST_BUNDLE_DATA_TRANSFER', requestId }, targetOrigin);
                // Backward compatible aliases (in case the bundle page uses another name)
                win.postMessage({ type: 'REQUEST_BUNDLE_DATA', requestId }, targetOrigin);
                win.postMessage({ type: 'EXPORT_BUNDLE_DATA', requestId }, targetOrigin);
            }
        } catch (_) {}
    };

    const waitForFreshBundleData = (t0, requestId, timeoutMs = 1200) => {
        return new Promise((resolve) => {
            // If we already have newer data, resolve immediately
            if (lastBundleTsRef.current && lastBundleTsRef.current > t0) {
                return resolve(lastBundleDataRef.current);
            }
            let done = false;
            const timer = setTimeout(() => {
                if (done) return;
                done = true;
                // cleanup pending
                if (pendingBundleReqRef.current && pendingBundleReqRef.current.id === requestId) {
                    pendingBundleReqRef.current = null;
                }
                resolve(null);
            }, timeoutMs);

            pendingBundleReqRef.current = {
                id: requestId,
                t0,
                resolved: false,
                resolve: (d) => {
                    if (done) return;
                    done = true;
                    clearTimeout(timer);
                    pendingBundleReqRef.current = null;
                    resolve(d);
                }
            };
        });
    };

    const handleImportClick = async () => {
        if (isWorking) return;
        setIsWorking(true);

        
        // Always request a fresh data export first (so 24/36 Monate is correct)
        const __reqId = String(Date.now()) + '_' + Math.random().toString(16).slice(2);
        const __t0 = Date.now();
        gotAutoImportRef.current = false;
        requestIframeBundleData(__reqId);
        // Wait a moment for BUNDLE_DATA_TRANSFER to arrive (if supported)
        await waitForFreshBundleData(__t0, __reqId, 1300);
        if (gotAutoImportRef.current) {
            // We already imported via BUNDLE_DATA_TRANSFER handler
            setIsWorking(false);
            return;
        }

// 0) BEST: Same-origin DOM-extraction (reads the CURRENT 24/36 selection from the iframe)
        try {
            const extracted = tryExtractBundleDataFromIframe();
            if (extracted) {
                gotAutoImportRef.current = true;
                const highResHTML = buildHighResBundleHTML(extracted);
                setPendingImport({ kind: 'html', value: highResHTML });
                if (typeof triggerToast === 'function') triggerToast('Bundle geladen – bitte mit + Uebernehmen in ' + targetLabel + ' einfuegen.');
                setIsWorking(false);
                return;
            }
        } catch(_) {}

        // 1) Try postMessage flow (works if the Bundle page implements it)
        requestIframeScreenshot();

        // 2) Short wait for a response; if none -> fallback to manual file import
        await new Promise((res) => setTimeout(res, 6000));

        // If no auto-import arrived, stop spinner and show the hint.
        if (!gotAutoImportRef.current) {
            setIsWorking(false);
            if (typeof triggerToast === 'function') {
                triggerToast('Kein Auto-Import erhalten. Prüfe bitte, ob der Link die Einzelansicht enthält (?...bundleId=...) und die Aktionsmappe den postMessage-Export (BUNDLE_DATA_TRANSFER) unterstützt.');
            }
        }
    };

    const handleFilePick = (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
            const dataUrl = reader.result;
            if (typeof dataUrl === 'string' && dataUrl.startsWith('data:image') && typeof onImportToCanvas === 'function') {
                onImportToCanvas(dataUrl);
                if (typeof triggerToast === 'function') triggerToast('Bild in Canva 1 übernommen.');
            }
            e.target.value = '';
        };
        reader.readAsDataURL(file);
    };


    const handleConfirmImport = () => {
        if (!pendingImport) {
            if (typeof triggerToast === "function") triggerToast("Bitte erst ein Bundle waehlen und laden.");
            return;
        }
        try {
            if (typeof onImportToCanvas === "function") {
                if (pendingImport.kind === "image") {
                    onImportToCanvas(pendingImport.value);
                } else if (pendingImport.kind === "html") {
                    onImportToCanvas({ kind: "html", html: pendingImport.value });
                }
            }
            if (typeof triggerToast === "function") triggerToast("In " + targetLabel + " uebernommen.");
            setPendingImport(null);
            onClose();
        } catch (_) {}
    };




    return (
        <div className="fixed inset-0 z-[120] flex items-center justify-center bg-slate-900/70 backdrop-blur-sm p-3 animate-in fade-in">
            <div className="bg-white w-[95vw] h-[90vh] rounded-2xl shadow-2xl border border-slate-200 relative overflow-hidden">
                <button
                    type="button"
                    onClick={onClose}
                    className="absolute top-3 right-3 z-10 w-10 h-10 rounded-full bg-white/90 border border-slate-200 text-slate-600 hover:bg-slate-50 hover:text-slate-900 transition-colors flex items-center justify-center"
                    title="Schließen"
                >
                    <Icon d={ICONS.X} size={18}/>
                </button>

                <div className="absolute top-3 left-3 right-14 z-10 flex flex-col gap-2">
                    <div className="flex items-center gap-2 flex-wrap">
                                                <button type="button" onClick={handleImportClick} className="px-3 py-2 rounded-xl bg-slate-900 text-white font-bold shadow hover:bg-slate-800 transition-colors" title="Bundle laden (nur Vorschau)">{isWorking ? 'Lade…' : '🔄 Laden'}</button>
                        <button type="button" onClick={handleConfirmImport} disabled={!pendingImport} className={pendingImport ? "px-3 py-2 rounded-xl bg-emerald-600 text-white font-bold shadow hover:bg-emerald-700 transition-colors" : "px-3 py-2 rounded-xl bg-slate-200 text-slate-400 font-bold cursor-not-allowed"} title={pendingImport ? ("In " + targetLabel + " uebernehmen") : "Noch nichts geladen"}>➕ Uebernehmen</button>

                        <span className="text-[11px] text-slate-500 hidden sm:inline">
                            Tipp: Nutze die festen Buttons (hw/home/tv). Link bleibt immer gleich – du änderst nur den Inhalt im Admin.
                        </span>

                        <input
                            ref={fileRef}
                            type="file"
                            accept="image/*"
                            onChange={handleFilePick}
                            style={{ display: 'none' }}
                        />
                    </div>

                    <div className="flex flex-col gap-2 bg-white/90 border border-slate-200 rounded-2xl p-2 shadow-sm">
                        
                        <div className="flex flex-wrap gap-2 items-center">
                            <div className="text-[10px] font-black text-slate-500 uppercase tracking-wider mr-1">{activeGroup === 'hw' ? 'CANVAS 1' : (activeGroup === 'home' ? 'CANVAS 2' : 'CANVAS 3')}</div>
                            {allowedIds.map(id => (
                                <button
                                    key={id}
                                    type="button"
                                    onClick={() => {
                                        setSelectedBundleId(id);
                                        setPendingImport(null);
                                        setIsWorking(false);
                                        setCurrentUrl(buildBundleUrl(id));
                                    }}
                                    className={
                                        (selectedBundleId === id)
                                            ? 'px-2.5 py-1.5 rounded-xl bg-blue-600 border border-blue-700 text-white text-xs font-black shadow'
                                            : 'px-2.5 py-1.5 rounded-xl bg-slate-50 border border-slate-200 text-slate-700 text-xs font-black hover:bg-blue-50 hover:border-blue-200 hover:text-blue-700 transition-colors'
                                    }
                                >
                                    {id}
                                </button>
                            ))}

                            {/* Admin + Copy bewusst ausgeblendet (wie gewuenscht) */}
                        </div>

                        <div className="flex items-center gap-2">
                            <div className="text-[10px] font-black text-slate-500 uppercase tracking-wider">Link</div>
                            <input
                                value={currentUrl}
                                readOnly
                                className="flex-1 px-3 py-2 rounded-xl border border-slate-200 bg-white text-xs font-semibold text-slate-800 focus:outline-none focus:ring-2 focus:ring-blue-200"
                                placeholder="https://jefferson990.github.io/Verkaufsmappe/?bundleId=hw-01"
                            />
                        </div>
                    </div>
                </div>

                <div className="w-full h-full p-3 pt-44 relative overflow-hidden">
                    <iframe
                        ref={iframeRef}
                        title="Bundle Manager"
                        src={currentUrl}
                        // Crop the embedded page header/navigation inside the iframe (no cross-origin access needed)
                        style={{ position: 'relative', top: '-140px', height: 'calc(100% + 140px)' }}
                        className="w-full h-full rounded-xl border border-slate-200"
                        sandbox="allow-same-origin allow-scripts"
                    />
                </div>
            </div>
        </div>
    );
};



        const StatsModal = ({ isOpen, onClose }) => {
const resolveUserName = (raw) => {
                const s = (raw == null) ? '' : String(raw).trim();
                if (!s) return 'Elif Icik';
                const low = s.toLowerCase();
                if (s === 'E.I' || low === 'e.i') return 'Elif Icik';
                if (s === 'Max Mustermann' || low === 'unknown') return 'Elif Icik';
                return s;
            };

                        const [range, setRange] = useState('7'); // '1' | '7' | '31' | 'all'
            const rows = useMemo(() => loadAnalyticsRows().slice().reverse(), [isOpen]);

            const filtered = useMemo(() => {
                if (!rows.length) return [];
                if (range === 'all') return rows;
                const days = parseInt(range, 10);
                const now = Date.now();
                const maxAge = days * 24 * 60 * 60 * 1000;
                return rows.filter(r => {
                    const t = new Date(r.ts).getTime();
                    return Number.isFinite(t) && (now - t) <= maxAge;
                });
            }, [rows, range]);

            const summary = useMemo(() => {
                const agg = {}; // user -> { total, angebot, abschluss, strokes, canv: {key:{usedCount, strokes}} }
                filtered.forEach(r => {
                    const u = resolveUserName(r.user);
                    if (!agg[u]) agg[u] = { total: 0, angebot: 0, abschluss: 0, strokes: 0, explainSum: 0, scoreSum: 0, canv: {} };
                    agg[u].total += 1;
                    if (r.result === 'Angebot') agg[u].angebot += 1;
                    if (r.result === 'Abschluss') agg[u].abschluss += 1;
                    const cs = r.canvasStats || {};
                    // Fair KPI: Erklärung (Text >=5 ODER Stift >=1) ist bereits in canvasStats.used abgebildet
                    const csEntries = Object.entries(cs).filter(([k]) => k !== 'skip_reason');
                    let rowUsed = 0;
                    let rowStrokes = 0;
                    csEntries.forEach(([_, v]) => {
                        if (v && v.used) rowUsed += 1;
                        if (v && Number.isFinite(v.strokes)) rowStrokes += v.strokes;
                    });
                    const rowExplain = csEntries.length ? (rowUsed / csEntries.length) : 0; // 0..1
                    const visualFactor = Math.min(1, rowStrokes / 8); // cap: 8 strokes => 100% Visual
                    const rowScore = (rowExplain * 100 * 0.7) + (visualFactor * 100 * 0.3); // 0..100
                    agg[u].explainSum += rowExplain;
                    agg[u].scoreSum += rowScore;

                    for (const [k, v] of Object.entries(cs)) {
                        if (!agg[u].canv[k]) agg[u].canv[k] = { usedCount: 0, strokes: 0 };
                        if (v.used) agg[u].canv[k].usedCount += 1;
                        agg[u].canv[k].strokes += (v.strokes || 0);
                        agg[u].strokes += (v.strokes || 0);
                    }
                });
                return agg;
            }, [filtered]);

            const allCanvasKeys = useMemo(() => {
                const s = new Set();
                filtered.forEach(r => Object.keys(r.canvasStats || {}).forEach(k => s.add(k)));
                // Für Übersicht: Situation-Keys zuerst
                const arr = Array.from(s);
                arr.sort((a,b) => {
                    const aSit = a.startsWith('sit_') ? 0 : 1;
                    const bSit = b.startsWith('sit_') ? 0 : 1;
                    if (aSit !== bSit) return aSit - bSit;
                    return a.localeCompare(b);
                });
                return arr;
            }, [filtered]);

            // Labels für Statistik (UI)
            const prettyUser = (u) => {
                const s = String(u || '').trim();
                if (s === 'E.I' || s === 'EI' || s.toLowerCase() === 'e.i') return 'Elif Icik';
                return s || '—';
            };

            const prettyField = (k) => {
                if (!k) return '';
                if (k === 'offer1') return '1. Hardware, Anbieter & Nutzung';
                if (k === 'offer2') return '2. Haushalt und weitere Produkte';
                if (k === 'offer3') return '3. Fernsehen & Wi‑Fi';
                if (k === 'skip_reason') return 'Überspringen';
                if (k.startsWith('sit_')) return k.replace('sit_','S:');
                if (k.startsWith('offer')) return k.replace('offer','O:');
                if (k.startsWith('cost_')) return k.replace('cost_','K:');
                if (k === 'agent_name') return 'Agent';
                if (k === 'date_field') return 'Datum';
                return k;
            };

            const trend6m = useMemo(() => {
                const now = new Date();
                const months = [];
                for (let i = 5; i >= 0; i--) {
                    const d = new Date(now.getFullYear(), now.getMonth() - i, 1);
                    const key = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`;
                    const label = d.toLocaleString('de-DE', { month: 'short', year: '2-digit' });
                    months.push({ key, label, total: 0, strokesSum: 0 });
                }
                const byKey = Object.fromEntries(months.map(m => [m.key, m]));

                (filtered || []).forEach(r => {
                    const t = Date.parse(r.ts);
                    if (!Number.isFinite(t)) return;
                    const d = new Date(t);
                    const key = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`;
                    const bucket = byKey[key];
                    if (!bucket) return;

                    const cs = r.canvasStats || {};
                    let strokes = 0;
                    Object.values(cs).forEach(v => {
                        if (v && Number.isFinite(v.strokes)) strokes += v.strokes;
                    });

                    bucket.total += 1;
                    bucket.strokesSum += strokes;
                });

                return months.map(m => ({
                    ...m,
                    strokesAvg: m.total ? (m.strokesSum / m.total).toFixed(1) : '0.0',
                }));
            }, [filtered]);


            const handleClear = () => {
                if (!confirm('Analytics wirklich löschen?')) return;
                clearAnalyticsRows();
                onClose();
                alert('Analytics gelöscht.');
            };

            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-[70] flex items-center justify-center bg-slate-900/70 backdrop-blur-sm p-4 animate-in fade-in">
                    <div className="bg-white w-full max-w-5xl max-h-[90vh] overflow-hidden rounded-2xl shadow-2xl border border-slate-200 flex flex-col">
                        <div className="p-4 border-b border-slate-200 flex items-center justify-between">
                            <div className="flex items-center gap-3">
                                <div className="w-10 h-10 rounded-xl bg-blue-50 border border-blue-100 flex items-center justify-center text-blue-700">
                                    <Icon d={ICONS.Lock} size={18}/>
                                </div>
                                <div>
                                    <div className="text-xl font-black text-slate-800 leading-tight">📊 Statistik</div>
                                    <div className="text-xs text-slate-500">DSGVO-safe: nur Nutzung (kein Inhalt)</div>
                                </div>
                            </div>
                            <button onClick={onClose} className="p-2 hover:bg-slate-100 rounded-full text-slate-500" title="Schließen">
                                <Icon d={ICONS.X} size={20}/>
                            </button>
                        </div>

                        <div className="p-4 border-b border-slate-200 flex flex-wrap items-center gap-2">
                            <div className="text-xs font-bold text-slate-500 uppercase tracking-wider mr-2">Zeitraum</div>
                            {[
                                { id:'1', label:'Heute (24h)' },
                                { id:'7', label:'7 Tage' },
                                { id:'31', label:'31 Tage' },
                                { id:'all', label:'Alles' },
                            ].map(r => (
                                <button key={r.id} onClick={() => setRange(r.id)}
                                    className={`px-3 py-1.5 rounded-full text-sm font-bold border transition-colors ${range===r.id ? 'bg-blue-600 text-white border-blue-600' : 'bg-white text-slate-600 border-slate-200 hover:bg-slate-50'}`}>
                                    {r.label}
                                </button>
                            ))}
                            <div className="ml-auto flex flex-wrap gap-2">
                                <button onClick={exportAnalyticsCSV} className="px-3 py-1.5 rounded-lg text-sm font-bold bg-slate-900 text-white hover:bg-slate-800 flex items-center gap-2">
                                    <Icon d={ICONS.Download} size={16}/> CSV
                                </button>
                                <button onClick={exportAnalyticsJSON} className="px-3 py-1.5 rounded-lg text-sm font-bold bg-white border border-slate-200 text-slate-700 hover:bg-slate-50 flex items-center gap-2">
                                    <Icon d={ICONS.Download} size={16}/> JSON
                                </button>
                                <button onClick={handleClear} className="px-3 py-1.5 rounded-lg text-sm font-bold bg-white border border-red-200 text-red-600 hover:bg-red-50 flex items-center gap-2">
                                    <Icon d={ICONS.Trash} size={16}/> Löschen
                                </button>
                            </div>
                        </div>

                        <div className="p-4 overflow-y-auto">
                            <div className="grid grid-cols-1 md:grid-cols-3 gap-3 mb-4">
                                <div className="p-4 rounded-2xl border border-slate-200 bg-slate-50">
                                    <div className="text-xs font-bold text-slate-500 uppercase tracking-wider">Vorgänge</div>
                                    <div className="text-3xl font-black text-slate-900">{filtered.length}</div>
                                </div>
                                <div className="p-4 rounded-2xl border border-slate-200 bg-slate-50">
                                    <div className="text-xs font-bold text-slate-500 uppercase tracking-wider">Angebote</div>
                                    <div className="text-3xl font-black text-slate-900">{filtered.filter(r => r.result==='Angebot').length}</div>
                                </div>
                                <div className="p-4 rounded-2xl border border-slate-200 bg-slate-50">
                                    <div className="text-xs font-bold text-slate-500 uppercase tracking-wider">Abschlüsse</div>
                                    <div className="text-3xl font-black text-slate-900">{filtered.filter(r => r.result==='Abschluss').length}</div>
                                </div>
                            </div>

                            

                            <div className="text-xs font-bold text-slate-500 uppercase tracking-wider mb-2 mt-4">Trend (letzte 6 Monate)</div>
                            <div className="overflow-x-auto border border-slate-200 rounded-2xl">
                                <table className="min-w-max w-max text-sm">
                                    <thead className="bg-slate-50">
                                        <tr className="text-left">
                                            <th className="p-3 font-black text-slate-700">Monat</th>
                                            <th className="p-3 font-black text-slate-700">Vorgänge</th>

                                            <th className="p-3 font-black text-slate-700"><span title="Ø Stift-Eingaben (Strokes) pro Vorgang. Tastatur zählt nicht.">Ø Stift-Eingaben</span></th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {trend6m.map(m => (
                                            <tr key={m.key} className="border-t border-slate-200">
                                                <td className="p-3 font-bold text-slate-800">{m.label}</td>
                                                <td className="p-3 text-slate-700">{m.total}</td>

                                                <td className="p-3 text-slate-700">{m.strokesAvg}</td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
<div className="text-xs font-bold text-slate-500 uppercase tracking-wider mb-2">Pro Mitarbeiter</div>
                            <div className="overflow-x-auto border border-slate-200 rounded-2xl">
                                <table className="min-w-max w-max text-sm">
                                    <thead className="bg-slate-50">
                                        <tr className="text-left">
                                            <th className="p-3 font-black text-slate-700">Mitarbeiter</th>
                                            <th className="p-3 font-black text-slate-700">Vorgänge</th>
                                            <th className="p-3 font-black text-slate-700">Angebot</th>
                                            <th className="p-3 font-black text-slate-700">Abschluss</th>
                                            <th className="p-3 font-black text-slate-700"><span title="Ø Stift-Eingaben (Strokes) pro Vorgang. Tastatur zählt nicht.">Ø Stift-Eingaben</span></th>
                                            {allCanvasKeys.map(k => (
                                                <th key={k} className="p-3 font-black text-slate-700">{prettyField(k)}</th>
                                            ))}
                                            
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {Object.entries(summary).length === 0 ? (
                                            <tr><td className="p-4 text-slate-500" colSpan={10}>Noch keine Daten. Tipp: Ein Vorgang wird automatisch geloggt, sobald du „Angebot drucken“ oder „Abschluss“ auswählst.</td></tr>
                                        ) : Object.entries(summary).map(([user, s]) => {
                                            const avgStrokes = (s.strokes / Math.max(1, s.total)).toFixed(1);
                                            const explainPct = Math.round((s.explainSum / Math.max(1, s.total)) * 100);
                                            const scoreAvg = Math.round((s.scoreSum / Math.max(1, s.total)));
                                            return (
                                                <tr key={user} className="border-t border-slate-200">
                                                    <td className="p-3 font-bold text-slate-800">{prettyUser(user)}</td>
                                                    <td className="p-3 text-slate-700">{s.total}</td>
                                                    <td className="p-3 text-slate-700">{s.angebot}</td>
                                                    <td className="p-3 text-slate-700">{s.abschluss}</td>
                                                    <td className="p-3 text-slate-700">{avgStrokes}</td>
                                                    {allCanvasKeys.map(k => {
                                                        const c = s.canv[k] || { usedCount: 0, strokes: 0 };
                                                        const pct = Math.round((c.usedCount / Math.max(1, s.total)) * 100);
                                                        return (
                                                            <td key={k} className="p-3 text-slate-700">
                                                                <div className="text-xs text-slate-500">{pct}%</div>
                                                                <div className="font-bold">{c.usedCount}</div>
                                                            </td>
                                                        );
                                                    })}
                                                    
                                                </tr>
                                            );
                                        })}
                                    </tbody>
                                </table>
                            </div>

                            <div className="mt-4 text-xs text-slate-500">
                                Export-Tipp: CSV erzeugt jetzt 2 Dateien: *_summary (kompakt) und *_fields (Pivot: field, used, strokes).
                            </div>
                        </div>
                    </div>
                </div>
            );
        };


        const QuestionModal = ({ isOpen, onClose, category, question, onNextQuestion }) => { if (!isOpen) return null; return (<div className="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/40 backdrop-blur-sm p-4"><div className="bg-white rounded-2xl shadow-2xl w-full max-w-lg p-6"><h3 className="text-xl font-bold mb-4">Frage zu: {category}</h3><p className="text-lg mb-6">{question}</p><div className="flex justify-end gap-2"><button onClick={onNextQuestion} className="px-4 py-2 border rounded">Nächste</button><button onClick={onClose} className="px-4 py-2 bg-blue-600 text-white rounded">OK</button></div></div></div>); };

        // --- OFFER CANVAS (Redraw Patch Applied) ---
        const redrawCanvas = (canvas, strokes, scaleFactor = 1, key = '') => { 
            if (!canvas) return; 
            // ✅ Wichtig für Drehen/Resize: Canvas-Pixelgröße immer an CSS-Größe anpassen (sonst "verschiebt" sich alles)
            try {
                const r = canvas.getBoundingClientRect();
                const w = Math.max(1, Math.round(r.width || 0));
                const h = Math.max(1, Math.round(r.height || 0));
                if (w && h && (canvas.width !== w || canvas.height !== h)) {
                    canvas.width = w;
                    canvas.height = h;
                }
            } catch(_) {}
            const ctx = canvas.getContext('2d'); 
            if (!ctx) return;
            ctx.setTransform(1,0,0,1,0,0);
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            ctx.save(); 
            const isOfferCanvas = key.startsWith('offer') || key.startsWith('cost_') || key.startsWith('agent_') || key.startsWith('date_') || key.startsWith('signature'); 
            strokes.forEach(stroke => { 
                ctx.beginPath(); 
                let currentCssWidth = canvas.getBoundingClientRect().width;
                let currentCssHeight = canvas.getBoundingClientRect().height;
                if (currentCssWidth === 0) currentCssWidth = stroke.baseWidth || 100; // FIX: Print Fallback
                if (currentCssHeight === 0) currentCssHeight = stroke.baseHeight || (stroke.baseWidth ? (stroke.baseWidth * 0.66) : 100); // best-effort fallback
                const scaleW = currentCssWidth / (stroke.baseWidth || currentCssWidth);
                const scaleH = (stroke.baseHeight ? (currentCssHeight / stroke.baseHeight) : scaleW);
                // ✅ Uniform scaling: prevents "overstretching" when aspect ratio changes (tablet rotate/fullscreen)
                const responsiveScaleFactor = Math.min(scaleW, scaleH); 
                const rawStrokeWidth = stroke.width; 
                let visualBaseWidth; 
                if (isOfferCanvas) { visualBaseWidth = rawStrokeWidth === 2 ? 2.5 : rawStrokeWidth === 4 ? 5 : 8; } else { visualBaseWidth = rawStrokeWidth === 2 ? 2 : rawStrokeWidth === 4 ? 3 : 5; } 
                const normalizedBaseLineWidth = (visualBaseWidth * responsiveScaleFactor); 
                if (stroke.tool === 'eraser') { ctx.lineWidth = normalizedBaseLineWidth * 4; ctx.globalCompositeOperation = 'destination-out'; ctx.globalAlpha = 1; } else if (stroke.tool === 'highlighter') { ctx.lineWidth = normalizedBaseLineWidth * 3; ctx.strokeStyle = stroke.color; ctx.globalAlpha = stroke.opacity; ctx.globalCompositeOperation = 'destination-over'; } else { ctx.lineWidth = normalizedBaseLineWidth; ctx.strokeStyle = stroke.color; ctx.globalAlpha = stroke.opacity; ctx.globalCompositeOperation = 'source-over'; } 
                if (stroke.points.length > 0) {
                    const pts = stroke.points.map(p => ({ x: p.x * responsiveScaleFactor, y: p.y * responsiveScaleFactor }));
                    ctx.moveTo(pts[0].x, pts[0].y);
                    const isSmooth = (stroke.tool === 'fountain' || stroke.tool === 'ballpen');
                    if (isSmooth && pts.length >= 3) {
                        // Quadratic smoothing via midpoints
                        for (let i = 1; i < pts.length - 2; i++) {
                            const xc = (pts[i].x + pts[i + 1].x) / 2;
                            const yc = (pts[i].y + pts[i + 1].y) / 2;
                            ctx.quadraticCurveTo(pts[i].x, pts[i].y, xc, yc);
                        }
                        // last two points
                        const pN1 = pts[pts.length - 2];
                        const pN = pts[pts.length - 1];
                        ctx.quadraticCurveTo(pN1.x, pN1.y, pN.x, pN.y);
                    } else {
                        pts.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
                    }
                } 
                ctx.stroke(); 
            }); 
            ctx.restore(); 
            ctx.globalCompositeOperation = 'source-over'; 
            ctx.globalAlpha = 1; 
        };

        const OfferCanvas = React.memo(({
            canvasRef, label, icon, statusKey, status, setStatus,
            inputMode, startDrawing, draw, stopDrawing,
            textValue, handleTextChange,
            textStyle, textSize,
            drawnStrokes, setDrawnStrokes,
            scaleRef, triggerRedraw,
            image, onClearImage, onClearOverlay,
            imageTransform, onUpdateImageTransform,
            followUpInfo, onOpenBundleModal,
            triggerToast
        }) => {
                const SIZE_DIFFERENCE_THRESHOLD = 5;

                // Overlay-HTML ist global gespiegelt (wird unten in Window gesetzt)
                const htmlGlobalKey = (statusKey === 'offer1') ? '__canvasHtmlOffer1' : (statusKey === 'offer2') ? '__canvasHtmlOffer2' : (statusKey === 'offer3') ? '__canvasHtmlOffer3' : null;
                const htmlOverlay = htmlGlobalKey ? window[htmlGlobalKey] : null;

                // ✅ Inhalterkennung direkt am Canvas (wichtig: auch nach Radieren korrekt)
                const canvasHasVisibleInkLocal = (canvas) => {
                    try {
                        if (!canvas) return false;
                        const w = canvas.width || 0;
                        const h = canvas.height || 0;
                        if (!w || !h) return false;
                        const ctx2d = canvas.getContext('2d', { willReadFrequently: true });
                        if (!ctx2d) return false;

                        // Sample-Scan (Performance): nicht jedes Pixel, aber zuverlässig
                        const step = Math.max(4, Math.floor(Math.min(w, h) / 80));
                        const img = ctx2d.getImageData(0, 0, w, h);
                        const d = img.data;

                        for (let y = 0; y < h; y += step) {
                            const row = y * w * 4;
                            for (let x = 0; x < w; x += step) {
                                const a = d[row + x * 4 + 3];
                                if (a && a > 0) return true;
                            }
                        }
                        return false;
                    } catch (_) {
                        return false;
                    }
                };

                const cEl = (canvasRef && canvasRef.current) ? canvasRef.current : null;
                const hasInk = cEl ? canvasHasVisibleInkLocal(cEl) : !!(drawnStrokes && drawnStrokes.length);
                const hasText = !!String(textValue || '').trim();
                const hasOverlay = !!(image || htmlOverlay);
                const isEmpty = !(hasInk || hasText || hasOverlay);

                // Auto-Inhalterkennung:
                // - Wenn leer -> Status immer neutral (kein "Offen/Abgeschlossen" noetig)
                // - Wenn Inhalt vorhanden -> User kann "Offen" oder "Abgeschlossen" setzen
                React.useEffect(() => {
                    try {
                        if (isEmpty && status !== 'neutral') {
                            setStatus(prev => ({ ...prev, [statusKey]: 'neutral' }));
                        }
                    } catch (e) { /* ignore */ }
                }, [isEmpty, status, statusKey, setStatus]);

                const toggleStatus = (newStatus) => {
                    // Wenn der Bereich leer ist, kein Status-Wechsel erzwingen (bleibt neutral)
                    if (isEmpty) {
                        try { triggerToast && triggerToast('Status nur noetig, wenn im Feld Inhalt vorhanden ist.'); } catch(e) {}
                        setStatus(prev => ({ ...prev, [statusKey]: 'neutral' }));
                        return;
                    }

                    if (newStatus === 'closed') {
                        setStatus(prev => ({ ...prev, [statusKey]: (prev[statusKey] === 'closed' ? 'neutral' : 'closed') }));
                        return;
                    }
                    if (newStatus === 'open') {
                        setStatus(prev => ({ ...prev, [statusKey]: (prev[statusKey] === 'open' ? 'neutral' : 'open') }));
                        return;
                    }
                };

                const isOpen = status === 'open'; const isClosed = status === 'closed'; let statusClass = 'border-slate-300'; if (isOpen) statusClass = 'border-red-500 ring-4 ring-red-100/50'; else if (isClosed) statusClass = 'border-green-500 ring-4 ring-green-100/50'; const containerClasses = `offer-canvas-container ${statusClass} flex flex-col min-h-[420px] md:min-h-[600px]`; const getOfferTextClasses = () => { let classes = "absolute inset-0 w-full h-full p-4 bg-transparent resize-none focus:ring-0 focus:outline-none z-20 leading-relaxed "; if (textSize === 'small') classes += "text-base "; else if (textSize === 'medium') classes += "text-lg "; else if (textSize === 'large') classes += "text-xl "; if (textStyle.bold) classes += "font-black "; else classes += "font-medium "; if (textStyle.italic) classes += "italic "; classes += inputMode === 'pen' ? 'pointer-events-none text-slate-800' : 'pointer-events-auto text-slate-800'; return classes; }; useEffect(() => { const canvas = canvasRef.current; if (!canvas || !drawnStrokes) return; const rect = canvas.getBoundingClientRect(); const currentWidth = rect.width; let baseWidth = scaleRef.current.baseWidth; if (baseWidth === 0) { scaleRef.current.baseWidth = currentWidth; baseWidth = currentWidth; } const scaleFactor = currentWidth / baseWidth; redrawCanvas(canvas, drawnStrokes, scaleFactor, statusKey); if (Math.abs(currentWidth - baseWidth) > SIZE_DIFFERENCE_THRESHOLD) { scaleRef.current.baseWidth = currentWidth; } }, [canvasRef, drawnStrokes, triggerRedraw]); useEffect(() => { const canvas = canvasRef.current; if (canvas && scaleRef.current.baseWidth === 0) { const rect = canvas.getBoundingClientRect(); scaleRef.current.baseWidth = rect.width; } }, [canvasRef]); const isPenMode = inputMode === 'pen'; const { x, y, scale, rotation } = imageTransform; const [overlayEditEnabled, setOverlayEditEnabled] = useState(false);
                useEffect(() => { try { setOverlayEditEnabled(false); } catch(_) {} }, [image, htmlOverlay]);

        // Sobald ein neues Bundle/Bild eingefügt wurde: Edit-Modus wieder deaktivieren, damit Zeichnen sofort funktioniert.
        useEffect(() => { try { setOverlayEditEnabled(false); } catch(_) {} }, [image, htmlOverlay]);
        useEffect(() => { try { setOverlayEditEnabled(false); } catch(_) {} }, [image, htmlOverlay]);
        useEffect(() => { try { setOverlayEditEnabled(false); } catch(_) {} }, [image, htmlOverlay]);
        const [overlayMode, setOverlayMode] = useState(null);
        const interactionStateRef = useRef({ isDragging: false, isScaling: false, startX: 0, startY: 0, initialX: 0, initialY: 0, initialScale: 1.0, initialDistance: 0, initialRotation: 0, initialAngle: 0, mode: null });
        const pointerCacheRef = useRef({}); 
        const getClientCoords = (e) => { const clientX = e.clientX ?? e.touches?.[0]?.clientX; const clientY = e.clientY ?? e.touches?.[0]?.clientY; if (clientX === undefined || clientY === undefined) return null; return { clientX, clientY }; }; 
        const longPressTimerRef = useRef(null);
        const longPressMetaRef = useRef({ active: false, x: 0, y: 0, pointerId: null });

        const hardEndInteraction = useCallback(() => {
            try { if (longPressTimerRef.current) { clearTimeout(longPressTimerRef.current); longPressTimerRef.current = null; } } catch(_) {}
            longPressMetaRef.current = { active: false, x: 0, y: 0, pointerId: null };
            pointerCacheRef.current = {};
            interactionStateRef.current = { isDragging: false, isScaling: false, startX: 0, startY: 0, initialX: 0, initialY: 0, initialScale: scale, initialDistance: 0, initialRotation: rotation, initialAngle: 0, mode: null };
            try { setOverlayMode(null); } catch(_) {}
        }, [scale, rotation, setOverlayMode]);

        // Wichtig: Falls der Pointer außerhalb losgelassen wird (Mouse/Touch), damit das "Festhängen" nie passiert.
        useEffect(() => {
            const onUp = () => { if (interactionStateRef.current.mode) hardEndInteraction(); };
            window.addEventListener('pointerup', onUp, true);
            window.addEventListener('pointercancel', onUp, true);
            window.addEventListener('blur', onUp, true);
            return () => {
                window.removeEventListener('pointerup', onUp, true);
                window.removeEventListener('pointercancel', onUp, true);
                window.removeEventListener('blur', onUp, true);
            };
        }, [hardEndInteraction]);

        const handleInteractionStart = useCallback((e) => {
            if (!hasOverlay) return;
            // Rechtsklick-Menü nicht blockieren (dafür gibt es onContextMenu)
            e.preventDefault();
            e.stopPropagation();

            const { clientX, clientY } = getClientCoords(e);
            if (clientX === undefined || clientY === undefined) return;

            // Pointer registrieren
            pointerCacheRef.current[e.pointerId] = { x: clientX, y: clientY };

            // Pointer Capture (stabiler Drag)
            try { e.currentTarget?.setPointerCapture?.(e.pointerId); } catch(_) {}

            // Nur wenn der User explizit den Bearbeiten/Move-Modus aktiviert hat.
            if (!overlayEditEnabled) return;

            const pointerIds = Object.keys(pointerCacheRef.current);
            if (pointerIds.length >= 2) {
                const [id1, id2] = pointerIds;
                const p1 = pointerCacheRef.current[id1];
                const p2 = pointerCacheRef.current[id2];
                const initialDistance = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                const initialAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                interactionStateRef.current = { isDragging: false, isScaling: true, initialDistance, initialScale: scale, initialRotation: rotation, initialAngle, mode: 'scale' };
                try { setOverlayMode('scale'); } catch(_) {}
                try { setOverlayMode('scale'); } catch(_) {}
            } else {
                // 1 Pointer -> Drag
                interactionStateRef.current = {
                    isDragging: true,
                    isScaling: false,
                    startX: clientX,
                    startY: clientY,
                    initialX: x,
                    initialY: y,
                    initialScale: scale,
                    initialRotation: rotation,
                    initialDistance: 0,
                    initialAngle: 0,
                    mode: 'drag'
                };
                try { setOverlayMode('drag'); } catch(_) {}
            }
        }, [hasOverlay, overlayEditEnabled, x, y, scale, rotation]);

        const handleInteractionMove = useCallback((e) => {
            if (!hasOverlay) return;
            const { clientX, clientY } = getClientCoords(e);
            if (clientX === undefined || clientY === undefined) return;

            // Long-press abbrechen wenn man zu früh "rutscht"
            if (longPressMetaRef.current.active && longPressMetaRef.current.pointerId === e.pointerId) {
                const dx0 = clientX - longPressMetaRef.current.x;
                const dy0 = clientY - longPressMetaRef.current.y;
                if (Math.hypot(dx0, dy0) > 8) {
                    longPressMetaRef.current.active = false;
                    try { if (longPressTimerRef.current) { clearTimeout(longPressTimerRef.current); longPressTimerRef.current = null; } } catch(_) {}
                }
            }

            pointerCacheRef.current[e.pointerId] = { x: clientX, y: clientY };
            const pointerIds = Object.keys(pointerCacheRef.current);
            const mode = interactionStateRef.current.mode;

            if (pointerIds.length === 1 && mode === 'drag') {
                e.preventDefault();
                e.stopPropagation();
                const { startX, startY, initialX, initialY } = interactionStateRef.current;
                const dx = clientX - startX;
                const dy = clientY - startY;
                onUpdateImageTransform(statusKey, { x: initialX + dx, y: initialY + dy });
            } else if (pointerIds.length >= 2 && mode === 'scale') {
                e.preventDefault();
                e.stopPropagation();
                const { initialDistance, initialScale, initialRotation, initialAngle } = interactionStateRef.current;
                const relevantIds = Object.keys(pointerCacheRef.current).slice(0, 2);
                const p1 = pointerCacheRef.current[relevantIds[0]];
                const p2 = pointerCacheRef.current[relevantIds[1]];
                if (!p1 || !p2) return;
                const currentDistance = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                const ratio = currentDistance / initialDistance;
                let newScale = initialScale * ratio;
                newScale = Math.min(2.5, Math.max(0.25, newScale));
                newScale = Math.round(newScale * 100) / 100;
                const currentAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                const angleDelta = currentAngle - initialAngle;
                const rotationDeltaDeg = angleDelta * (180 / Math.PI);
                let newRotation = (initialRotation + rotationDeltaDeg);
                newRotation = Math.round(newRotation * 10) / 10;
                if (newScale !== scale || newRotation !== rotation) {
                    onUpdateImageTransform(statusKey, { scale: newScale, rotation: newRotation });
                }
            }
        }, [hasOverlay, onUpdateImageTransform, statusKey, scale, rotation]);

        const handleInteractionEnd = useCallback((e) => {
            // Long press cleanup
            if (longPressMetaRef.current.pointerId === e.pointerId) {
                longPressMetaRef.current.active = false;
                try { if (longPressTimerRef.current) { clearTimeout(longPressTimerRef.current); longPressTimerRef.current = null; } } catch(_) {}
            }

            try { e.currentTarget?.releasePointerCapture?.(e.pointerId); } catch(_) {}
            delete pointerCacheRef.current[e.pointerId];

            const pointerIds = Object.keys(pointerCacheRef.current);
            if (pointerIds.length === 0) {
                interactionStateRef.current.mode = null;
                try { setOverlayMode(null); } catch(_) {}
                interactionStateRef.current.isDragging = false;
                interactionStateRef.current.isScaling = false;
                try { setOverlayMode(null); } catch(_) {}
            } else if (pointerIds.length === 1) {
                const remainingId = pointerIds[0];
                const p = pointerCacheRef.current[remainingId];
                interactionStateRef.current = { isDragging: true, isScaling: false, startX: p.x, startY: p.y, initialX: x, initialY: y, initialScale: scale, initialRotation: rotation, initialDistance: 0, initialAngle: 0, mode: 'drag' };
                try { setOverlayMode('drag'); } catch(_) {}
            } else if (pointerIds.length >= 2) {
                const relevantIds = pointerIds.slice(0, 2);
                const p1 = pointerCacheRef.current[relevantIds[0]];
                const p2 = pointerCacheRef.current[relevantIds[1]];
                const currentDistance = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                const currentAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                interactionStateRef.current = { isDragging: false, isScaling: true, initialDistance: currentDistance, initialScale: scale, initialRotation: rotation, initialAngle: currentAngle, mode: 'scale' };
                try { setOverlayMode('scale'); } catch(_) {}
            }

            // Wichtig: Nicht immer preventDefault erzwingen, sonst "klebt" Mouse manchmal im Browser.
            if (interactionStateRef.current.mode) {
                e.preventDefault();
                e.stopPropagation();
            }
        }, [x, y, scale, rotation]);

        const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
        const bumpScale = (delta) => {
            const next = Math.round(clamp((scale || 1) + delta, 0.25, 2.5) * 100) / 100;
            onUpdateImageTransform(statusKey, { scale: next });
        };
        const bumpRotation = (deltaDeg) => {
            const next = Math.round(((rotation || 0) + deltaDeg) * 10) / 10;
            onUpdateImageTransform(statusKey, { rotation: next });
        };
        const toggleOverlayEdit = () => {
            setOverlayEditEnabled(v => !v);
            // Mode reset, damit nichts "klebt"
            try { hardEndInteraction(); } catch(_) {}
        };
        const handleImageReset = () => { onUpdateImageTransform(statusKey, { x: 0, y: 0, scale: 0.8, rotation: 0 }); }; 
        return (<div className={containerClasses} style={{transition: 'all 0.25s ease'}}> <div className="p-4 bg-white/90 border-b border-slate-100 relative z-10 shrink-0 flex flex-col"><div className="flex justify-between items-start"><div className="flex items-center gap-3 text-lg font-bold text-slate-800"><Icon d={icon} size={20} className="text-blue-600"/><span>{label}</span></div><div className="flex items-center gap-2">{(statusKey === 'offer1' || statusKey === 'offer2' || statusKey === 'offer3') && typeof onOpenBundleModal === 'function' ? (<button type="button" onClick={(e) => { e.preventDefault(); e.stopPropagation(); onOpenBundleModal('customer', statusKey); }} className="p-1.5 rounded-full bg-slate-50 text-slate-400 hover:text-blue-600 hover:bg-blue-50 transition-colors" title="Bundle öffnen"><Icon d={ICONS.Smartphone} size={16}/></button>) : null}{hasOverlay && (x !== 0 || y !== 0 || scale !== 1.0 || rotation !== 0) && (<button onClick={(e)=>{ e.preventDefault(); e.stopPropagation(); handleImageReset(); }} className="p-1.5 rounded-full bg-slate-50 text-blue-600 hover:bg-blue-100 transition-colors" title="Position/Skalierung/Rotation zurücksetzen"><Icon d={ICONS.RefreshCw} size={14}/></button>)}
        {hasOverlay && (statusKey === 'offer1' || statusKey === 'offer2' || statusKey === 'offer3') && (
            <>
                <button type="button" onClick={(e)=>{ e.preventDefault(); e.stopPropagation(); toggleOverlayEdit(); }} className={`p-1.5 rounded-full transition-colors ${overlayEditEnabled ? 'bg-blue-600 text-white hover:bg-blue-700' : 'bg-slate-50 text-slate-400 hover:text-blue-600 hover:bg-blue-50'}`} title={overlayEditEnabled ? 'Bearbeiten aktiv: Angebot kann bewegt/skaliert werden (Zeichnen ist dann gesperrt). Klick zum Sperren.' : 'Bearbeiten aus: Zeichnen ist frei. Klick um Angebot zu bewegen/skaliert zu bearbeiten.'}><Icon d={ICONS.Lock} size={16}/></button>
                <button type="button" onClick={(e)=>{ e.preventDefault(); e.stopPropagation(); setOverlayEditEnabled(true); bumpScale(-0.1); }} className="p-1.5 rounded-full bg-slate-50 text-slate-400 hover:text-blue-600 hover:bg-blue-50 transition-colors" title="Verkleinern"><Icon d={ICONS.ZoomOut} size={16}/></button>
                <button type="button" onClick={(e)=>{ e.preventDefault(); e.stopPropagation(); setOverlayEditEnabled(true); bumpScale(0.1); }} className="p-1.5 rounded-full bg-slate-50 text-slate-400 hover:text-blue-600 hover:bg-blue-50 transition-colors" title="Vergrößern"><Icon d={ICONS.ZoomIn} size={16}/></button>
                <button type="button" onClick={(e)=>{ e.preventDefault(); e.stopPropagation(); setOverlayEditEnabled(true); bumpRotation(-5); }} className="p-1.5 rounded-full bg-slate-50 text-slate-400 hover:text-blue-600 hover:bg-blue-50 transition-colors" title="Drehen"><Icon d={ICONS.RotateCcw} size={16}/></button>
                <button type="button" onClick={(e)=>{ e.preventDefault(); e.stopPropagation(); (onClearOverlay||onClearImage)?.(statusKey); setOverlayEditEnabled(false); }} className="p-1.5 rounded-full bg-red-50 text-red-600 hover:bg-red-100 transition-colors" title="Inhalt entfernen"><Icon d={ICONS.Trash} size={16}/></button>
            </>
        )}
        {hasOverlay && !(statusKey === 'offer1' || statusKey === 'offer2' || statusKey === 'offer3') && (<button onClick={(onClearOverlay||onClearImage)} className="p-1.5 rounded-full bg-red-50 text-red-600 hover:bg-red-100 transition-colors" title="Inhalt entfernen"><Icon d={ICONS.Trash} size={14}/></button>)}</div></div><div className="flex items-center gap-2 mt-2"><span className="text-[10px] font-medium text-slate-500 mr-1 uppercase">Status:</span><button data-print-keep="1" onClick={() => toggleStatus('open')} className={`px-2 py-0.5 rounded-full text-[10px] font-bold transition-all flex items-center gap-1 border ${isOpen ? 'bg-red-500 text-white shadow-lg shadow-red-200/50' : 'text-slate-500 bg-red-50 border-red-200 hover:bg-red-100'}`}>{isOpen ? <Icon d={ICONS.AlertCircle} size={10}/> : null} Offen</button><button data-print-keep="1" onClick={() => toggleStatus('closed')} className={`px-2 py-0.5 rounded-full text-[10px] font-bold transition-all flex items-center gap-1 border ${isClosed ? 'bg-green-500 text-white shadow-lg shadow-green-200/50' : 'text-slate-500 bg-green-50 border-green-200 hover:bg-green-100'}`}>{isClosed ? <Icon d={ICONS.CheckCircle} size={10}/> : null} Abgeschlossen</button></div>
                    {followUpInfo && (followUpInfo.date || followUpInfo.time || followUpInfo.reason) ? (
                        <div className={`mt-3 mb-2 p-3 rounded-xl text-sm relative z-20 ${
                            status === 'open'
                                ? 'bg-red-50 border border-red-200'
                                : status === 'closed'
                                    ? 'bg-green-50 border border-green-200'
                                    : 'bg-slate-50 border border-slate-200'
                        }`}>
                            <div className={`font-black ${
                                status === 'open' ? 'text-red-700' : status === 'closed' ? 'text-green-700' : 'text-slate-700'
                            }`}>Folgetermin</div>
                            <div className={`${status === 'open' ? 'text-red-900' : status === 'closed' ? 'text-green-900' : 'text-slate-800'} mt-1`}>
                                <span className="font-bold">{followUpInfo.date || ""}</span>{followUpInfo.time ? <> • <span className="font-bold">{followUpInfo.time}</span></> : null}
                            </div>
                            {followUpInfo.reason ? (
                                <div className={`${status === 'open' ? 'text-red-900' : status === 'closed' ? 'text-green-900' : 'text-slate-800'} mt-1`}>
                                    <span className="font-bold">Grund:</span> {followUpInfo.reason}
                                </div>
                            ) : null}
                        </div>
                    ) : null}

</div>{hasOverlay && !(statusKey === 'offer1' || statusKey === 'offer2' || statusKey === 'offer3') && (<button type="button" onClick={(e) => { e.stopPropagation(); (onClearOverlay||onClearImage)?.(); }} className="absolute top-2 right-2 z-50 w-7 h-7 rounded-full bg-red-600/90 text-white flex items-center justify-center shadow-md hover:bg-red-700" title="Entfernen">✕</button>)}<div className="canvas-lines"></div>{hasOverlay && (<div className="absolute inset-0 z-40" onPointerDown={handleInteractionStart} onPointerMove={handleInteractionMove} onPointerUp={handleInteractionEnd} onPointerCancel={handleInteractionEnd} onPointerLeave={handleInteractionEnd} onContextMenu={(e)=>{ e.preventDefault(); e.stopPropagation(); (onClearOverlay||onClearImage)?.(); }} style={{ transform: `translate(${x}px, ${y}px)`, transition: 'none', cursor: (!overlayEditEnabled ? 'default' : (overlayMode === 'drag' ? 'grabbing' : (overlayMode === 'scale' ? 'crosshair' : 'grab'))), pointerEvents: overlayEditEnabled ? 'auto' : 'none', touchAction: overlayEditEnabled ? 'none' : 'auto' }}>{htmlOverlay ? (<div style={{ width: '100%', maxWidth: '920px', margin: '0 auto', boxSizing: 'border-box', padding: '0 10px', transform: `scale(${scale}) rotate(${rotation}deg)`, transformOrigin: 'top left', pointerEvents: 'none', userSelect: 'none' }} dangerouslySetInnerHTML={{ __html: htmlOverlay }} />) : (<img src={image} alt={`Eingefügtes Bild für ${label}`} className="canvas-image" style={{ transform: `scale(${scale}) rotate(${rotation}deg)`, transition: 'none', pointerEvents: 'none', opacity: 1 }}/>)}</div>)}<div className="relative flex-1 w-full h-full min-h-[100px] overflow-hidden"><textarea value={textValue || ''} onChange={(e) => handleTextChange(statusKey, e.target.value)} className={getOfferTextClasses()} placeholder={inputMode === 'keyboard' ? 'Details digital eingeben...' : ''} readOnly={inputMode === 'pen'} /><canvas ref={canvasRef} onPointerDown={(e) => startDrawing(e, canvasRef, statusKey)} onPointerMove={(e) => draw(e, canvasRef, statusKey)} onPointerUp={(e) => stopDrawing(e, canvasRef)} onPointerLeave={(e) => stopDrawing(e, canvasRef)} className="w-full h-full drawing-canvas absolute inset-0" style={{pointerEvents: inputMode === 'pen' ? 'auto' : 'none', touchAction: 'none'}}/></div></div>); });
        
        // --- SMALL INPUT CANVAS (Patched with drawing-canvas class) ---
        
        // --- SMALL INPUT CANVAS (shows background value even in Pen mode) ---
        const SmallInputCanvas = ({
            inputMode, canvasRef, inputKey,
            inputValue = '', inputType = 'text', onChange, placeholder,
            drawnStrokes, setDrawnStrokes, readOnly = false,
            startDrawing, draw, stopDrawing, triggerRedraw
        }) => {
            const isPen = inputMode === 'pen';

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                if (isPen) {
                    redrawCanvas(canvas, drawnStrokes[inputKey], 1, inputKey);
                }
            }, [isPen, drawnStrokes, inputKey, triggerRedraw]);

            const clearSmallCanvas = () => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const dpr = window.devicePixelRatio || 1;
                ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
                setDrawnStrokes(prev => ({ ...prev, [inputKey]: [] }));
            };

            return (
                <div className="small-canvas-wrapper h-full relative flex items-center border-none">
                    {/* Background value (so initials like "E.I" are visible even when Pen overlay is active) */}
                    {isPen && (
                        <div
                            className="absolute inset-0 flex items-center pl-2 pr-8 text-[15px] font-semibold text-slate-700 select-none"
                            style={{ pointerEvents: 'none', opacity: 0.9 }}
                        >
                            {String(inputValue || '').trim()}
                        </div>
                    )}

                    {isPen ? (
                        <>
                            <canvas
                                ref={canvasRef}
                                onPointerDown={(e) => startDrawing(e, canvasRef, inputKey)}
                                onPointerMove={(e) => draw(e, canvasRef, inputKey)}
                                onPointerUp={(e) => stopDrawing(e, canvasRef)}
                                onPointerLeave={(e) => stopDrawing(e, canvasRef)}
                                className="absolute inset-0 w-full h-full cursor-crosshair z-10 drawing-canvas"
                                style={{ pointerEvents: 'auto', touchAction: 'none' }}
                            />
                            {drawnStrokes[inputKey]?.length > 0 && (
                                <button
                                    onClick={clearSmallCanvas}
                                    className="absolute top-1/2 right-2 -translate-y-1/2 p-0.5 hover:bg-slate-100 rounded text-slate-400 z-20"
                                    title="Löschen"
                                >
                                    <Icon d={ICONS.Trash} size={14}/>
                                </button>
                            )}
                        </>
                    ) : (
                        <input
                            type={inputType}
                            value={inputValue}
                            onChange={onChange}
                            readOnly={readOnly}
                            placeholder={placeholder}
                            className="w-full h-full p-2 text-sm font-medium text-slate-700 bg-transparent focus:ring-1 focus:ring-blue-300 transition-colors focus:outline-none"
                            style={{ fontSize: '15px', paddingLeft: '8px' }}
                        />
                    )}
                </div>
            );
        };


        // --- MAIN APP ---
        
        const OfferValidityModal = ({ isOpen, value, onValueChange, onCancel, onConfirm }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-[60] flex items-center justify-center bg-slate-900/60 backdrop-blur-sm p-4 animate-in fade-in">
                    <div className="bg-white w-full max-w-xl rounded-2xl shadow-2xl border border-slate-200 overflow-hidden">
                        <div className="p-5 border-b border-slate-200 bg-slate-50 flex items-center justify-between">
                            <div className="flex items-center gap-3">
                                <div className="w-10 h-10 rounded-xl bg-blue-600 flex items-center justify-center text-white font-black">i</div>
                                <div>
                                    <div className="text-sm font-black text-slate-900">Angebotsgültigkeit</div>
                                    <div className="text-xs text-slate-600">Bitte Enddatum eingeben, bevor gedruckt wird.</div>
                                </div>
                            </div>
                        </div>

                        <div className="p-6 space-y-3">
                            <div className="text-sm font-bold text-slate-700">Bis wann ist dieses Angebot gültig?</div>
                            <input
                                type="date"
                                value={value || ''}
                                onChange={(e) => onValueChange(e.target.value)}
                                className="w-full h-12 px-4 rounded-xl border border-slate-300 bg-white text-slate-900 font-bold focus:outline-none focus:ring-2 focus:ring-blue-300"
                            />
                            <div className="text-xs text-slate-500">Tipp: Standard sind oft 14 Tage – bitte nach interner Vorgabe wählen.</div>
                        </div>

                        <div className="p-5 border-t border-slate-200 bg-white flex items-center justify-end gap-3">
                            <button onClick={onCancel} className="px-4 py-2 rounded-xl border border-slate-200 text-slate-700 font-bold hover:bg-slate-50">Abbrechen</button>
                            <button onClick={onConfirm} className="px-5 py-2 rounded-xl bg-blue-600 text-white font-black hover:bg-blue-500">
                                Speichern & Drucken
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

function App() {
            const [view, setView] = useState('situation');
            
            const [showSecondYear, setShowSecondYear] = useState(false);

            // PATCH (Stylus Year-2 Costs): When the 2nd-year cost field becomes visible, force a DPR-correct resize
            // to prevent "jump lines" caused by a 0x0 canvas being drawn before layout settles.
            useEffect(() => {
                if (!showSecondYear) return;
                const raf = requestAnimationFrame(() => {
                    const canvas = offerCost3Ref?.current;
                    if (!canvas) return;
                    const rect = canvas.getBoundingClientRect();
                    if (!rect.width || !rect.height) return;
                    const dpr = window.devicePixelRatio || 1;
                    canvas.width = Math.round(rect.width * dpr);
                    canvas.height = Math.round(rect.height * dpr);
                    const ctx = canvas.getContext('2d');
                    if (!ctx) return;
                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                    // Redraw existing strokes if any
                    try { redrawCanvas(canvas, drawnStrokes['cost_monatlich2'], 1, 'cost_monatlich2'); } catch (e) {}
                });
                return () => cancelAnimationFrame(raf);
            }, [showSecondYear, drawnStrokes]);
 
            const [activeCategory, setActiveCategory] = useState(null); 
            const [questionIndex, setQuestionIndex] = useState(0); 
            const [questionsData, setQuestionsData] = useState(INITIAL_QUESTIONS_DATA);
            
            const ua = (navigator.userAgent || '');
            const isProbablyAndroid = /Android/i.test(ua) || /; Android /i.test(ua);
            const canNativeShare = !!(navigator.share && window.isSecureContext);
            // --- OneDrive Auto-Upload (Power Automate HTTP Gateway) ---
            // Schritt 1: In Power Automate Flow-URL eintragen (When an HTTP request is received)
            // Schritt 2: Optionales Shared Secret (im Flow prüfen)
            const PA_UPLOAD_URL = 'PASTE_POWER_AUTOMATE_FLOW_URL_HERE';
            const PA_SHARED_KEY = ''; // optional: z.B. 'hetec-xyz-123'

            // NOTE: Tablet-Browser im "Desktopmodus" kann 'Android' aus dem User-Agent entfernen.
            // Daher UI nicht nur nach UA, sondern nach echter WebShare-Fähigkeit anzeigen.
            const showShareButton = canNativeShare;
            // Drawing State
            const [tool, setTool] = useState('pen');
            const [showPenToolPicker, setShowPenToolPicker] = useState(false);
            const lastPenTapRef = useRef(0);
            const [color, setColor] = useState('#0044ff'); 
            const [strokeWidth, setStrokeWidth] = useState(4); 
            const [opacity, setOpacity] = useState(0.85); 
            const [gestureMode, setGestureMode] = useState(false); // 🔍 Zoom/Pan-Lock für Touch (2-Finger Gesten im Canvas)
            
            const [drawnStrokes, setDrawnStrokes] = useState({ 
                // Legacy (früher: ein großes Overlay-Canvas über allen Zeilen)
                main: [],

                // Kleine Input-Canvas
                email: [], provider: [], notes: [], skip_reason: [],

                // Situation: EIN Canvas pro Zeile (stabil im Druck)
                sit_Kundenname: [], sit_Rufnummer: [], sit_Anbieter: [], sit_Hardware: [],
                sit_Nutzung: [], sit_Haushalt: [], sit_WeitereProdukte: [], sit_Fernsehen: [],
                sit_WiFi: [], sit_Gesamtkosten: [],

                // Angebot / Kosten
                offer1: [], offer2: [], offer3: [],
                cost_einmalig: [], cost_monatlich1: [], cost_monatlich2: [], agent_name: [], date_field: [], offer_valid_until: []
            });

            const isDrawingRef = useRef(false);
            const currentStrokeRef = useRef(null); 
            
                        const gestureModeRef = useRef(false);
const toolRef = useRef('pen');
            const strokeWidthRef = useRef(4);
            const opacityRef = useRef(0.85);
            const colorRef = useRef('#0044ff'); 

            // --- Tool helpers (Pen / Fountain / Ballpen) ---
            const resolveToolForPointer = (selectedTool, pointerType) => {
                // Finger-Eingabe soll "schöner" schreiben -> Füller als Fallback
                if (pointerType === 'touch') {
                    if (selectedTool === 'pen') return 'fountain';
                }
                return selectedTool;
            };

            const getToolTuning = (toolId, baseWidth, baseOpacity) => {
                // WICHTIG: width muss in diesem Projekt in den "diskreten" Stufen bleiben,
                // sonst wirkt der Strich nach dem Absetzen dicker (Redraw-Mapping 2/4/8).
                const quantize = (w) => {
                    const steps = [2, 4, 8];
                    let best = steps[0], bestD = Math.abs(w - steps[0]);
                    for (let i = 1; i < steps.length; i++) {
                        const d = Math.abs(w - steps[i]);
                        if (d < bestD) { bestD = d; best = steps[i]; }
                    }
                    return best;
                };
                const bw = quantize(baseWidth);

                // Tool-Charakter: klar sichtbar unterschiedlich
                // - Pen: Standard (mittlere Deckkraft)
                // - Fountain: kräftiger + eine Stufe breiter
                // - Ballpen: dünner + "leichter" (mehr Transparenz)
                if (toolId === 'fountain') {
                    const up = (bw === 2) ? 4 : (bw === 4) ? 8 : 8;
                    return {
                        width: up,
                        opacity: 1,
                        smooth: 1
                    };
                }
                if (toolId === 'ballpen') {
                    const down = (bw === 8) ? 4 : 2;
                    return {
                        width: down,
                        opacity: Math.max(0.55, Math.min(0.75, baseOpacity)),
                        smooth: 0.25
                    };
                }
                return { width: bw, opacity: Math.min(1, baseOpacity), smooth: 0 };
            };

            const digitalTouchedRef = useRef({}); // merkt: Feld wurde per Tastatur genutzt


            // Sync GestureMode-Ref (für Callbacks) + Canvas-TouchAction sofort anpassen
            useEffect(() => {
                gestureModeRef.current = !!gestureMode;
                // Alle Zeichnen-Canvases updaten (auch Small-Input/Offer/Situation)
                try {
                    document.querySelectorAll('canvas.drawing-canvas').forEach((c) => {
                        const st = getCanvasPointerState(c);
                        updateCanvasTouchAction(c, st.count || 0);
                    });
                } catch(_) {}
            }, [gestureMode]);
            
            const scaleRef1 = useRef({ baseWidth: 0, scaleFactor: 1 });
            const scaleRef2 = useRef({ baseWidth: 0, scaleFactor: 1 });
            const scaleRef3 = useRef({ baseWidth: 0, scaleFactor: 1 });
            const [redrawCounter, setRedrawCounter] = useState(0);
            // ✅ Auto-Redraw + Smart-Shift bei Drehen/Resize/Vollbild (damit nichts rechts abgeschnitten wird)
            useEffect(() => {
                const setShift = (px) => {
                    try { document.documentElement.style.setProperty('--PORTRAIT_SHIFT_PX', `${px}px`); } catch(_) {}
                };

                const applyPortraitShift = () => {
                    // Nur im Hochformat relevant
                    if (!(window.matchMedia && window.matchMedia('(orientation: portrait)').matches)) {
                        setShift(0);
                        return;
                    }

                    // Erst Shift resetten, dann echte Geometrie messen
                    setShift(0);

                    requestAnimationFrame(() => {
                        try {
                            const pad = 8; // Sicherheitsabstand links/rechts
                            const vv = window.visualViewport;
                            const vw = Math.max(1, Math.round((vv && vv.width) || window.innerWidth || document.documentElement.clientWidth || 0));

                            // Versuche ein sichtbares Haupt-Layout zu messen (stabiler als scrollWidth im Vollbild)
                            const el =
                                document.querySelector('.situation-view-wrapper') ||
                                document.querySelector('.print-offer-view') ||
                                document.querySelector('.print-situation-view');

                            if (!el) {
                                setShift(0);
                                return;
                            }

                            const r = el.getBoundingClientRect();

                            // Shift-Spanne, die "passt": links >= pad und rechts <= vw - pad
                            const minShift = (vw - pad) - r.right; // (negativ => nach links)
                            const maxShift = pad - r.left;         // (positiv => nach rechts)

                            let shift = 0;

                            if (minShift <= maxShift) {
                                // Wähle den Shift, der 0 am nächsten ist, aber innerhalb der Spanne liegt
                                if (shift < minShift) shift = minShift;
                                if (shift > maxShift) shift = maxShift;
                            } else {
                                // Inhalt ist breiter als viewport: priorisiere, dass links nichts abgeschnitten wird
                                shift = maxShift;
                            }

                            // Runden + Limit gegen "zu viel"
                            shift = Math.round(shift);
                            shift = Math.max(Math.min(shift, 120), -120);

                            // Nur setzen, wenn wirklich nötig (verhindert unnötiges Springen)
                            if (Math.abs(shift) <= 1) shift = 0;

                            setShift(shift);
                        } catch (_) {
                            setShift(0);
                        }
                    });
                };
                const handle = () => {
                    // doppelt rAF: erst Layout settle, dann Shift + Redraw
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            applyPortraitShift();
                            setRedrawCounter(r => r + 1);
                        });
                    });
                };

                // initial
                handle();

                window.addEventListener('resize', handle);
                window.addEventListener('orientationchange', handle);
                document.addEventListener('fullscreenchange', handle);

                // Mobile: visualViewport kann bei Vollbild/Browser-UI ändern ohne klassisches resize
                const vv = window.visualViewport;
                if (vv && vv.addEventListener) vv.addEventListener('resize', handle);

                return () => {
                    window.removeEventListener('resize', handle);
                    window.removeEventListener('orientationchange', handle);
                    document.removeEventListener('fullscreenchange', handle);
                    if (vv && vv.removeEventListener) vv.removeEventListener('resize', handle);
                };
            }, []);
 
            const hasMigratedSituationRef = useRef(false);
            
            useEffect(() => { toolRef.current = tool; }, [tool]);
            useEffect(() => { colorRef.current = color; }, [color]);
            useEffect(() => { strokeWidthRef.current = strokeWidth; }, [strokeWidth]);
            useEffect(() => { opacityRef.current = opacity; }, [opacity]);

            const [isWritingEnabled, setIsWritingEnabled] = useState(true); 
            const [inputMode, setInputMode] = useState('pen'); 
            const [showColorPicker, setShowColorPicker] = useState(false);
            const [showAdmin, setShowAdmin] = useState(false);
            const [showStats, setShowStats] = useState(false);

            
// ===== Bundle IFrame (extern) =====
const BUNDLE_URL = "https://jefferson990.github.io/Verkaufsmappe/"; // <-- hier deinen Bundle-Link eintragen
const [showBundleModal, setShowBundleModal] = useState(false);
const [bundleModalUrl, setBundleModalUrl] = useState(BUNDLE_URL);
const [bundleTargetKey, setBundleTargetKey] = useState('offer1');

const openBundleModal = useCallback((mode = 'customer', targetKey = 'offer1') => {
    setBundleTargetKey(targetKey);
    const url = (mode === 'admin') ? `${BUNDLE_URL}#admin` : BUNDLE_URL;
    setBundleModalUrl(url);
    setShowBundleModal(true);
}, [BUNDLE_URL]);

const handleOpenStats = () => {
                const pw = prompt('Statistik Passwort:');
                if (pw !== STATS_PASSWORD) { alert('Falsches Passwort'); return; }
                setShowStats(true);
            };
            const dprRef = useRef(window.devicePixelRatio || 1); 
            const [textSize, setTextSize] = useState('medium'); 
            const [textStyle, setTextStyle] = useState({ bold: false, italic: false });
            const [textData, setTextData] = useState({ 
                AgentName: '', 
                DateValue: '',
                OfferValidUntil: '', 
                offer1: '', 
                offer2: '', 
                offer3: '' 
            }); 
            const [emailText, setEmailText] = useState('');
            const [emailMode, setEmailMode] = useState('keyboard'); 
            const [notesMode, setNotesMode] = useState('keyboard');

            const [showWlanModal, setShowWlanModal] = useState(false);
            const [showSpeedModal, setShowSpeedModal] = useState(false);
            const [showTechModal, setShowTechModal] = useState(false);
            const [showRoamingModal, setShowRoamingModal] = useState(false);
            const [showSignatureModal, setShowSignatureModal] = useState(false);
            const [showFinishTypeModal, setShowFinishTypeModal] = useState(false); // NEW MODAL STATE
            
            const [showReferralModal, setShowReferralModal] = useState(false);
            const [showValidityModal, setShowValidityModal] = useState(false);
            const pendingPrintRef = useRef(null);
const [showSkipReasonModal, setShowSkipReasonModal] = useState(false); 
            const [skipReason, setSkipReason] = useState(''); 
            const [skipReasonMode, setSkipReasonMode] = useState('keyboard'); 
            const skipReasonCanvasRef = useRef(null); 
            const MIN_REASON_LENGTH = 5; 

            const [customerType, setCustomerType] = useState("");
            const [segment, setSegment] = useState("");
            const [segmentTouched, setSegmentTouched] = useState(false);
            const [providerSelect, setProviderSelect] = useState("");
            const [customProvider, setCustomProvider] = useState("");
            const [isCustomProvider, setIsCustomProvider] = useState(false); 
            const [providerMode, setProviderMode] = useState('keyboard');
            const [wlanRecommendation, setWlanRecommendation] = useState('');
            const [speedRecommendation, setSpeedRecommendation] = useState(''); 
            const techSituation = providerSelect === 'Sonstiges' ? customProvider : providerSelect;
            
            const [costState, setCostState] = useState({ mobile: '', landline: '', tv: '' });
            const parseCost = (val) => { if (!val) return 0; return parseFloat(val.replace(',', '.')) || 0; };
            const totalCost = parseCost(costState.mobile) + parseCost(costState.landline) + parseCost(costState.tv);
            
            const initialOfferData = { einmalig: 0, monatlich1: 0, monatlich2: 0, einmaligRaw: '', monatlich1Raw: '', monatlich2Raw: '' };
            const [offerData, setOfferData] = useState(initialOfferData);
            const [canvasStatus, setCanvasStatus] = useState({ offer1: 'neutral', offer2: 'neutral', offer3: 'neutral' });

            // === FOLLOW-UP (Folgetermin) Pflicht bei Status "Offen" ===
            const [followUpsByKey, setFollowUpsByKey] = useState({}); // { [statusKey]: {date,time,reason} }
            const [showFollowUpModal, setShowFollowUpModal] = useState(false);
            const [followUpKeys, setFollowUpKeys] = useState([]);
            const [followUpIndex, setFollowUpIndex] = useState(0);
            const [followUpDraft, setFollowUpDraft] = useState({ date: "", time: "", reason: "" });
            const [finishAfterFollowUp, setFinishAfterFollowUp] = useState(false);

            const startFollowUpFlow = (keys) => {
                setFollowUpKeys(keys);
                setFollowUpIndex(0);
                setFollowUpDraft({ date: "", time: "", reason: "" });
                setFinishAfterFollowUp(true);
                setShowFollowUpModal(true);
            };

            const saveCurrentFollowUp = () => {
                const reasonOk = (followUpDraft.reason || "").trim().length >= 3;
                if (!followUpDraft.date || !followUpDraft.time || !reasonOk) return;

                const key = followUpKeys[followUpIndex];
                if (!key) return;

                setFollowUpsByKey(prev => ({ ...prev, [key]: { ...followUpDraft } }));

                const nextIndex = followUpIndex + 1;
                if (nextIndex >= followUpKeys.length) {
                    setShowFollowUpModal(false);
                    setFollowUpKeys([]);
                    setFollowUpIndex(0);

                    // Continue finish flow
                    if (finishAfterFollowUp) {
                        setFinishAfterFollowUp(false);
                        backgroundAutoUpload({ type: 'abschluss', triggerToast, ensurePrintHeaders, getAgent: getAgentDisplayNameForUpload, getDsl: getDslFlagForUpload });
                        handlePrint();
                    }
                } else {
                    setFollowUpIndex(nextIndex);
                    setFollowUpDraft({ date: "", time: "", reason: "" });
                }
            };

            const cancelFollowUp = () => {
                setShowFollowUpModal(false);
                setFollowUpKeys([]);
                setFollowUpIndex(0);
                setFinishAfterFollowUp(false);
            };
            // isReadyToFinish wird weiter unten nach Inhalterkennung berechnet

            
            const [customerSignature, setCustomerSignature] = useState(null);
            const SHOP_STAMP_TEXT = "o2 Shop Crailsheim";
            const SHOP_STAMP_QR = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAIAAAABc2X6AAAEl0lEQVR4AeybUY7cOBBDvbn/nXef8wJ2bclyOzONILA8INgsiqXpkoT5CJAf/y7282Pbtn++9LMNP24T2xKOo8ARlmHNkROIGDMXHXbYB+ZjHbwGvv602+nkdPVTZsM4iplvO5yAwi6YpQpXr3Dteg1c3RvrZ+Bt+jdsm/zkUU3Wf9ljrDmt/NV24YPXfojD1ueGD4/lRuYHbjjPyTeZw4mv00pN2cYxoOMqbPib/IGBv/kN/nD7Bwbm7IVfXQ1bwugKnAZvMqYlrIMQlt/kDwz8zW/wh9ufgbetPr+qZ1fhewsnlt44TbSW5JtoXWPZ8inHJM5zwxzCnbG9bjgP7K2YHYhvKe2J6bQS0zycJQVLwnLGZq5w3eE1cHVvrPeBOeMvIIeSXg87viUcR5G85cgJ0AtOAkleFGy1D8zHOlhyYJ7NFeQVzMK+q8Qsw/HTHsfM6BtwFW6BVhLWQQhL2FJe8oYdfRHeb5jXAjIwuiJ+RF1Fx1fgCN6S0H/LdsF2wbYghCV8WGLSCwgItGBJ4O8D87EOzgbOqXgclmFN2FOEs6TAEZZhTTgOmxyCDMgS+hxJNpEu/LOBWb4flhzYp5V7t4TjHAoCDbPn0NrT9TZvMu3J64eb30picRBL3jBzr4P9hn0zmdkS5jGA+BGYgECDgZhkDmEMThINEkYLA+rK+uG6hM4+B4Gt/AMA0RWw37BHkmktYU8I0aCf/FvR8pZwGt0fRzTf1ZHHmO3hMYCzD8zHOlhyYN/A7JJdrezrGvNmXIUtYZMIYQmTEegKTdj8yIYJiAQsw8bgBNBL3jBzr4P9hn0DmTkPQH9kA6Ov4yqcDfVTRpCpiB9hYzh+EwnU3dDxa34fuNa31wsPnAcQ4W3zNhoMxDQG6yCEMbiVOA0t4D6wPkJYwoclZtsWR9ASLHzDOYMIjyfH9tY3MMu7CrttZVvikDmEsXAycdwhfkQCOM8Ncwi3xuuGfQ+VZ4P7QrKaljiKmW97ZZPVUTffEnb/MI6I04SrMP5rYIrbgwGfgTmE/4OXIHxmsGVSOELHVdgSdhVH4AhLuJU4Qv8tuz9s0l4YR+jLzw17Dj+5HQ9nJmb+z6Yp2QUngT5HkoqELWc8xqrz3PDs3O7i7zfsQx0nOvddhfNgFNnHEiZTkUDMOOci+SbSxe8CKQ/FPvDhwl3NJQfmGXwB4xPwpWUrS1gneRyhD2dJ4SrMEtCsjAmqc6jZoYHYkjfM3KAdxklJuCJJzZRcgtA/4bQoTpIuzWL6YcONF77hdhJ3LQ9u2Hc48uwIWjKxPC1FYgk0MQZsTCyBJhJQZNWy8cHALXGzcqmB97v75MC+wLyoiP33lP8sYwmbh00iBEsVmiMnkyX3iR+hD+N8cmC2+/vxyYE5QpCZc/BxmiAs9NXX2S44LeiK+PWbfHLg+sv+Wv0MXP665CUo3l5ai+VFKS62u0nlNFYTPfo6LAnLxs8NtwO5Xfm6YR/eFZ4dgr0+p8otbwyObxhHxLd0FW5+KwnrIAQtQl9+DWx9e15yYO/9dzlvoTXGjzDQSk3ZJTVsCaMBogHzClqX5X8AAAD//1oR/6MAAAAGSURBVAMANy00KRKTFV4AAAAASUVORK5CYII=";
 
            
            const [imageTransform, setImageTransform] = useState({ 
                offer1: { x: 0, y: 0, scale: 1.0, rotation: 0 }, 
                offer2: { x: 0, y: 0, scale: 1.0, rotation: 0 }, 
                offer3: { x: 0, y: 0, scale: 1.0, rotation: 0 } 
            });
            const handleUpdateImageTransform = useCallback((key, updates) => { setImageTransform(prev => ({ ...prev, [key]: { ...prev[key], ...updates } })); }, []);
            
            const canvasRef = useRef(null); 
            const emailCanvasRef = useRef(null);
            const providerCanvasRef = useRef(null); 
            const notesCanvasRef = useRef(null);
            const sitCanvasRef_Kundenname = useRef(null);
            const sitCanvasRef_Rufnummer = useRef(null);
            const sitCanvasRef_Anbieter = useRef(null);
            const sitCanvasRef_Hardware = useRef(null);
            const sitCanvasRef_Nutzung = useRef(null);
            const sitCanvasRef_Haushalt = useRef(null);
            const sitCanvasRef_WeitereProdukte = useRef(null);
            const sitCanvasRef_Fernsehen = useRef(null);
            const sitCanvasRef_WiFi = useRef(null);
            const sitCanvasRef_Gesamtkosten = useRef(null);
 
            const offerCanvasRef1 = useRef(null);
            const offerCanvasRef2 = useRef(null);
            const offerCanvasRef3 = useRef(null);
            const offerCost1Ref = useRef(null);
            const offerCost2Ref = useRef(null);
            const offerCost3Ref = useRef(null);
            const offerAgentRef = useRef(null);
            const offerDateRef = useRef(null);
            const offerValidUntilRef = useRef(null);
const fileInputRef = useRef(null); 

            const [displayLanguage, setDisplayLanguage] = useState('de');
            const [translatedText, setTranslatedText] = useState({});
            const [staticTranslations, setStaticTranslations] = useState({}); 
            const [showLanguageDropdown, setShowLanguageDropdown] = useState(false);
            const [oneDriveLink, setOneDriveLink] = useState('https://jefferson990.github.io/Verkaufsmappe/'); 
            const [isDrawing, setIsDrawing] = useState(false);
            const [toastMessage, setToastMessage] = useState(null); 
            const toastTimerRef = useRef(null);
            const [canvasImages, setCanvasImages] = useState({ offer1: null, offer2: null, offer3: null });
            const [canvasHtml, setCanvasHtml] = React.useState({ offer1: null, offer2: null, offer3: null });

            // Brücke für die OfferCanvas-Komponente (minimal-invasiv)
            React.useEffect(() => {
                window.__canvasHtmlOffer1 = canvasHtml.offer1 || null;
                window.__canvasHtmlOffer2 = canvasHtml.offer2 || null;
                window.__canvasHtmlOffer3 = canvasHtml.offer3 || null;
            }, [canvasHtml.offer1, canvasHtml.offer2, canvasHtml.offer3]);

            const [isImageSelectModalOpen, setIsImageSelectModalOpen] = useState(false);
            const [currentImagePayload, setCurrentImagePayload] = useState(null);
            
            const getDisplayText = useCallback((key) => { const defaultText = textData[key] || ''; if (displayLanguage === 'de') return defaultText; const translation = translatedText[displayLanguage]?.[key]; if (!translation && MOCK_TRANSLATIONS[displayLanguage]?.[key]) { return MOCK_TRANSLATIONS[displayLanguage][key]; } return translation || defaultText; }, [textData, translatedText, displayLanguage]);
            
            const getStaticLabel = useCallback((key) => { if (displayLanguage === 'de') return STATIC_LABELS[key] || key; return staticTranslations[displayLanguage]?.[key] || MOCK_TRANSLATIONS[displayLanguage]?.[key] || STATIC_LABELS[key] || key; }, [staticTranslations, displayLanguage]);

            const triggerToast = (message) => { clearTimeout(toastTimerRef.current); setToastMessage(message); toastTimerRef.current = setTimeout(() => setToastMessage(null), 3000); };


            // === Inhalterkennung Offer-Canvas (Status nur bei Inhalt erforderlich) ===
            // === Inhalterkennung Offer-Canvas (wichtig: auch nach Radieren korrekt) ===
            const getOfferCanvasElByKey = (k) => {
                try {
                    if (k === 'offer1') return offerCanvasRef1?.current || null;
                    if (k === 'offer2') return offerCanvasRef2?.current || null;
                    if (k === 'offer3') return offerCanvasRef3?.current || null;
                    return null;
                } catch(_) { return null; }
            };

            // Prüft echte Pixel auf dem Canvas (nicht nur "Strokes-Liste"),
            // damit "Fertigstellen" nach komplettem Radieren wieder möglich ist.
            const canvasHasVisibleInk = (canvas) => {
                try {
                    if (!canvas) return false;
                    const w = canvas.width || 0;
                    const h = canvas.height || 0;
                    if (w === 0 || h === 0) return false;

                    const ctx = canvas.getContext('2d', { willReadFrequently: true });
                    if (!ctx) return false;

                    // Sample-Scan: nicht jedes Pixel (Performance), aber zuverlässig genug.
                    const step = Math.max(4, Math.floor(Math.min(w, h) / 80)); // adaptiv
                    const img = ctx.getImageData(0, 0, w, h);
                    const data = img.data;

                    for (let y = 0; y < h; y += step) {
                        const row = y * w * 4;
                        for (let x = 0; x < w; x += step) {
                            const a = data[row + x * 4 + 3]; // alpha
                            if (a && a > 0) return true;
                        }
                    }
                    return false;
                } catch (e) {
                    // Falls der Canvas "tainted" wäre oder readback nicht geht:
                    return false;
                }
            };

const isOfferAreaNonEmpty = React.useCallback((k) => {
                try {
                    const hasText = !!String(getDisplayText(k) || '').trim();
                    const cEl = getOfferCanvasElByKey(k);
                    const hasInk = (cEl ? canvasHasVisibleInk(cEl) : !!(drawnStrokes && drawnStrokes[k] && drawnStrokes[k].length));
                    const hasImg = !!(canvasImages && canvasImages[k]);
                    const hasHtml = !!((k === 'offer1') ? window.__canvasHtmlOffer1 : (k === 'offer2') ? window.__canvasHtmlOffer2 : (k === 'offer3') ? window.__canvasHtmlOffer3 : null);
                    return hasText || hasInk || hasImg || hasHtml;
                } catch (e) {
                    return false;
                }
            }, [getDisplayText, drawnStrokes, canvasImages]);

            const isReadyToFinish = ['offer1','offer2','offer3'].every(k => {
                if (!isOfferAreaNonEmpty(k)) return true; // leer -> keine Status-Pflicht
                const s = (canvasStatus && canvasStatus[k]) ? canvasStatus[k] : 'neutral';
                return (s === 'open' || s === 'closed');
            });

            // ===== Bundle -> Ziel-Canva (HTML bevorzugt, Fallback Bild) =====
            const importBundleToCanvas = React.useCallback((payload) => {
                if (!payload) return;
                const key = bundleTargetKey || 'offer1';

                const calcCenteredY = () => {
                    try {
                        const containers = document.querySelectorAll('.offer-canvas-container');
                        const idx = (key === 'offer2') ? 1 : (key === 'offer3') ? 2 : 0;
                        const el = containers && containers[idx];
                        const h = el ? (el.clientHeight || 0) : 0;
                        // Overlay-Card ist ca. 320px hoch; wir starten mit scale 0.8 => ~256px.
                        const approxOverlayH = 320 * 0.8;
                        const y = Math.round((h > 0 ? (h - approxOverlayH) / 2 : 140));
                        // Nie ganz oben, damit Icons frei bleiben
                        return Math.max(110, y);
                    } catch (e) {
                        return 140;
                    }
                };

                const applyCenteredY = () => {
                    const y = calcCenteredY();
                    setImageTransform(prev => ({
                        ...prev,
                        [key]: { ...(prev[key] || { x: 0, y: 0, scale: 0.8, rotation: 0 }), y, x: 0, scale: 0.8, rotation: 0 }
                    }));
                };

                // 1) HTML-Import (Scharf)
                if (typeof payload === 'object' && payload.kind === 'html') {
                    setCanvasHtml(prev => ({ ...prev, [key]: payload.html || null }));
                    setCanvasImages(prev => ({ ...prev, [key]: null })); // Bild leeren

                    // Nach Render: mittig positionieren (damit die Toolbar-Icons nicht verdeckt werden)
                    requestAnimationFrame(() => requestAnimationFrame(applyCenteredY));

                    triggerToast('Bundle (HTML – scharf) eingefügt.');
                    setShowBundleModal(false);
                    return;
                }

                // 2) Fallback: Bild-Import
                if (typeof payload === 'string') {
                    setCanvasImages(prev => ({ ...prev, [key]: payload }));
                    setCanvasHtml(prev => ({ ...prev, [key]: null }));

                    // Nach Render: mittig positionieren
                    requestAnimationFrame(() => requestAnimationFrame(applyCenteredY));

                    triggerToast('Bundle (Bild) eingefügt.');
                    setShowBundleModal(false);
                }
            }, [triggerToast, bundleTargetKey]);


            // ===== Fullscreen Toggle (F11-like) =====
            const [isFullscreen, setIsFullscreen] = useState(!!document.fullscreenElement);
            useEffect(() => {
                const onFsChange = () => setIsFullscreen(!!document.fullscreenElement);
                document.addEventListener('fullscreenchange', onFsChange);
                return () => document.removeEventListener('fullscreenchange', onFsChange);
            }, []);

            const toggleFullScreen = useCallback(async () => {
                try {
                    if (!document.fullscreenElement) {
                        const el = document.documentElement;
                        if (el && el.requestFullscreen) {
                            await el.requestFullscreen();
                        } else {
                            triggerToast && triggerToast('Vollbild wird von diesem Browser nicht unterstützt (iOS/Safari). Tipp: Als PWA „Zum Home‑Bildschirm“ hinzufügen.');
                        }
                    } else {
                        if (document.exitFullscreen) await document.exitFullscreen();
                    }
                } catch (err) {
                    console.warn('fullscreen failed', err);
                    triggerToast && triggerToast('Vollbild konnte nicht aktiviert werden.');
                }
            }, [triggerToast]);

            const openOneDriveLink = () => { if (oneDriveLink && oneDriveLink.startsWith('http')) { window.open(oneDriveLink, '_blank'); triggerToast('Aktionsmappe geöffnet.'); } else { triggerToast('WICHTIG: Kein gültiger OneDrive Link hinterlegt. Bitte pflegen Sie den Link in den Einstellungen.'); } };
            const handleFileSelect = (event) => { const file = event.target.files?.[0]; event.target.value = null; setRedrawCounter(r => r + 1); if (!file) { triggerToast('Datei-Auswahl abgebrochen.'); return; } if (!file.type.startsWith('image/') && !file.type.includes('pdf')) { triggerToast(`Datei "${file.name}" ausgewählt. Nur Bilder werden visuell platziert.`); return; } const reader = new FileReader(); reader.onload = (e) => { const imageDataUrl = e.target.result; setCurrentImagePayload({ url: imageDataUrl, name: file.name }); setIsImageSelectModalOpen(true); }; reader.readAsDataURL(file); };
            const handleFileAdd = () => { fileInputRef.current?.click(); };
            const handleImagePlacement = (targetCanvasKey) => { if (currentImagePayload) { setCanvasImages(prev => ({ ...prev, [targetCanvasKey]: currentImagePayload.url })); setImageTransform(prev => ({ ...prev, [targetCanvasKey]: { x: 0, y: 0, scale: 0.8, rotation: 0 } })); triggerToast(`Bild "${currentImagePayload.name}" zu ${targetCanvasKey.toUpperCase()} hinzugefügt.`); } setIsImageSelectModalOpen(false); setCurrentImagePayload(null); };
            const handleClearImage = (key) => { setCanvasImages(prev => ({ ...prev, [key]: null })); setImageTransform(prev => ({ ...prev, [key]: { x: 0, y: 0, scale: 1.0, rotation: 0 } })); triggerToast(`Bild von ${key.toUpperCase()} entfernt.`); };
            const handleClearOverlay = (key) => {
                // Wichtig: Beim Entfernen NICHT den Transform auf 1.0 resetten – das verursacht ein kurzes "Großziehen"
                // durch die Transition. Wir behalten den aktuellen Transform (oder Default), damit es visuell sofort verschwindet.
                setCanvasImages(prev => ({ ...prev, [key]: null }));
                setCanvasHtml(prev => ({ ...prev, [key]: null }));
                setImageTransform(prev => ({ ...prev, [key]: (prev && prev[key]) ? prev[key] : { x: 0, y: 0, scale: 0.8, rotation: 0 } }));
                triggerToast(`Inhalt von ${key.toUpperCase()} entfernt.`);
            };

            // === PRINT: Hintergrund-Layer als IMG (druckt auch ohne "Hintergrundgrafiken") ===
            const PRINT_BG_SVG = {
                blue50: "data:image/svg+xml;charset=utf-8," + encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='#eff6ff'/></svg>"),
                slate100: "data:image/svg+xml;charset=utf-8," + encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='#f1f5f9'/></svg>")
            };

            const injectPrintBgLayers = useCallback(() => {
                try {
                    const hosts = [];

                    const addLayer = (el, src) => {
                        if (!el || el.querySelector(':scope > img.print-bg-img-layer')) return;
                        el.classList.add('print-bg-host');
                        const img = document.createElement('img');
                        img.className = 'print-bg-img-layer';
                        img.setAttribute('aria-hidden', 'true');
                        img.setAttribute('data-print-bg', '1');
                        img.alt = '';
                        img.src = src;
                        el.insertBefore(img, el.firstChild);
                        hosts.push(el);
                    };

                    document.querySelectorAll('.bg-blue-50').forEach(el => addLayer(el, PRINT_BG_SVG.blue50));
                    document.querySelectorAll('.bg-slate-100').forEach(el => addLayer(el, PRINT_BG_SVG.slate100));

                    return hosts;
                } catch (e) {
                    return [];
                }
            }, []);

            const cleanupPrintBgLayers = useCallback(() => {
                try {
                    document.querySelectorAll('img.print-bg-img-layer[data-print-bg="1"]').forEach(img => img.remove());
                    document.querySelectorAll('.print-bg-host').forEach(el => el.classList.remove('print-bg-host'));
                } catch (e) { /* ignore */ }
            }, []);

            // Global vor/nach Print (falls User STRG+P direkt nutzt)
            useEffect(() => {
                const bp = () => injectPrintBgLayers();
                const ap = () => cleanupPrintBgLayers();
                window.addEventListener('beforeprint', bp);
                window.addEventListener('afterprint', ap);
                return () => {
                    window.removeEventListener('beforeprint', bp);
                    window.removeEventListener('afterprint', ap);
                };
            }, [injectPrintBgLayers, cleanupPrintBgLayers]);

            const requestPrint = useCallback((doPrint) => {
                // Angebotsgültigkeit nur abfragen, wenn mindestens ein Bereich auf "Offen" steht.
                const hasOpen = (() => {
                    try {
                        const keys = ['offer1','offer2','offer3'];
                        const nonEmpty = keys.filter(k => {
                            const hasText = !!String(getDisplayText(k) || '').trim();
                            const hasInk = !!(drawnStrokes && drawnStrokes[k] && drawnStrokes[k].length);
                            const hasImg = !!(canvasImages && canvasImages[k]);
                            const hasHtml = !!(k === 'offer1' ? window.__canvasHtmlOffer1 : k === 'offer2' ? window.__canvasHtmlOffer2 : window.__canvasHtmlOffer3);
                            return hasText || hasInk || hasImg || hasHtml;
                        });
                        return nonEmpty.some(k => (canvasStatus && canvasStatus[k]) === 'open');
                    } catch(e){ return false; }
                })();

                const hasText = !!String(getDisplayText('OfferValidUntil') || '').trim();
                const hasInk = !!(drawnStrokes.offer_valid_until && drawnStrokes.offer_valid_until.length);

                // PRINT-HINWEIS (Browser-Setting): Farben/Hintergründe werden nur gedruckt, wenn
                // im Druckdialog "Hintergrundgrafiken" (bzw. "Hintergrundfarben und -bilder") aktiviert ist.
                // Der CSS-Fix ist bereits aktiv, aber dieses Häkchen kann die Ausgabe trotzdem überschreiben.
                try {
                    if (typeof triggerToast === 'function') {
                        triggerToast('Tipp (STRG+P): In Chrome/Edge unter „Weitere Einstellungen“ → „Hintergrundgrafiken“ aktivieren, damit Farben/Hintergründe gedruckt werden.');
                    }
                } catch(e) { /* ignore */ }

                // Nur wenn "offen" UND noch kein Datum vorhanden -> Modal zeigen
                if (hasOpen && !hasText && !hasInk) {
                    pendingPrintRef.current = (typeof doPrint === 'function') ? doPrint : (() => window.print());
                    setShowValidityModal(true);
                    return;
                }

                // Wichtig: Layer injizieren, damit blaue/graue Hintergründe sicher gedruckt werden
                // (auch wenn im Druckdialog "Hintergrundgrafiken" deaktiviert ist).
                injectPrintBgLayers();

                (typeof doPrint === 'function' ? doPrint : (() => window.print()))();
            }, [drawnStrokes, getDisplayText, canvasStatus, triggerToast, injectPrintBgLayers]);

            const downloadPdfBlob = (blob, filename) => {
                try {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    setTimeout(() => URL.revokeObjectURL(url), 5000);
                } catch (e) { /* ignore */ }
            };

            const safePrint = useCallback(() => {
                // 1) Bevorzugt: System-Druckdialog
                if (typeof window.print === 'function') {
                    try {
                        window.safePrint ? window.safePrint() : window.print();
                        return;
                    } catch (e) {
                        // fällt unten auf PDF-Fallback
                    }
                }

                // 2) Fallback: PDF im Print-Look erzeugen und speichern (wenn Drucken vom Browser blockiert wird)
                (async () => {
                    try {
                        if (!window.html2pdf) {
                            triggerToast('Drucken nicht verfügbar (PDF-Generator fehlt).');
                            return;
                        }
                        triggerToast('Druck-Fallback: PDF wird erstellt…');
                        const blob = await createPrintLookPdfBlob(triggerToast, ensurePrintHeaders);
                        const filename = `Angebot_${new Date().toISOString().slice(0,10)}.pdf`;
                        downloadPdfBlob(blob, filename);
                    } catch (e) {
                        console.warn('safePrint fallback failed:', e);
                        triggerToast('Drucken/Export nicht möglich.');
                    }
                })();
            }, [triggerToast]);

            const handlePrint = useCallback(() => { requestPrint(() => safePrint()); }, [requestPrint, safePrint]);

            
            const getAgentDisplayNameForUpload = () => {
                const raw = (textData && textData.AgentName) ? String(textData.AgentName).trim() : '';
                if (!raw) return 'Elif Icik';
                if (raw === 'E.I' || raw.toLowerCase() === 'e.i') return 'Elif Icik';
                if (raw === 'Max Mustermann' || raw.toLowerCase() === 'unknown') return 'Elif Icik';
                return raw;
            };
            const getDslFlagForUpload = () => {
                try {
                    const stats = buildCanvasStatsFromDrawnStrokes(drawnStrokes, textData, { skipReason });
                    const dslOffered = !!(stats?.offer2?.used || stats?.offer3?.used);
                    return dslOffered ? 'ja' : 'nein';
                } catch(e) { return 'nein'; }
            };

const handleFinishOfferClick = () => {
                // Inhalterkennung: Status nur fuer Bereiche erzwingen, die wirklich Inhalt haben
                const keys = ['offer1','offer2','offer3'];
                const nonEmptyKeys = keys.filter(k => {
                    try {
                        const hasText = !!String(getDisplayText(k) || '').trim();
                        const hasInk = !!(drawnStrokes && drawnStrokes[k] && drawnStrokes[k].length);
                        const hasImg = !!(canvasImages && canvasImages[k]);
                        const hasHtml = !!(k === 'offer1' ? window.__canvasHtmlOffer1 : k === 'offer2' ? window.__canvasHtmlOffer2 : window.__canvasHtmlOffer3);
                        return hasText || hasInk || hasImg || hasHtml;
                    } catch(e) { return false; }
                });

                const missingStatus = nonEmptyKeys.filter(k => {
                    const s = (canvasStatus && canvasStatus[k]) || 'neutral';
                    return !(s === 'open' || s === 'closed');
                });

                if (missingStatus.length > 0) {
                    try {
                        triggerToast('Bitte Status setzen (Offen/Abgeschlossen) fuer: ' + missingStatus.map(k => k.replace('offer','Angebot ')).join(', '));
                    } catch(e) {}
                    return;
                }

                const openKeys = nonEmptyKeys.filter(k => canvasStatus[k] === 'open');

                // Wenn Kunde unterschrieben hat: erst Folgetermine abfragen (falls etwas offen), dann drucken/hochladen
                if (customerSignature) {
                    if (openKeys.length > 0) {
                        startFollowUpFlow(openKeys);
                        return;
                    }
                    backgroundAutoUpload({ type: 'abschluss', triggerToast, ensurePrintHeaders, getAgent: getAgentDisplayNameForUpload, getDsl: getDslFlagForUpload });
                    handlePrint();
                    return;
                }

                // Ohne Unterschrift: Entscheidung (Papier / PDF / Share) wie bisher
                setShowFinishTypeModal(true);
            };

            const handleFinishTypeSelection = (type) => {
                setShowFinishTypeModal(false);
                // --- Analytics log (DSGVO-safe: only usage, no content) ---
                try {
                    appendAnalyticsRow({
                        ts: new Date().toISOString(),
                        user: (() => {
                            const raw = (textData && textData.AgentName) ? String(textData.AgentName).trim() : '';
                            if (!raw) return 'Elif Icik';
                            if (raw === 'E.I' || raw.toLowerCase() === 'e.i') return 'Elif Icik';
                            if (raw === 'Max Mustermann' || raw.toLowerCase() === 'unknown') return 'Elif Icik';
                            return raw;
                        })(),
                        shop: 'HeTec',
                        result: (type === 'deal') ? 'Abschluss' : 'Angebot',
                        canvasStats: buildCanvasStatsFromDrawnStrokes(drawnStrokes, textData, { skipReason })
                    });
                } catch (e) { /* ignore */ }

                if (type === 'deal') {
                    // Path 1: Deal -> Signature -> Referral -> Print
                    setShowSignatureModal(true);
                } else {
                    // Path 2: Quote -> Skip Signature -> Skip Referral -> Print directly
                    // Clear signature just in case
                    setCustomerSignature(null);
                    triggerToast("Angebot wird gedruckt (Status: Offen)");
                    // Angebot: im Hintergrund als PDF (Print-Look) nach OneDrive (Power Automate) hochladen
                    backgroundAutoUpload({ type: 'angebot', triggerToast, ensurePrintHeaders, getAgent: getAgentDisplayNameForUpload, getDsl: getDslFlagForUpload });
                    handlePrint();
                }
            };
            
            const handleSignatureSave = (dataUrl) => { if (dataUrl === 'PAPER_SIGNATURE') { setCustomerSignature(null); triggerToast("Papier-Unterschrift bestätigt."); } else { setCustomerSignature(dataUrl); triggerToast("Unterschrift erfasst."); } setShowSignatureModal(false); setTimeout(() => setShowReferralModal(true), 300); };
            
            const handleSkipToOffer = (reasonData) => { setSkipReason(reasonData); setShowSkipReasonModal(false); setView('offer'); triggerToast(`Situation übersprungen. Grund: ${reasonData.substring(0, 30)}...`); };

            const handleClearAll = () => { setDrawnStrokes({ main: [], email: [], provider: [], notes: [], skip_reason: [], sit_Kundenname: [], sit_Rufnummer: [], sit_Anbieter: [], sit_Hardware: [], sit_Nutzung: [], sit_Haushalt: [], sit_WeitereProdukte: [], sit_Fernsehen: [], sit_WiFi: [], sit_Gesamtkosten: [], offer1: [], offer2: [], offer3: [], cost_einmalig: [], cost_monatlich1: [], cost_monatlich2: [], agent_name: [], date_field: [], offer_valid_until: [] }); setTextData({ AgentName: '', DateValue: '', OfferValidUntil: '', offer1: '', offer2: '', offer3: '', Kundenname: '', Rufnummer: '', Anbieter: '', Hardware: '', Nutzung: '', Haushalt: '', 'Weitere Produkte': '', Fernsehen: '', WiFi: '', Gesamtkosten: '' }); setCustomerType(""); setSegment(""); setProviderSelect(""); setCustomProvider(""); setIsCustomProvider(false); setWlanRecommendation(''); setSpeedRecommendation(''); setEmailText(''); setSkipReason(''); setSkipReasonMode('keyboard'); setCostState({ mobile: '', landline: '', tv: '' }); setOfferData(initialOfferData); setCanvasStatus({ offer1: 'neutral', offer2: 'neutral', offer3: 'neutral' }); setCustomerSignature(null); setCanvasImages({ offer1: null, offer2: null, offer3: null }); setImageTransform({ offer1: { x: 0, y: 0, scale: 1.0, rotation: 0 }, offer2: { x: 0, y: 0, scale: 1.0, rotation: 0 }, offer3: { x: 0, y: 0, scale: 1.0, rotation: 0 } }); setRedrawCounter(r => r + 1); triggerToast('Alle Daten gelöscht und Ansicht zurückgesetzt.'); };

            const Toast = ({ message }) => { if (!message) return null; return (<div className="print-hide-toast fixed bottom-4 left-1/2 -translate-x-1/2 z-[100] bg-slate-900 text-white px-4 py-2 rounded-xl shadow-lg border border-slate-700 animate-in fade-in duration-300"><div className="flex items-center gap-2"><Icon d={ICONS.Clipboard} size={16} className="text-green-400"/><span className="text-sm font-medium">{message}</span></div></div>); };

            useEffect(() => { const handleBeforeUnload = (e) => { e.preventDefault(); e.returnValue = ''; return ''; }; window.addEventListener('beforeunload', handleBeforeUnload); return () => window.removeEventListener('beforeunload', handleBeforeUnload); }, []);
            const handleCategoryClick = (cat) => { setActiveCategory(cat); setQuestionIndex(0); };
            const handleNextQuestion = () => setQuestionIndex((prev) => (prev + 1) % (questionsData[activeCategory || 'default'].length));
            const getCurrentQuestion = () => questionsData[activeCategory || 'default'][questionIndex];
            const handleTextChange = (key, val) => {
                setTextData(prev => ({ ...prev, [key]: val }));
                // Merken: dieses Feld wurde digital (Tastatur) genutzt -> im Druck/Share anzeigen
                try {
                    if (inputMode === 'keyboard') {
                        const map = {
                            'Kundenname': 'sit_Kundenname', 'Rufnummer': 'sit_Rufnummer', 'Anbieter': 'sit_Anbieter', 'Hardware': 'sit_Hardware',
                            'Nutzung': 'sit_Nutzung', 'Haushalt': 'sit_Haushalt', 'Weitere Produkte': 'sit_WeitereProdukte', 'WeitereProdukte': 'sit_WeitereProdukte',
                            'Fernsehen': 'sit_Fernsehen', 'WiFi': 'sit_WiFi', 'Gesamtkosten': 'sit_Gesamtkosten',
                            'offer1': 'offer1', 'offer2': 'offer2', 'offer3': 'offer3',
                            'cost_einmalig': 'cost_einmalig', 'cost_monatlich1': 'cost_monatlich1', 'cost_monatlich2': 'cost_monatlich2',
                            'AgentName': 'agent_name', 'DateValue': 'date_field', 'OfferValidUntil': 'offer_valid_until',
                            'skip_reason': 'skip_reason'
                        };
                        const k = map[key];
                        if (k) digitalTouchedRef.current[k] = true;
                    }
                } catch(e){}
                if (displayLanguage !== 'de') {
                    setTranslatedText(prev => ({ ...prev, [displayLanguage]: { ...prev[displayLanguage], [key]: val } }));
                }
            };
            const handleCostChange = (key, e) => { const val = e.target.value; setCostState(prev => ({ ...prev, [key]: val })); };
            const handleUpdateQuestions = (cat, newQs) => { setQuestionsData(prev => ({...prev, [cat]: newQs})); };
            const isFormValid = customerType !== "" && segment !== "" && techSituation !== "";
            const isMainInputReadOnly = inputMode === 'pen';
            const getInputClasses = () => { let classes = "w-full h-full bg-transparent border-none focus:ring-0 px-4 placeholder-blue-50/0 group-hover:placeholder-blue-100/50 transition-all "; if (textSize === 'small') classes += "text-sm "; else if (textSize === 'medium') classes += "text-base "; else if (textSize === 'large') classes += "text-xl "; if (textStyle.bold) classes += "font-black "; else classes += "font-medium "; if (textStyle.italic) classes += "italic "; return classes; };
            const clearCanvas = (ref, key) => { const canvas = ref.current; if (!canvas) return; const ctx = canvas.getContext('2d'); const dpr = window.devicePixelRatio || 1; ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr); setDrawnStrokes(prev => ({ ...prev, [key]: [] })); setRedrawCounter(r => r + 1); };

            useEffect(() => { 
                const canvasMap = [ 
                    // Situation: 1 Canvas pro Zeile
                    { ref: sitCanvasRef_Kundenname, key: 'sit_Kundenname', mode: inputMode },
                    { ref: sitCanvasRef_Rufnummer, key: 'sit_Rufnummer', mode: inputMode },
                    { ref: sitCanvasRef_Anbieter, key: 'sit_Anbieter', mode: inputMode },
                    { ref: sitCanvasRef_Hardware, key: 'sit_Hardware', mode: inputMode },
                    { ref: sitCanvasRef_Nutzung, key: 'sit_Nutzung', mode: inputMode },
                    { ref: sitCanvasRef_Haushalt, key: 'sit_Haushalt', mode: inputMode },
                    { ref: sitCanvasRef_WeitereProdukte, key: 'sit_WeitereProdukte', mode: inputMode },
                    { ref: sitCanvasRef_Fernsehen, key: 'sit_Fernsehen', mode: inputMode },
                    { ref: sitCanvasRef_WiFi, key: 'sit_WiFi', mode: inputMode },
                    { ref: sitCanvasRef_Gesamtkosten, key: 'sit_Gesamtkosten', mode: inputMode },

                    // Kleine Input-Canvas
                    { ref: emailCanvasRef, key: 'email', mode: emailMode }, 
                    { ref: providerCanvasRef, key: 'provider', mode: providerMode, condition: isCustomProvider }, 
                    { ref: notesCanvasRef, key: 'notes', mode: notesMode }, 
                    { ref: skipReasonCanvasRef, key: 'skip_reason', mode: skipReasonMode, condition: true } 
                ]; 

                const offerCanvasMap = [ 
                    { ref: offerCanvasRef1, key: 'offer1', scaleRef: scaleRef1 }, 
                    { ref: offerCanvasRef2, key: 'offer2', scaleRef: scaleRef2 }, 
                    { ref: offerCanvasRef3, key: 'offer3', scaleRef: scaleRef3 }, 
                    { ref: offerCost1Ref, key: 'cost_einmalig', mode: inputMode, condition: true }, 
                    { ref: offerCost2Ref, key: 'cost_monatlich1', mode: inputMode, condition: true }, 
                    { ref: offerCost3Ref, key: 'cost_monatlich2', mode: inputMode, condition: true }, 
                    { ref: offerAgentRef, key: 'agent_name', mode: inputMode, condition: true }, 
                    { ref: offerDateRef, key: 'date_field', mode: inputMode, condition: true } 
                ]; 

                const resizeCanvas = (ref, key) => { 
                    const canvas = ref.current; 
                    if (!canvas || !key) return; 
                    const rect = canvas.getBoundingClientRect(); 
                    if (!rect || rect.width === 0 || rect.height === 0) return; 
                    const dpr = window.devicePixelRatio || 1; 
                    dprRef.current = dpr; 
                    const oldWidth = canvas.width; 
                    const oldHeight = canvas.height; 
                    const newWidth = rect.width * dpr; 
                    const newHeight = rect.height * dpr; 
                    if (oldWidth !== newWidth || oldHeight !== newHeight) { 
                        canvas.width = newWidth; 
                        canvas.height = newHeight; 
                        const ctx = canvas.getContext('2d'); 
                        ctx.setTransform(dpr, 0, 0, dpr, 0, 0); 
                        ctx.lineCap = 'round'; 
                        ctx.lineJoin = 'round'; 
                    } 
                }; 

                const resizeAll = () => { 
                    canvasMap.forEach(map => { 
                        const shouldResize = map.mode === 'pen' && (map.condition === undefined || map.condition); 
                        if (shouldResize) { resizeCanvas(map.ref, map.key); } 
                    }); 
                    if (view === 'offer') { 
                        offerCanvasMap.forEach(({ ref, key }) => { resizeCanvas(ref, key); }); 
                    } 
                    setRedrawCounter(r => r + 1); 
                }; 

                resizeAll(); 
                window.addEventListener('resize', resizeAll); 
                return () => window.removeEventListener('resize', resizeAll); 
            }, [emailMode, providerMode, isCustomProvider, notesMode, skipReasonMode, view, inputMode]); 
            useEffect(() => { 
                if (view !== 'situation') return; 
                const list = [
                    { ref: sitCanvasRef_Kundenname, key: 'sit_Kundenname' },
                    { ref: sitCanvasRef_Rufnummer, key: 'sit_Rufnummer' },
                    { ref: sitCanvasRef_Anbieter, key: 'sit_Anbieter' },
                    { ref: sitCanvasRef_Hardware, key: 'sit_Hardware' },
                    { ref: sitCanvasRef_Nutzung, key: 'sit_Nutzung' },
                    { ref: sitCanvasRef_Haushalt, key: 'sit_Haushalt' },
                    { ref: sitCanvasRef_WeitereProdukte, key: 'sit_WeitereProdukte' },
                    { ref: sitCanvasRef_Fernsehen, key: 'sit_Fernsehen' },
                    { ref: sitCanvasRef_WiFi, key: 'sit_WiFi' },
                    { ref: sitCanvasRef_Gesamtkosten, key: 'sit_Gesamtkosten' }
                ];
                list.forEach(({ ref, key }) => {
                    const c = ref.current;
                    if (!c) return;
                    redrawCanvas(c, drawnStrokes[key] || [], 1, key);
                });
            }, [view, drawnStrokes, redrawCounter]);
            // --- Migration: altes 'main' (großes Overlay) -> neue 'sit_*' Zeilen-Canvas ---
            useEffect(() => {
                if (view !== 'situation') return;
                if (hasMigratedSituationRef.current) return;

                const legacy = drawnStrokes.main || [];
                const hasLegacy = legacy.length > 0;

                const sitKeys = ['sit_Kundenname','sit_Rufnummer','sit_Anbieter','sit_Hardware','sit_Nutzung','sit_Haushalt','sit_WeitereProdukte','sit_Fernsehen','sit_WiFi','sit_Gesamtkosten'];
                const alreadyHasSit = sitKeys.some(k => (drawnStrokes[k] || []).length > 0);
                if (!hasLegacy || alreadyHasSit) { hasMigratedSituationRef.current = true; return; }

                // Wir approximieren die alte Canvas-Höhe als Summe der Zeilenhöhen (Layout ist identisch),
                // und verteilen Strokes anhand ihres durchschnittlichen Y-Werts auf die passende Zeile.
                const rows = [
                    { key: 'sit_Kundenname', ref: sitCanvasRef_Kundenname },
                    { key: 'sit_Rufnummer', ref: sitCanvasRef_Rufnummer },
                    { key: 'sit_Anbieter', ref: sitCanvasRef_Anbieter },
                    { key: 'sit_Hardware', ref: sitCanvasRef_Hardware },
                    { key: 'sit_Nutzung', ref: sitCanvasRef_Nutzung },
                    { key: 'sit_Haushalt', ref: sitCanvasRef_Haushalt },
                    { key: 'sit_WeitereProdukte', ref: sitCanvasRef_WeitereProdukte },
                    { key: 'sit_Fernsehen', ref: sitCanvasRef_Fernsehen },
                    { key: 'sit_WiFi', ref: sitCanvasRef_WiFi },
                    { key: 'sit_Gesamtkosten', ref: sitCanvasRef_Gesamtkosten }
                ];

                // Warten bis alle Canvas gerendert sind
                const allReady = rows.every(r => r.ref.current && r.ref.current.getBoundingClientRect().height > 0);
                if (!allReady) return;

                const heights = rows.map(r => r.ref.current.getBoundingClientRect().height);
                const cum = [];
                heights.reduce((acc, h, i) => { cum[i] = acc + h; return cum[i]; }, 0);

                const bucket = Object.fromEntries(rows.map(r => [r.key, []]));
                legacy.forEach(stroke => {
                    const pts = stroke.points || [];
                    if (pts.length < 2) return;
                    const avgY = pts.reduce((s,p)=>s+(p.y||0),0) / pts.length;
                    let idx = cum.findIndex(c => avgY < c);
                    if (idx === -1) idx = rows.length - 1;
                    const rowTop = idx === 0 ? 0 : cum[idx-1];
                    const migrated = {
                        ...stroke,
                        points: pts.map(p => ({ x: p.x, y: (p.y||0) - rowTop }))
                    };
                    bucket[rows[idx].key].push(migrated);
                });

                setDrawnStrokes(prev => ({
                    ...prev,
                    ...Object.fromEntries(Object.entries(bucket).map(([k,v]) => [k, [...(prev[k]||[]), ...v]])),
                    main: [] // legacy leeren, damit es nicht doppelt gespeichert wird
                }));

                hasMigratedSituationRef.current = true;
            }, [view, drawnStrokes, setDrawnStrokes]);

            const getRelativeCoords = (e, canvas) => { const rect = canvas.getBoundingClientRect(); const clientX = e.clientX ?? e.touches?.[0]?.clientX; const clientY = e.clientY ?? e.touches?.[0]?.clientY; if (clientX === undefined || clientY === undefined) return null; const cssX = clientX - rect.left; const cssY = clientY - rect.top; return { x: cssX, y: cssY }; };

            // ✅ Pinch-Zoom im Canvas erlauben:
            // - 1 Finger/pen: Zeichnen (Default-Gesten blocken)
            // - 2 Finger (touch): Browser darf zoomen (Pinch)
            const getCanvasPointerState = (canvas) => {
                if (!canvas) return { count: 0 };
                if (!canvas.__pinchState) canvas.__pinchState = { count: 0 };
                return canvas.__pinchState;
            };
            const updateCanvasTouchAction = (canvas, count) => {
                if (!canvas) return;
                // Wenn GestureMode aktiv: Touch-Gesten (Pan/Pinch) immer erlauben.
                if (gestureModeRef?.current) {
                    canvas.style.touchAction = 'pan-x pan-y pinch-zoom';
                    return;
                }
                // Normal: 1 Finger/Pen = Zeichnen (keine Default-Gesten), 2 Finger = Browser-Pan/Pinch erlauben.
                canvas.style.touchAction = (count >= 2) ? 'pan-x pan-y pinch-zoom' : 'none';
            };

            const startDrawing = useCallback((e, ref, key) => {
                const canvas = ref?.current;
                if(!canvas) return;

                // Multi-touch erkennen (2 Finger) -> Pinch erlauben
                const st = getCanvasPointerState(canvas);
                st.count = (st.count || 0) + 1;
                updateCanvasTouchAction(canvas, st.count);

                const pointerType = e.pointerType;
                // GestureMode: Touch soll immer zoomen/pannen dürfen (auch mit 1 Finger, z.B. beim Verschieben auf gezoomter Seite)
                if (gestureModeRef.current && pointerType === 'touch') {
                    isDrawingRef.current = false;
                    currentStrokeRef.current = null;
                    return;
                }

                if (pointerType === 'touch' && st.count >= 2) {
                    // Kein Zeichnen, keine preventDefault -> Browser-Geste (Zoom/Pan) zulassen
                    isDrawingRef.current = false;
                    currentStrokeRef.current = null;
                    return;
                }

                // 1 Finger / Pen: Zeichnen (Default-Gesten blocken)
                e.preventDefault();

                const isPenInput = pointerType === 'pen';
                const isMainCanvasPenActive = ref === canvasRef && inputMode === 'pen';
                const isSituationCanvasActive = key && key.startsWith('sit_') && inputMode === 'pen';
                const isSmallCanvasPenActive = (ref === emailCanvasRef && emailMode === 'pen') || (ref === providerCanvasRef && providerMode === 'pen') || (ref === notesCanvasRef && notesMode === 'pen') || (ref === skipReasonCanvasRef && skipReasonMode === 'pen');
                const isOfferCanvasActive = (ref === offerCanvasRef1 || ref === offerCanvasRef2 || ref === offerCanvasRef3) && inputMode === 'pen';
                const isOfferInputActive = (ref === offerCost1Ref || ref === offerCost2Ref || ref === offerCost3Ref || ref === offerAgentRef || ref === offerDateRef) && inputMode === 'pen';

                if (!isPenInput || (!isMainCanvasPenActive && !isSituationCanvasActive && !isSmallCanvasPenActive && !isOfferCanvasActive && !isOfferInputActive)) {
                    return;
                }

                const { x: cssX, y: cssY } = getRelativeCoords(e, canvas) || {};
                if (cssX == null || cssY == null) return;

                const ctx = canvas.getContext('2d');
                const selectedTool = toolRef.current;
                const pointerTypeNow = e.pointerType;
                const currentStrokeWidth = strokeWidthRef.current;
                const currentColor = colorRef.current;
                const baseOpacity = opacityRef.current;

                const currentTool = resolveToolForPointer(selectedTool, pointerTypeNow);
                const tune = getToolTuning(currentTool, currentStrokeWidth, baseOpacity);
                const currentOpacity = tune.opacity;
                const strokeBaseWidth = canvas.getBoundingClientRect().width;
                const strokeBaseHeight = canvas.getBoundingClientRect().height;
                const zoomLevel = 1.0;
                const x = cssX / zoomLevel;
                const y = cssY / zoomLevel;

                const newStroke = { tool: currentTool, color: currentColor, width: tune.width, opacity: currentOpacity, points: [{ x, y }], baseWidth: strokeBaseWidth, baseHeight: strokeBaseHeight };

                ctx.save();
                const isOfferType = key.startsWith('offer');
                const rawStrokeW = tune.width;
                let visualBaseW;
                if (isOfferType) { visualBaseW = rawStrokeW === 2 ? 2.5 : rawStrokeW === 4 ? 5 : 8; }
                else { visualBaseW = rawStrokeW === 2 ? 2 : rawStrokeW === 4 ? 3 : 5; }

                const finalLineWidth = visualBaseW / zoomLevel;
                if (currentTool === 'eraser') { ctx.lineWidth = finalLineWidth * 4; ctx.globalCompositeOperation = 'destination-out'; ctx.globalAlpha = 1; }
                else if (currentTool === 'highlighter') { ctx.lineWidth = finalLineWidth * 3; ctx.strokeStyle = currentColor; ctx.globalAlpha = currentOpacity; ctx.globalCompositeOperation = 'destination-over'; }
                else { ctx.lineWidth = finalLineWidth; ctx.strokeStyle = currentColor; ctx.globalAlpha = currentOpacity; ctx.globalCompositeOperation = 'source-over'; }

                ctx.beginPath();
                ctx.moveTo(x, y);

                currentStrokeRef.current = newStroke;
                isDrawingRef.current = true;
            }, [inputMode, emailMode, providerMode, notesMode, skipReasonMode, strokeWidth, color, opacity]);

            const draw = useCallback((e, ref, key) => {
                const canvas = ref.current;
                if(!canvas) return;

                const st = getCanvasPointerState(canvas);
                const pointerType = e.pointerType;

                // GestureMode oder 2 Finger aktiv -> kein Zeichnen, keine preventDefault
                if ((gestureModeRef.current && pointerType === 'touch') || (pointerType === 'touch' && (st.count || 0) >= 2)) return;

                if (!isDrawingRef.current || !currentStrokeRef.current) return;

                e.preventDefault();

                const { x: cssX, y: cssY } = getRelativeCoords(e, canvas) || {};
                if (cssX == null || cssY == null) return;

                const zoomLevel = 1.0;
                const x = cssX / zoomLevel;
                const y = cssY / zoomLevel;

                const ctx = canvas.getContext('2d');
                currentStrokeRef.current.points.push({ x, y });
                ctx.save();
                ctx.lineTo(x, y);
                ctx.stroke();
                ctx.restore();
            }, []);

            const stopDrawing = useCallback((e, ref) => {
                const canvas = ref.current;
                if (canvas) {
                    // Pointer-Counter runterzählen (auch wenn nicht gezeichnet wurde)
                    const st = getCanvasPointerState(canvas);
                    st.count = Math.max(0, (st.count || 0) - 1);
                    updateCanvasTouchAction(canvas, st.count);
                }

                if (!isDrawingRef.current) return;
                if (!canvas) return;

                isDrawingRef.current = false;
                const finishedStroke = currentStrokeRef.current;
                currentStrokeRef.current = null;

                if (finishedStroke && finishedStroke.points.length > 1) {
                    let key = null;
                    if (ref === canvasRef) key = 'main';
                    else if (ref === sitCanvasRef_Kundenname) key = 'sit_Kundenname';
                    else if (ref === sitCanvasRef_Rufnummer) key = 'sit_Rufnummer';
                    else if (ref === sitCanvasRef_Anbieter) key = 'sit_Anbieter';
                    else if (ref === sitCanvasRef_Hardware) key = 'sit_Hardware';
                    else if (ref === sitCanvasRef_Nutzung) key = 'sit_Nutzung';
                    else if (ref === sitCanvasRef_Haushalt) key = 'sit_Haushalt';
                    else if (ref === sitCanvasRef_WeitereProdukte) key = 'sit_WeitereProdukte';
                    else if (ref === sitCanvasRef_Fernsehen) key = 'sit_Fernsehen';
                    else if (ref === sitCanvasRef_WiFi) key = 'sit_WiFi';
                    else if (ref === sitCanvasRef_Gesamtkosten) key = 'sit_Gesamtkosten';
                    else if (ref === emailCanvasRef) key = 'email';
                    else if (ref === providerCanvasRef) key = 'provider';
                    else if (ref === notesCanvasRef) key = 'notes';
                    else if (ref === offerCanvasRef1) key = 'offer1';
                    else if (ref === offerCanvasRef2) key = 'offer2';
                    else if (ref === offerCanvasRef3) key = 'offer3';
                    else if (ref === offerCost1Ref) key = 'cost_einmalig';
                    else if (ref === offerCost2Ref) key = 'cost_monatlich1';
                    else if (ref === offerCost3Ref) key = 'cost_monatlich2';
                    else if (ref === offerAgentRef) key = 'agent_name';
                    else if (ref === offerDateRef) key = 'date_field';
                    else if (ref === offerValidUntilRef || ref === offerValidUntilModalRef) key = 'offer_valid_until';
                    else if (ref === skipReasonCanvasRef) key = 'skip_reason';

                    if (key) {
                        setDrawnStrokes(prev => ({ ...prev, [key]: [...(prev[key] || []), finishedStroke] }));
                        if (key.startsWith('offer')) { setRedrawCounter(r => r + 1); }
                    }
                }

                const ctx = canvas.getContext('2d');
                ctx.restore();
            }, [setDrawnStrokes]);

const CostBar = ({ val, total, colorClass }) => { const pct = total > 0 ? (val / total) * 100 : 0; return (<div className="h-1.5 w-full bg-slate-100 rounded-full mt-1 overflow-hidden"><div className={`h-full ${colorClass} transition-all duration-500`} style={{ width: `${pct}%` }}></div></div>); };
            const toggleTech = (val) => setShowTechModal(val);
                        const penModes = [
  { id: 'pen', Icon: ICONS.Pen, c: 'bg-blue-100 text-blue-600', title: 'Stift' },
  { id: 'fountain', Icon: ICONS.Fountain, c: 'bg-indigo-100 text-indigo-600', title: 'Füller' },
  { id: 'ballpen', Icon: ICONS.Ballpen, c: 'bg-slate-100 text-slate-700', title: 'Kugelschreiber' },
];
const otherTools = [
  { id: 'highlighter', Icon: ICONS.Highlighter, c: 'bg-yellow-100 text-yellow-600', title: 'Textmarker' },
  { id: 'eraser', Icon: ICONS.EraserLine, c: 'bg-slate-100 text-slate-600', title: 'Radierer' },
];

const isPenMode = (t) => (t === 'pen' || t === 'fountain' || t === 'ballpen');

const getPenBtnStyle = () => {
  if (tool === 'fountain') return 'bg-indigo-100 text-indigo-600';
  if (tool === 'ballpen') return 'bg-slate-100 text-slate-700';
  return 'bg-blue-100 text-blue-600'; // pen default
};

const handlePenButtonClick = () => {
  const now = Date.now();
  const dt = now - (lastPenTapRef.current || 0);
  lastPenTapRef.current = now;

  // Double-tap: open/close picker (like color palette)
  if (dt > 0 && dt < 350) {
    setShowPenToolPicker(v => !v);
    return;
  }

  // Single tap: just select default pen and close picker
  setTool('pen');
  setShowPenToolPicker(false);
};

// Close picker on outside click
useEffect(() => {
  if (!showPenToolPicker) return;
  const onDown = (e) => {
    const host = e.target?.closest?.('.pen-tool-picker-host');
    if (!host) setShowPenToolPicker(false);
  };
  window.addEventListener('pointerdown', onDown, { capture: true });
  return () => window.removeEventListener('pointerdown', onDown, { capture: true });
}, [showPenToolPicker]);

const renderPenToolButtons = () => (
  <>
    <div className="relative pen-tool-picker-host">
      <button
        onClick={handlePenButtonClick}
        className={`p-2 rounded-md ${isPenMode(tool) ? getPenBtnStyle() : 'text-slate-400 hover:bg-slate-50'}`}
        title="Stift (Doppeltipp = Auswahl)"
      >
        <Icon d={tool === 'fountain' ? ICONS.Fountain : tool === 'ballpen' ? ICONS.Ballpen : ICONS.Pen} size={16} />
      </button>

      {showPenToolPicker && (
        <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-3 bg-white p-3 rounded-xl shadow-2xl border border-slate-200 grid grid-cols-3 gap-2 w-[240px] z-[120]">
          <div className="col-span-3 text-[10px] font-bold text-slate-400 uppercase tracking-wider text-center mb-1">
            Stift wählen
          </div>
          {penModes.map(pm => (
            <button
              key={pm.id}
              onClick={() => { setTool(pm.id); setShowPenToolPicker(false); }}
              className={`flex flex-col items-center justify-center gap-1 p-2 rounded-lg border ${tool === pm.id ? 'border-slate-300 bg-slate-50' : 'border-slate-200 hover:bg-slate-50'}`}
              title={pm.title}
            >
              <span className={`w-9 h-9 rounded-lg flex items-center justify-center ${pm.c}`}>
                <Icon d={pm.Icon} size={18} />
              </span>
              <span className="text-[10px] font-extrabold text-slate-700">{pm.title}</span>
            </button>
          ))}
        </div>
      )}
    </div>

    {otherTools.map(t => (
      <button
        key={t.id}
        onClick={() => { setTool(t.id); setShowPenToolPicker(false); }}
        className={`p-2 rounded-md ${tool === t.id ? t.c : 'text-slate-400 hover:bg-slate-50'}`}
        title={t.title}
      >
        <Icon d={t.Icon} size={16} />
      </button>
    ))}
  </>
);

            const handleOfferCostChange = (key, value) => {
                try { if (inputMode === 'keyboard') { digitalTouchedRef.current[`cost_${key}`] = true; } } catch(e){}
                const cleanValue = value.replace(',', '.');
                let val = parseFloat(cleanValue);
                const rawKey = `${key}Raw`;
                setOfferData(prev => ({ ...prev, [rawKey]: value, [key]: isNaN(val) || value.trim() === '' ? 0 : val }));
            };
            const renderOfferInput = (key, labelKey, type = 'text') => { let ref, rawValue, strokesKey; const label = getStaticLabel(labelKey); if (key === 'einmalig' || key === 'monatlich1' || key === 'monatlich2') { ref = (key === 'einmalig' ? offerCost1Ref : key === 'monatlich1' ? offerCost2Ref : offerCost3Ref); rawValue = offerData[`${key}Raw`] ?? ''; strokesKey = `cost_${key}`; } else if (key === 'agent') { ref = offerAgentRef; rawValue = getDisplayText('AgentName'); strokesKey = 'agent_name'; } else if (key === 'datum') { ref = offerDateRef; rawValue = getDisplayText('DateValue'); strokesKey = 'date_field'; } else if (key === 'gueltig') { ref = offerValidUntilRef; rawValue = getDisplayText('OfferValidUntil'); strokesKey = 'offer_valid_until'; } const isCostField = key.startsWith('monatlich') || key === 'einmalig'; const handleChange = (e) => { if (isCostField) { handleOfferCostChange(key, e.target.value); } else if (key === 'agent') { handleTextChange('AgentName', e.target.value); } else if (key === 'datum') { handleTextChange('DateValue', e.target.value); } else if (key === 'gueltig') { handleTextChange('OfferValidUntil', e.target.value); } }; const inputHeightClass = 'h-12'; return (<div className="flex flex-col"><label className="text-xs font-bold text-slate-500 uppercase tracking-wider mb-1">{label}</label><div className={`relative ${inputHeightClass} ${isCostField ? 'bg-slate-50' : 'bg-white'} border border-slate-300 rounded-lg`}>{inputMode === 'pen' ? (<SmallInputCanvas inputMode={inputMode} canvasRef={ref} inputKey={strokesKey} inputValue={rawValue} placeholder={label.split(' ')[0]} drawnStrokes={drawnStrokes} setDrawnStrokes={setDrawnStrokes} startDrawing={startDrawing} draw={draw} stopDrawing={stopDrawing} triggerRedraw={redrawCounter}/>) : (() => { const showDigital = !!digitalTouchedRef.current[strokesKey]; const displayValue = showDigital ? rawValue : ''; const hasInk = !!(drawnStrokes[strokesKey] && drawnStrokes[strokesKey].length); if (!showDigital && hasInk) { return (<canvas ref={ref} className="absolute inset-0 w-full h-full drawing-canvas" style={{ pointerEvents: 'none', touchAction: 'none', background: 'transparent' }} />); } return (<input type={type} value={displayValue} onChange={handleChange} placeholder={label.split(' ')[0]} className={`w-full h-full px-3 text-base font-medium focus:ring-1 focus:ring-blue-300 transition-colors focus:outline-none ${isCostField ? 'offer-cost-input text-xl font-black text-slate-800 bg-transparent' : 'offer-meta-input text-slate-700 bg-transparent'}`}/>); })()}</div></div>); };
            
            const handleLocalTranslation = useCallback((targetCode) => { if (targetCode === 'de') return; const mockData = MOCK_TRANSLATIONS[targetCode]; if (mockData) { const newTranslatedText = {}; const newStaticTranslations = {}; Object.keys(STATIC_LABELS).forEach(key => { if (mockData[key]) { newStaticTranslations[key] = mockData[key]; } }); Object.keys(textData).forEach(key => { if (mockData[key]) { newTranslatedText[key] = mockData[key]; } }); setTranslatedText(prev => ({ ...prev, [targetCode]: { ...(prev[targetCode] || {}), ...newTranslatedText } })); setStaticTranslations(prev => ({ ...prev, [targetCode]: { ...(prev[targetCode] || {}), ...newStaticTranslations } })); if (mockData.AgentName) handleTextChange('AgentName', mockData.AgentName); if (mockData.DateValue) handleTextChange('DateValue', mockData.DateValue); triggerToast(`Lokale (Mock) Übersetzung geladen: ${targetCode.toUpperCase()}.`); } else { triggerToast(`Für ${targetCode.toUpperCase()} ist keine lokale Mock-Übersetzung verfügbar. Standard-Deutsch wird verwendet.`); } }, [triggerToast, textData, handleTextChange]); 
            useEffect(() => { if (displayLanguage !== 'de') { if (!staticTranslations[displayLanguage] || !translatedText[displayLanguage]) { handleLocalTranslation(displayLanguage); } } }, [displayLanguage, handleLocalTranslation, translatedText, staticTranslations]);


// --- OneDrive Auto-Upload Helpers ---
// PDF im "Print-Look" als Blob erzeugen (ohne Print-Dialog). Wiederverwendet von Share + Auto-Upload.

// PDF im "Print-Look" als Blob erzeugen (ohne Print-Dialog). Wiederverwendet von Share + Auto-Upload.
const createPrintLookPdfBlob = async (triggerToast, ensurePrintHeaders, opts = {}) => {
    if (!window.html2pdf) throw new Error('html2pdf missing');

    const addPageNumbers = false; // FIX: kein "Seite X / N" im Share-PDF

    // --- SHARE HARD-LOCK (v50_52): exakt links/rechts bündig, kein Cut ---
// Ziel: Share-PDF soll exakt die Inhaltsbreite nutzen (keine Offsets, kein Extra-Padding, keine Skalierung)
const SHARE_PAGE_WIDTH_PX  = 1122; // Share-safe width (A4 landscape @ 96dpi) // Share-safe width (prevents right-edge cut)
const SHARE_PAGE_HEIGHT_PX = 794;
const SHARE_DOC_WIDTH_PX   = SHARE_PAGE_WIDTH_PX;
const SHARE_SAFE_SCALE     = 1.0; // keep size; CSS share-mode adds its own safety // extra safety to prevent any right-edge clipping
const SHARE_OFFSET_Y_PX  = 0; // Share: keep at 0 (prevents page-cut) // Share: pushes PDF content down (px). Increase if top is too tight.

    try { if (typeof ensurePrintHeaders === 'function') ensurePrintHeaders(); } catch(e){}

    const sourceSituation = document.querySelector('.situation-view-wrapper');
    const sourceOffer = document.querySelector('.print-offer-view');
    if (!sourceOffer || !sourceSituation) throw new Error('print views not found');

    // Offscreen-Iframe
    const iframe = document.createElement('iframe');
    iframe.setAttribute('aria-hidden', 'true');
    iframe.style.cssText = `position:fixed;left:-99999px;top:0;width:${SHARE_DOC_WIDTH_PX}px;height:6500px;opacity:0;pointer-events:none;`;
    document.body.appendChild(iframe);

    const doc = iframe.contentDocument;
    doc.open();
    doc.write('<!doctype html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"></head><body></body></html>');
    doc.close();

    // Share-PDF: eigener Modus im Iframe
    try { doc.body.classList.add('pdf-share-mode');

                    // Hard-override gegen Landscape-Fullscreen-Shift (nur Share-PDF)
                    const __centerStyle = clonedDoc.createElement('style');
                    __centerStyle.textContent = `
                      body.pdf-share-mode{ --FULLSCREEN_SHIFT_X: 0px !important; }
                      @media (orientation: landscape) and (min-width: 1100px){
                        body.pdf-share-mode .situation-view-wrapper,
                        body.pdf-share-mode .print-situation-view,
                        body.pdf-share-mode .print-offer-view{ transform: none !important; }
                      }
                      body.pdf-share-mode .print-page,
                      body.pdf-share-mode .page{
                        width: ${1122}px !important;
                        max-width: ${1122}px !important;
                        margin-left: auto !important;
                        margin-right: auto !important;
                      }
                    `;
                    clonedDoc.head.appendChild(__centerStyle);

                    // Hide voucher / Gutscheincode area during export (prevents it showing in screenshot/PDF)
                    try {
                        const txt = (el) => (el && (el.textContent || el.innerText) || '').toLowerCase();
                        const all = Array.from(clonedDoc.querySelectorAll('div,section,article,p,span,strong,small,label,h1,h2,h3,h4'));
                        const hit = all.find(n => txt(n).includes('gutscheincode') || txt(n).includes('gutschein'));
                        if (hit) {
                            // hide nearest "row/card/section" container
                            const box = hit.closest('section, article, .card, .rounded-xl, .border, .p-4, .p-6, div') || hit;
                            box.style.display = 'none';
                        }
                    } catch(e){}
                    // Force exact colors inside clone
                    try { clonedDoc.querySelectorAll('*').forEach(el => { el.style.webkitPrintColorAdjust='exact'; el.style.printColorAdjust='exact'; }); } catch(e){}
 } catch(e){}

    // Styles kopieren und Print-Regeln immer aktiv machen
    const styles = Array.from(document.querySelectorAll('style'))
        .map(s => s.textContent || '')
        .filter(Boolean)
        .join('\n\n');
    const stylesPrintAll = styles.replace(/@media\s+print/g, '@media all');

    const styleEl = doc.createElement('style');
    styleEl.textContent =
        stylesPrintAll + "\n\n" +
        `html,body{background:#fff;margin:0;padding:0;width:${SHARE_DOC_WIDTH_PX}px;max-width:${SHARE_DOC_WIDTH_PX}px;overflow:hidden;height:auto;}
         html{height:auto;}
         /* Share-Modus: Header sichtbar, keine doppelten Links-Offsets innerhalb der Views */
         .pdf-share-mode .print-page-header{display:flex !important;}
         /* Share: eigene Seitensteuerung (verhindert Leer-Seiten durch doppelte Pagebreaks) */
         body.pdf-share-mode .situation-view-wrapper,
         body.pdf-share-mode .print-offer-view,
         body.pdf-share-mode .share-cover,
         body.pdf-share-mode .share-outro{
           break-after:auto !important;
           page-break-after:auto !important;
         }
         /* Optional: falls irgendwo legacy page-break-before gesetzt ist */
         body.pdf-share-mode .situation-view-wrapper,
         body.pdf-share-mode .print-offer-view,
         body.pdf-share-mode .share-cover,
         body.pdf-share-mode .share-outro{
           break-before:auto !important;
           page-break-before:auto !important;
         }

.pdf-share-mode .share-page{break-after:page; page-break-after:always; width:297mm; max-width:297mm; height:210mm; min-height:210mm; max-height:210mm; display:flex; flex-direction:column; box-sizing:border-box; overflow:hidden;}
         .pdf-share-mode .share-page-header{flex:0 0 16mm; height:16mm; min-height:16mm; max-height:16mm; box-sizing:border-box;}
         .pdf-share-mode .share-page-content{flex:1 1 auto; min-height:0; height:calc(210mm - 16mm); overflow:hidden; box-sizing:border-box;}
         .pdf-share-mode .share-cover,.pdf-share-mode .share-outro{height:100% !important; min-height:100% !important; max-height:100% !important; box-sizing:border-box;}

         .pdf-share-mode .share-page:last-child{break-after:auto !important; page-break-after:auto !important;}
         .pdf-share-mode .situation-view-wrapper{padding-left: 0px !important; padding-top:0 !important; margin-left:0 !important;}
         .pdf-share-mode .print-offer-view{padding-left:0 !important; padding-top:0 !important; margin-left:0 !important;}
         .pdf-share-mode body{background:#eff6ff !important;}
         /* Share: Fallback-Header-Styling (falls Print-CSS nicht sauber kopiert wird) */
         .pdf-share-mode header{display:none !important;}
         .pdf-share-mode .print-page-header{display:flex !important;align-items:center;justify-content:space-between;gap:12px;padding:10px 14px;background:#eff6ff !important;border:1px solid #e2e8f0;border-radius:14px;margin:0 0 10px 0;}
         .pdf-share-mode .print-page-header .title{font-size:28px;font-weight:900;color:#0b1e42;letter-spacing:-0.02em;}
         .pdf-share-mode .print-page-header .print-header-right{display:flex;align-items:center;gap:10px;}
         .pdf-share-mode .print-page-header .hida-logo-print{height:34px;width:auto;
         /* === A4-Hardlock (mm) nur für Share-PDF (entkoppelt vom Monitor) === */
         .pdf-share-mode .share-page,
         .pdf-share-mode .share-cover,
         .pdf-share-mode .share-feedback-page,
         .pdf-share-mode .situation-view-wrapper,
         .pdf-share-mode .print-offer-view{
           width:297mm !important;
           min-width:297mm !important;
           max-width:297mm !important;
           height:210mm !important;
           min-height:210mm !important;
           box-sizing:border-box !important;
           overflow:hidden !important;
         }
         .pdf-share-mode .share-pdf-container{
           width:297mm !important;
           max-width:297mm !important;
           margin:0 !important;
           padding:0 !important;
           overflow:hidden !important;
         }
         /* Spalten fix für Seite 2 & 3 */
         .pdf-share-mode .situation-view-wrapper{padding:10mm !important; gap:6mm !important;}
         .pdf-share-mode .print-offer-view{padding:10mm !important; gap:6mm !important;}
         .pdf-share-mode .situation-view-wrapper > div.flex-1,
         .pdf-share-mode .print-offer-view > div.flex-1{
           flex:0 0 190mm !important;
           width:190mm !important;
           max-width:190mm !important;
         }
         .pdf-share-mode .situation-view-wrapper > aside,
         .pdf-share-mode .print-offer-view > aside{
           display:block !important;
           flex:0 0 77mm !important;
           width:77mm !important;
           max-width:77mm !important;
         }

         
         /* --- FINAL 4-SEITEN SHARE (TEILEN) --- */
/* Seite 3 (Angebot+Kosten) kompakt halten, damit nichts in eine 5. Seite läuft */
.pdf-share-mode .print-offer-view{
  display:flex !important;
  flex-direction:column !important;
  zoom:0.78 !important;
  height:210mm !important;
  min-height:210mm !important;
  max-height:210mm !important;
  overflow:hidden !important;
}
.pdf-share-mode .print-offer-view .offer-canvas-container{
  min-height:420px !important;
  max-height:420px !important;
  margin-bottom:8px !important;
  break-inside:avoid !important;
}
.pdf-share-mode .print-offer-view .cost-overview-print{
  padding:8px 10px !important;
  margin-top:0 !important;
  break-inside:avoid !important;
}
.pdf-share-mode .cost-grid-years{
  display:grid !important;
  grid-template-columns:repeat(3, 1fr) !important;
  gap:6px !important;
}

/* Seite 4: Full-Bleed Outro (ohne Header) */
.pdf-share-mode .share-outro{
  width:297mm !important;
  height:210mm !important;
  padding:0 !important;
  margin:0 !important;
  display:flex !important;
  flex-direction:column !important;
  justify-content:center !important;
  overflow:hidden !important;
}
.pdf-share-mode .share-outro .print-page-header{ display:none !important; }

/* Harte Trennung erzwingen (falls irgendwo legacy-breaks fehlen) */
         .pdf-share-mode .pdf-page-break{
           break-after:page !important;
           page-break-after:always !important;
         }

/* ===== Share: Seitenzähler (nur im Share-Iframe) ===== */

         /* ===== Share: ZENTRIER-FIX (Seite 2/3 nicht links kleben) ===== */
         .pdf-share-mode .share-safe-stage{
           width:100% !important;
           display:flex !important;
           flex-direction:column !important;
           align-items:center !important;
         }
         .pdf-share-mode .share-page{
           margin-left:auto !important;
           margin-right:auto !important;
         }

         .pdf-share-mode .share-page{position:relative !important;}
         .pdf-share-mode .share-page-number{
           display:none !important;

           position:absolute !important;
           right:10mm !important;
           bottom:8mm !important;
           z-index:50 !important;
           font-family: Arial, Helvetica, sans-serif !important;
           font-size:10px !important;
           font-weight:800 !important;
           letter-spacing:0.02em !important;
           color:#64748b !important;
           background:rgba(255,255,255,0.88) !important;
           border:1px solid #e2e8f0 !important;
           border-radius:999px !important;
           padding:3px 8px !important;
           line-height:1 !important;
         }

         object-fit:contain;}`;




    const base = doc.createElement('base');
    base.href = window.location.href;
    doc.head.appendChild(base);

    // Container: hier passiert die echte Verschiebung (einmalig, stabil)
    const container = doc.createElement('div');
// Container = exakte Seitenbreite (keine Innen-Paddings/Offsets)
container.style.cssText =
    `background:#fff;width:${SHARE_DOC_WIDTH_PX}px;max-width:${SHARE_DOC_WIDTH_PX}px;margin:0 auto;` +
    `box-sizing:border-box;padding:0;overflow:hidden;height:auto;`;

// Stage = 1:1 Breite, zentriert (kein Scale/Shift)
const stage = doc.createElement('div');
stage.className = 'share-safe-stage';
stage.style.cssText =
    `width:${SHARE_PAGE_WIDTH_PX}px;max-width:${SHARE_PAGE_WIDTH_PX}px;margin:0 auto;` +
    `height:auto;overflow:hidden;` +
    `transform:scale(${SHARE_SAFE_SCALE});transform-origin:top left;`;


doc.body.appendChild(container);
container.appendChild(stage);


    // Inhalt klonen

    // --- Share: Seiten-Wrapping + Header im Iframe (robust für html2pdf) ---
const makeShareHeader = (titleText) => {
    const h = doc.createElement('div');
    h.className = 'share-page-header print-page-header';
    const t = doc.createElement('div');
    t.className = 'title';
    t.textContent = titleText;

    const right = doc.createElement('div');
    right.className = 'print-header-right';
    const img = doc.createElement('img');
    img.src = HIDA_LOGO_DATA_URI;
    img.alt = 'HIDA';
    img.className = 'hida-logo-print';
    right.appendChild(img);

    h.appendChild(t);
    h.appendChild(right);
    return h;
};

const wrapSharePage = (titleText, contentEl, opts = {}) => {
    const page = doc.createElement('div');
    page.className = 'share-page';
    // WICHTIG: feste A4-Landscape-Seitengröße im Share-PDF (inline wins!)
    page.style.cssText = 'width:297mm;max-width:297mm;height:210mm;min-height:210mm;max-height:210mm;box-sizing:border-box;overflow:hidden;';
    const includeHeader = !(opts && opts.includeHeader === false);
    if (includeHeader) {
        const header = makeShareHeader(titleText);
        header.classList.add('share-page-header');
        page.appendChild(header);
    }

    const contentWrap = doc.createElement('div');
    contentWrap.className = 'share-page-content';
    // Inhalt darf nie "in die nächste Seite laufen"
    contentWrap.style.cssText = includeHeader
        ? 'flex:1 1 auto;min-height:0;height:calc(210mm - 16mm);overflow:hidden;box-sizing:border-box;'
        : 'flex:1 1 auto;min-height:0;height:210mm;overflow:hidden;box-sizing:border-box;';
    contentWrap.appendChild(contentEl);

    page.appendChild(contentWrap);
    return page;
};


// ===== Share-PDF: Canvas-Inhalte "einbrennen" (Canvas-Bitmap wird beim cloneNode NICHT kopiert) =====
const bakeCanvasesIntoClone = (srcRoot, cloneRoot) => {
    try {
        if (!srcRoot || !cloneRoot) return;
        const src = Array.from(srcRoot.querySelectorAll('canvas'));
        const dst = Array.from(cloneRoot.querySelectorAll('canvas'));
        const n = Math.min(src.length, dst.length);
        for (let i = 0; i < n; i++) {
            const sc = src[i];
            const dc = dst[i];
            if (!sc || !dc) continue;

            // Versuche Bitmap zu exportieren
            let dataUrl = null;
            try { dataUrl = sc.toDataURL('image/png'); } catch(e) { dataUrl = null; }
            if (!dataUrl || dataUrl.length < 50) continue;

            const img = doc.createElement('img');
            img.src = dataUrl;
            img.alt = 'canvas';
            img.className = (dc.className || '') + ' canvas-baked-image';
            // Übernimm die wichtigsten Layout-Eigenschaften des Canvas
            img.style.cssText = (dc.getAttribute('style') || '') + ';' +
                'position:absolute;inset:0;width:100%;height:100%;object-fit:contain;pointer-events:none;touch-action:none;';
            // Canvas im Clone ausblenden, Image darüber legen
            try { dc.style.visibility = 'hidden'; } catch(e){}
            try { dc.parentNode && dc.parentNode.insertBefore(img, dc.nextSibling); } catch(e){}
        }
    } catch(e) {
        // silent (Share muss immer funktionieren)
    }
};

// Inhalt klonen + Print-Header im Clone entfernen (wir setzen den Header oben im Wrapper)
const cloneSituation = sourceSituation.cloneNode(true);
try { cloneSituation.classList.remove('hidden'); } catch(e){}
cloneSituation.querySelectorAll('.print-page-header').forEach(n => n.remove());
cloneSituation.querySelectorAll('#pdf-share-overlay,.print-hide-toast').forEach(n => n.remove());
cloneSituation.style.display = 'flex';
cloneSituation.style.height = '100%';
cloneSituation.style.maxHeight = '100%';
cloneSituation.style.overflow = 'hidden';

// Canvas-Bitmaps aus dem Original in den Clone übernehmen (wichtig für Share/PDF)
bakeCanvasesIntoClone(sourceSituation, cloneSituation);


// --- Share: COVER + OUTRO (nur beim Teilen, nicht beim Drucken) ---
const pad2 = (n) => String(n).padStart(2,'0');
const now = new Date();
const yy = String(now.getFullYear()).slice(-2);
const mm = pad2(now.getMonth()+1);
const dd = pad2(now.getDate());
const shareDateDisplay = now.toLocaleDateString('de-DE', { day:'2-digit', month:'2-digit', year:'numeric' });
const voucherCode = `CRA-o2-${yy}/${mm}/${dd}`;

// Simple QR (remote) – falls offline/blocked, bleibt das Feld leer, Textlink bleibt sichtbar
const qrUrl = (data, color='001942') => `https://api.qrserver.com/v1/create-qr-code/?size=260x260&data=${encodeURIComponent(data)}&color=${color}&bgcolor=ffffff&margin=1`;

const makeCoverContent = () => {
    const wrap = doc.createElement('div');
    wrap.className = 'share-cover';
    wrap.innerHTML = `
      <div class="share-cover-inner">
        <div class="share-cover-badge">EXKLUSIV FÜR SIE ERSTELLT</div>
        <div class="share-cover-title">
          <div>Ihr persönliches</div>
          <div class="share-cover-title-accent">Angebot</div>
        </div>
        <div class="share-cover-date">VOM ${shareDateDisplay}</div>

        <div class="share-cover-card">
          <div class="share-cover-chip">CRAILSHEIM</div>
          <div class="share-cover-shop">
            <div class="share-cover-shop-name">o2 Shop Crailsheim</div>
            <div class="share-cover-shop-addr">Karlstraße 37, 74564 Crailsheim</div>
          </div>
        </div>
      </div>
    `;
    return wrap;
};

const makeOutroContent = () => {
    const wrap = doc.createElement('div');
    wrap.className = 'share-outro';
    const googleReviewUrl = (window.GOOGLE_REVIEW_URL || 'https://share.google/IWbGLWPI83ByOirz1');
    const instagramUrl = (window.INSTAGRAM_URL || 'https://www.instagram.com/o2shop_crailsheim/');
    wrap.innerHTML = `
      <div class="share-outro-grid">
        <div class="share-outro-card">
          <div class="share-outro-icon">★</div>
          <div class="share-outro-h">Kurzes Feedback?</div>
          <div class="share-outro-p">Zufrieden mit der Beratung?<br/>Wir freuen uns über 5 Sterne!</div>
          <div class="share-outro-qr">
            <img crossorigin="anonymous" referrerpolicy="no-referrer" src="${qrUrl(googleReviewUrl,'0050ff')}" alt="QR Google" />
          </div>
          <div class="share-outro-link">${googleReviewUrl}</div>
        </div>

        <div class="share-outro-card share-outro-card-focus">
          <div class="share-outro-icon">🎟️</div>
          <div class="share-outro-h">Dankeschön</div>
          <div class="share-outro-amount">10 €</div>
          <div class="share-outro-p">Zubehör-Bonus<br/><span class="share-outro-small">Einlösbar für hochwertige Schutzfolien direkt bei uns.</span></div>
          <div class="share-outro-voucher">${voucherCode}</div>
          <div class="share-outro-small">* Nur im Shop vor Ort für Folien einlösbar.</div>
        </div>

        <div class="share-outro-card">
          <div class="share-outro-icon">⌁</div>
          <div class="share-outro-h">Folgen & Sparen</div>
          <div class="share-outro-p">News, Gewinnspiele und Deals<br/>direkt aus Crailsheim.</div>
          <div class="share-outro-qr">
            <img crossorigin="anonymous" referrerpolicy="no-referrer" src="${qrUrl(instagramUrl,'bc1888')}" alt="QR Insta" />
          </div>
          <div class="share-outro-link">@o2shop_crailsheim</div>
          <div class="share-outro-link">${instagramUrl}</div>
        </div>
      </div>
    `;
    return wrap;
};

// Cover als erste Seite
const coverPage = wrapSharePage('Ihre Angebotsmappe', makeCoverContent(), { includeHeader: false });
stage.appendChild(coverPage);

const page1 = wrapSharePage('Ihre Aktuelle Situation', cloneSituation);
stage.appendChild(page1);

// Angebot klonen (FINAL v7: Kostenübersicht wandert auf Seite 4 nach ganz oben)
const cloneOfferAll = sourceOffer.cloneNode(true);
cloneOfferAll.querySelectorAll('.print-page-header').forEach(n => n.remove());
cloneOfferAll.querySelectorAll('#pdf-share-overlay,.print-hide-toast').forEach(n => n.remove());
cloneOfferAll.style.display = 'block';
cloneOfferAll.style.height = '100%';
cloneOfferAll.style.maxHeight = '100%';
cloneOfferAll.style.overflow = 'hidden';

// Canvas-Bitmaps aus dem Original in den Clone übernehmen (wichtig für Share/PDF)
bakeCanvasesIntoClone(sourceOffer, cloneOfferAll);


// ✅ Kostenübersicht aus Seite 3 entfernen und für Seite 4 aufheben
let costBlock = null;
try {
    costBlock = cloneOfferAll.querySelector('.cost-overview-print');
    if (costBlock) costBlock.remove();
} catch(e){}

// Seite 3: Angebot OHNE Kosten
const page2 = wrapSharePage('Ihr Persönliches Angebot', cloneOfferAll);
stage.appendChild(page2);

// Seite 4: Kostenübersicht & Abschluss ganz oben + danach der blaue Bereich
const outroContentWrap = doc.createElement('div');
outroContentWrap.style.cssText = 'width:100%;height:100%;display:flex;flex-direction:column;gap:16px;box-sizing:border-box;overflow:hidden;';

if (costBlock) {
    // Kostenblock oben (weiß), kompakt und ohne Umbruch
    costBlock.style.display = 'block';
    costBlock.style.breakInside = 'avoid';
    costBlock.style.pageBreakInside = 'avoid';
    costBlock.style.margin = '0';
    outroContentWrap.appendChild(costBlock);
}

outroContentWrap.appendChild(makeOutroContent());

// Outro als letzte Seite (ohne Header)
const outroPage = wrapSharePage('Danke & Bonus', outroContentWrap, { includeHeader: false });
stage.appendChild(outroPage);

// Share: Seitenzähler deaktiviert (Fix: kein "Seite X / N")

    // Layout settle
    await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));

    // A4 Landscape in points
    const A4_LANDSCAPE_PT = [841.89, 595.28];

    const SHARE_SCROLL_H = Math.max(
        doc.documentElement?.scrollHeight || 0,
        doc.body?.scrollHeight || 0,
        container?.scrollHeight || 0
    ) + 80;

    
    // === HARD-FIX: IGNORE/REMOVE EXTRA SHARE PAGE(S) ===
    // Some browsers force an additional blank/strip page (e.g., only a blue bar).
    // We strictly export ONLY the first 4 pages in Share-PDF mode.
    try {
        const pages = Array.from(doc.querySelectorAll('.share-page'));
        if (pages.length > 4) {
            pages.slice(4).forEach(p => { try { p.remove(); } catch(_){} });
        }
    } catch(e) { /* ignore */ }

const opt = {
        margin: 0,
        filename: `Angebot_HIDA_${new Date().toISOString().split('T')[0]}.pdf`,
        pagebreak: { mode: ['css', 'legacy'] },
        image: { type: 'jpeg', quality: 1.0 },
        html2canvas: {
            scale: 2,
            useCORS: true,
            allowTaint: true,
            backgroundColor: '#ffffff',
            // A4-Querformat @ 96dpi als stabiler "virtueller Viewport"
            width: 1122,
            windowWidth: 1122,
            scrollX: 0,
            scrollY: 0,
            x: 0,
            y: 0,
            logging: false,
            onclone: function(clonedDoc) {
                try{
                    const html = clonedDoc.documentElement;
                    const body = clonedDoc.body;

                    // Share-PDF: komplett von echter Fenstergröße/Zoom entkoppeln
                    // WICHTIG: html2canvas arbeitet in PX. mm-Werte führen hier leicht zu Versatz/Cropping.
                    const PAGE_W = 1122; // A4 landscape @96dpi (dein bewährtes Setup)
                    const PAGE_H = 794;

                    html.style.width = PAGE_W + 'px';
                    html.style.minWidth = PAGE_W + 'px';
                    html.style.maxWidth = PAGE_W + 'px';
                    html.style.overflow = 'hidden';

                    body.style.width = '100%';
                    body.style.margin = '0';
                    body.style.padding = '0';
                    body.style.overflow = 'hidden';

                    // Zentrierung: der Clone-Body wird zum Flex-Wrapper (nur Share-PDF)
                    body.style.display = 'flex';
                    body.style.justifyContent = 'center';
                    body.style.alignItems = 'flex-start';

                    body.classList.add('pdf-share-mode');

                    const c = clonedDoc.querySelector('.share-pdf-container');
                    if(c){
                        c.style.width = PAGE_W + 'px';
                        c.style.maxWidth = PAGE_W + 'px';
                        c.style.marginLeft = 'auto';
                        c.style.marginRight = 'auto';
                        c.style.padding = '0';
                        c.style.overflow = 'hidden';
                    }

                    // =========================================================
                    // PDF-SHARE COLORS + FULL-BACKGROUNDS (nur html2pdf-Clone)
                    // - erzwingt Hintergrundgrafiken/Farben wie bei STRG+P
                    // - macht Cover/Outro 100% Seitenhöhe (kein Weiß unten)
                    // - verhindert eine leere "Extra-Seite" am Ende
                    // =========================================================
                    const style = clonedDoc.createElement('style');
                    style.id = 'pdf-share-force-colors-v1';
                    style.textContent = `
                        html, body{
                            margin:0 !important;
                            padding:0 !important;
                            background:#eff6ff !important;
                            -webkit-print-color-adjust: exact !important;
                            print-color-adjust: exact !important;
                            color-adjust: exact !important;
                        }
                        *, *::before, *::after{
                            -webkit-print-color-adjust: exact !important;
                            print-color-adjust: exact !important;
                            color-adjust: exact !important;
                        }

                        /* Jede Share-Seite ist ein echtes A4-Landscape Blatt */
                        body.pdf-share-mode .share-page{
                            width:297mm !important;
                            max-width:297mm !important;
                            height:210mm !important;
                            min-height:210mm !important;
                            max-height:210mm !important;
                            margin:0 !important;
                            padding:0 !important;
                            overflow:hidden !important;
                            box-sizing:border-box !important;
                            background:#eff6ff !important;
                            box-shadow: inset 0 0 0 1000px #eff6ff !important;
                            break-after: page !important;
                            page-break-after: always !important;
                        }
                        body.pdf-share-mode .share-page:last-child{
                            break-after:auto !important;
                            page-break-after:auto !important;
                        }

                        /* Content darf nie "überlaufen" -> sonst kommt die leere Extra-Seite */
                        body.pdf-share-mode .share-page-content{
                            overflow:hidden !important;
                            box-sizing:border-box !important;
                        }

                        /* Cover/Outro MUSS volle Seitenhöhe bekommen */
                        body.pdf-share-mode .share-page-content > .share-cover,
                        body.pdf-share-mode .share-page-content > .share-outro{
                            height:100% !important;
                            min-height:100% !important;
                            max-height:100% !important;
                        }

                        /* Standard-Hintergrund der Inhaltsseiten (Seite 2/3) */
                        body.pdf-share-mode .situation-view-wrapper,
                        body.pdf-share-mode .print-offer-view{
                            background:#eff6ff !important;
                            background-color:#eff6ff !important;
                            box-shadow: inset 0 0 0 1000px #eff6ff !important;
                        }

                        /* Cover/Outro Gradient als "echte" Fläche erzwingen */
                        body.pdf-share-mode .share-cover,
                        body.pdf-share-mode .share-outro{
                            background: linear-gradient(135deg,#001942 0%,#0050ff 100%) !important;
                            background-color:#001942 !important;
                        }
                    `;
                    clonedDoc.head.appendChild(style);

                    
                // ===== Share/PDF ONLY (Clone): Side Header vertikal am rechten Seitenrand =====
                try {
                    // Inject clone-only CSS (does NOT touch web or STRG+P)
                    const shStyle = clonedDoc.createElement('style');
                    shStyle.innerHTML = `
                      body.pdf-share-mode 
                      body.pdf-share-mode 
                    `;
                    clonedDoc.head.appendChild(shStyle);

                    const ensureRel = (el) => {
                        const cs = clonedDoc.defaultView.getComputedStyle(el);
                        if (!cs.position || cs.position === 'static') el.style.position = 'relative';
                    };

                    const addSideHeader = (pageEl, text) => {
                        if (!pageEl || pageEl.querySelector('.side-header-vertical')) return;
                        ensureRel(pageEl);
                        const wrap = clonedDoc.createElement('div');
                        wrap.className = 'side-header-vertical';
                        const span = clonedDoc.createElement('span');
                        span.className = 'side-header-text';
                        span.textContent = text;
                        wrap.appendChild(span);
                        pageEl.appendChild(wrap);
                    };

                    // Attach to share-page so it sits in the free right margin area
                    const pages = Array.from(clonedDoc.querySelectorAll('.share-page'));
                    pages.forEach((p) => {
                        if (p.querySelector('.situation-view-wrapper')) addSideHeader(p, 'Ihre aktuelle Situation');
                        if (p.querySelector('.print-offer-view')) addSideHeader(p, 'Ihr persönliches Angebot');
                    });
                
                    // Entferne horizontale Titel (nur im Clone), aber lasse den seitlichen Rand-Header stehen
                    try {
                        const killExact = (txt) => {
                            const all = Array.from(clonedDoc.querySelectorAll('h1,h2,h3,div,span,p'));
                            all.forEach(el => {
                                const t = (el.textContent || '').trim();
                                if (t === txt && !el.closest('.side-header-vertical')) {
                                    // Nur "kopfzeilenartige" Elemente ausblenden (kleine Textknoten / keine tiefen Kinder)
                                    const isSimple = el.children.length <= 1;
                                    if (isSimple) el.style.display = 'none';
                                }
                            });
                        };
                        killExact('Ihre Aktuelle Situation');
                        killExact('Ihre aktuelle Situation');
                        killExact('Ihr Persönliches Angebot');
                        killExact('Ihr persönliches Angebot');
                    } catch(e) {}
} catch(e) {}
// ---- Rechte Header im freien Randbereich (nur Seite 2 & 3) ----
                    try{
                        const pagesHdr = Array.from(clonedDoc.querySelectorAll('.share-page'));
                        pagesHdr.forEach((pg, idx)=>{
                            // idx: 0=Cover, 1=Seite2, 2=Seite3, 3=Seite4...
                            /* Share/PDF: Top-Header entfernt – nur seitlicher Rand-Header */

                        });
                    }catch(e){}


                                        // ===== Share/PDF: Top-Header Cleanup (falls vorhanden) =====
                    try { clonedDoc.querySelectorAll('.print-page-header').forEach(el => el.remove()); } catch(e){}

// ---- Leere letzte Seite entfernen (falls irgendwo ein Spacer entsteht) ----
                    const pages = Array.from(clonedDoc.querySelectorAll('.share-page'));
                    for(let i = pages.length - 1; i >= 0; i--){
                        const pg = pages[i];
                        const hasMedia = !!pg.querySelector('img,svg,canvas,video,table,textarea,input,select');
                        const hasText = (pg.textContent || '').replace(/\s+/g,'').length > 0;
                        if(!hasMedia && !hasText){
                            pg.remove();
                            continue;
                        }
                        // Wenn die Seite nur aus einem winzigen Rand/Strich besteht, ist sie i.d.R. ebenfalls leer
                        const rect = pg.getBoundingClientRect ? pg.getBoundingClientRect() : null;
                        if(rect && rect.height < 5){
                            pg.remove();
                            continue;
                        }
                        break;
                    }
                }catch(e){}
            }
        },
        // echte Papiermaße: A4 Landscape in mm (immer korrekt skaliert)
        jsPDF: { unit: 'mm', format: 'a4', orientation: 'landscape' }
    };
    try {
        // --- HARD LIMIT: keep ONLY first 4 pages in the generated PDF (Share) ---
        const sourceEl = (doc.getElementById('pdf-content') || doc.getElementById('print-container') || doc.body);
        const worker = window.html2pdf().set(opt).from(sourceEl).toPdf();
        let pdf = null;
        try { pdf = await worker.get('pdf'); } catch(e) { pdf = null; }

        if (pdf && typeof pdf.getNumberOfPages === 'function') {
            try {
                const total = pdf.getNumberOfPages();
                // Delete from the end so indices stay valid
                if (typeof pdf.deletePage === 'function') {
                    for (let i = total; i > 4; i--) {
                        try { pdf.deletePage(i); } catch(_) {}
                    }
                } else {
                    // Fallback: if deletePage isn't available, we still proceed (best effort)
                }
            } catch(e) { /* ignore */ }
        }

        // Output blob (prefer jsPDF output to respect deleted pages)
        let blob = null;
        try {
            if (pdf && typeof pdf.output === 'function') {
                blob = pdf.output('blob');
            }
        } catch(e) { blob = null; }

        // Fallback: if something failed above, use default worker output
        if (!blob) {
            blob = await worker.outputPdf('blob');
        }
        return blob;
    } finally {
        try { document.body.classList.remove('exporting'); } catch(e){}
        try { document.body.removeChild(iframe); } catch(e){}
        try { document.querySelectorAll('.print-page-header').forEach(el => el.remove()); } catch(e){}
    }
};


const blobToBase64 = (blob) => new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
        const res = String(reader.result || '');
        // data:application/pdf;base64,XXXX
        const idx = res.indexOf('base64,');
        resolve(idx >= 0 ? res.slice(idx + 7) : res);
    };
    reader.onerror = () => reject(reader.error);
    reader.readAsDataURL(blob);
});

// Sendet PDF + Metadaten an Power Automate (Flow speichert in OneDrive)
const uploadPdfToPowerAutomate = async ({ blob, type, dsl, agent, dateISO, triggerToast }) => {
    if (!PA_UPLOAD_URL || PA_UPLOAD_URL.includes('PASTE_POWER_AUTOMATE_FLOW_URL_HERE')) {
        // Noch nicht konfiguriert -> leise überspringen (Druck/Teilen soll trotzdem funktionieren)
        return { ok:false, skipped:true };
    }
    const pdfBase64 = await blobToBase64(blob);
    const payload = {
        type,                // 'abschluss' | 'angebot'
        dsl,                 // 'ja' | 'nein'
        agent,
        date: dateISO.slice(0,10),
        ts: dateISO,
        key: PA_SHARED_KEY || undefined,
        pdfBase64
    };
    const res = await fetch(PA_UPLOAD_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
    });
    if (!res.ok) throw new Error('Upload failed: ' + res.status);
    return { ok:true };
};

// Hintergrund-Upload: erstellt Print-Look PDF und lädt es hoch. UI bleibt normal (Print-Dialog kann trotzdem kommen).
const backgroundAutoUpload = async ({ type, triggerToast, ensurePrintHeaders, getAgent, getDsl }) => {
    try {
        if (!window.html2pdf) return; // offline/CDN block -> skip
        const blob = await createPrintLookPdfBlob(triggerToast, ensurePrintHeaders, { addPageNumbers: true });
        const dateISO = new Date().toISOString();
        const agent = getAgent();
        const dsl = getDsl();
        await uploadPdfToPowerAutomate({ blob, type, dsl, agent, dateISO, triggerToast });
    } catch (e) {
        console.warn('Auto-Upload skipped:', e);
        // bewusst nur leise, damit Verkauf nicht gestört wird
    }
};

// --- ANDROID SHARE (UX-OPTIMIERUNG: echtes PDF + Web Share API) ---
// Ziel: PDF im Hintergrund exakt im Print-Look erzeugen (ohne Print-Dialog) und direkt teilen.
// Technik: Offscreen-Iframe mit kopierten Styles + @media print => @media all, dann html2pdf (Blob) -> File -> navigator.share.

// --- ROBUST SHARE & SAVE (Android/iPad): WebShare wenn möglich, sonst Download-Fallback ---
// Hintergrund: Browser erlauben navigator.share(files) nur bei gültiger "User Activation".
// Wenn das Rendern zu lange dauert oder Files nicht unterstützt werden, wird automatisch gespeichert.

// --- ROBUST SHARE & SAVE (Android/iPad): WebShare wenn möglich, sonst Download-Fallback ---
// Hintergrund: Browser erlauben navigator.share(files) nur bei gültiger "User Activation".
// Wenn das Rendern zu lange dauert oder Files nicht unterstützt werden, wird automatisch gespeichert.
const handlePDFShare = async () => {
    // FINAL SAFE (v50_65): Never white-screen, never popup-block.
    // Strategy:
    // 1) Generate print-look PDF as Blob.
    // 2) Try Web Share ONLY if files-share is supported AND we are still in a likely user-activation window.
    // 3) Otherwise download to device (Downloads) and show a clear hint.

    const t0 = Date.now();
    const filename = `Angebot_${new Date().toISOString().slice(0,10)}.pdf`;

    const saveBlobToDownloads = (blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 5000);
    };

    const showOverlay = (msg='PDF wird erstellt...') => {
        let ov = document.getElementById('pdf-share-overlay');
        if (!ov) {
            ov = document.createElement('div');
            ov.id = 'pdf-share-overlay';
            ov.style.cssText = [
                'position:fixed','inset:0','z-index:99999',
                'background:rgba(15,23,42,0.55)','backdrop-filter:blur(6px)',
                'display:flex','align-items:center','justify-content:center','padding:16px'
            ].join(';');
            ov.innerHTML = `
              <div style="background:#fff;border:1px solid #e2e8f0;border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,0.25);padding:18px 18px;min-width:260px;max-width:360px;text-align:center;font-family:Arial,Helvetica,sans-serif;">
                <div style="width:44px;height:44px;border-radius:999px;border:5px solid #e2e8f0;border-top-color:#2563eb;margin:0 auto 12px auto;animation:pspin 0.9s linear infinite;"></div>
                <div id="pdf-share-overlay-text" style="font-weight:800;color:#0f172a;letter-spacing:-0.01em;">${msg}</div>
                <div style="margin-top:6px;font-size:12px;color:#64748b;">Bitte kurz warten…</div>
              </div>
            `;
            const st = document.createElement('style');
            st.textContent = '@keyframes pspin{to{transform:rotate(360deg)}}';
            ov.appendChild(st);
            document.body.appendChild(ov);
        } else {
            const t = ov.querySelector('#pdf-share-overlay-text');
            if (t) t.textContent = msg;
            ov.style.display = 'flex';
        }
    };
    const hideOverlay = () => {
        const ov = document.getElementById('pdf-share-overlay');
        if (ov) ov.style.display = 'none';
    };

    let blob = null;

    try {
        if (!window.html2pdf) {
            triggerToast('PDF-Generator nicht verfügbar. Fallback: Drucken.');
            try { (window.safePrint ? window.safePrint() : window.print()); } catch (e) {}
            return;
        }

        document.body.classList.add('exporting');
        showOverlay('PDF wird erstellt...');
        showOverlay('PDF wird gerendert...');

        // Generate once (no double render)
        blob = await createPrintLookPdfBlob(triggerToast, ensurePrintHeaders, { addPageNumbers: true });

        // Decide whether to attempt Web Share
        const file = new File([blob], filename, { type: 'application/pdf' });
        const canFileShare = !!(navigator.canShare && navigator.canShare({ files: [file] }));
        const elapsed = Date.now() - t0;
        const userActivation = !!(navigator.userActivation && navigator.userActivation.isActive);

        // Heuristic window: if rendering took too long, WebShare is likely blocked -> skip to download.
        const likelyAllowed = userActivation || elapsed < 1200;

        if (canFileShare && likelyAllowed) {
            showOverlay('Teilen-Dialog wird geöffnet...');
            try {
                await navigator.share({
                    files: [file],
                    title: 'Angebot',
                    text: 'Hier ist Ihr persönliches Angebot.'
                });
                return; // success
            } catch (errShare) {
                // NotAllowedError / AbortError / etc -> fallback to download
                try { console.warn('navigator.share blocked/failed -> download fallback', errShare); } catch(e){}
            }
        }

        // Fallback: download
        hideOverlay();
        saveBlobToDownloads(blob);
        try {
            alert("Teilen wurde vom Browser blockiert oder ist nicht verfügbar.\n\nDas PDF wurde automatisch in Ihrem 'Downloads'-Ordner gespeichert.\nTipp: Öffnen Sie es in 'Dateien' und teilen Sie es von dort per WhatsApp/Outlook.");
        } catch(e) {}
    } catch (err) {
        hideOverlay();
        try { console.warn('PDF Share failed:', err); } catch(e){}
        // last-resort fallback
        try {
            if (blob) saveBlobToDownloads(blob);
            else { (window.safePrint ? window.safePrint() : window.print()); }
        } catch (e2) {}
        try { triggerToast('Teilen/Export nicht möglich.'); } catch(e){}
    } finally {
        try { document.querySelectorAll('.print-page-header').forEach(el => el.remove()); } catch(e){}
        hideOverlay();
    }
};





            return (
                <div className="w-full h-full bg-[#f0f6ff] font-sans text-slate-800 flex flex-col overflow-hidden text-sm">
                    <Toast message={toastMessage} />
                    <WlanModal isOpen={showWlanModal} onClose={() => setShowWlanModal(false)} triggerToast={triggerToast} onRecommendation={(rec) => setWlanRecommendation(rec)} />
                    <SpeedModal isOpen={showSpeedModal} onClose={() => setShowSpeedModal(false)} triggerToast={triggerToast} onRecommendation={(rec) => setSpeedRecommendation(rec)} />
                    <TechModal isOpen={showTechModal} onClose={() => toggleTech(false)} />
                    <RoamingModal isOpen={showRoamingModal} onClose={() => setShowRoamingModal(false)} />
                    <QuestionModal isOpen={!!activeCategory && !showAdmin} onClose={() => setActiveCategory(null)} category={activeCategory} question={getCurrentQuestion()} onNextQuestion={handleNextQuestion} />
                    <ReferralModal isOpen={showReferralModal} onClose={(mode) => {
                        setShowReferralModal(false);
                        if (mode === 'cancel') {
                            try { setCustomerSignature(null); } catch(e) {}
                            // Angebotsgültigkeit zurücksetzen (Text + Stift), damit beim nächsten Druck sauber neu gesetzt werden kann
                            try { setTextData(prev => ({ ...prev, OfferValidUntil: '' })); } catch(e) {}
                            try { setDrawnStrokes(prev => ({ ...prev, offer_valid_until: [] })); } catch(e) {}
                        }
                    }} onPrint={handlePrint} />
                    <FinishTypeModal isOpen={showFinishTypeModal} onClose={() => setShowFinishTypeModal(false)} onSelect={handleFinishTypeSelection} />
                    <FollowUpModal isOpen={showFollowUpModal} onCancel={cancelFollowUp} onSave={saveCurrentFollowUp} followUpDraft={followUpDraft} setFollowUpDraft={setFollowUpDraft} currentLabel={getStaticLabel(followUpKeys[followUpIndex] || '')} stepInfo={followUpKeys.length ? `${followUpIndex+1}/${followUpKeys.length}` : ''} />

                    <OfferValidityModal
                        isOpen={showValidityModal}
                        value={getDisplayText('OfferValidUntil')}
                        onValueChange={(v) => {
                            handleTextChange('OfferValidUntil', v);
                            try { digitalTouchedRef.current['offer_valid_until'] = true; } catch(e) {}
                        }}
                        onCancel={() => { setShowValidityModal(false); pendingPrintRef.current = null; }}
                        onConfirm={() => {
                            const hasText = !!String(getDisplayText('OfferValidUntil') || '').trim();
                            if (!hasText) { triggerToast('Bitte Gültigkeitsdatum eingeben.'); return; }
                            setShowValidityModal(false);
                            const fn = pendingPrintRef.current;
                            pendingPrintRef.current = null;
                            (fn || (() => window.print()))();
                        }}
                    />


                    <SkipReasonModal isOpen={showSkipReasonModal} onClose={() => setShowSkipReasonModal(false)} onConfirm={handleSkipToOffer} reason={skipReason} setReason={setSkipReason} reasonMode={skipReasonMode} setReasonMode={setSkipReasonMode} drawnStrokes={drawnStrokes} setDrawnStrokes={setDrawnStrokes} canvasRef={skipReasonCanvasRef} startDrawing={startDrawing} draw={draw} stopDrawing={stopDrawing} MIN_LENGTH={MIN_REASON_LENGTH} /> <BundleModal isOpen={showBundleModal} onClose={() => setShowBundleModal(false)} url={bundleModalUrl} onImportToCanvas={importBundleToCanvas} triggerToast={triggerToast} targetKey={bundleTargetKey} />
<AdminModal isOpen={showAdmin} onClose={()=>setShowAdmin(false)} questions={questionsData} onUpdate={handleUpdateQuestions} oneDriveLink={oneDriveLink} onUpdateLink={setOneDriveLink} />
                    <StatsModal isOpen={showStats} onClose={()=>setShowStats(false)} />
                    
                    <ImagePlacementModal isOpen={isImageSelectModalOpen} onClose={() => setIsImageSelectModalOpen(false)} onPlace={handleImagePlacement} imageName={currentImagePayload?.name || 'Datei'} />
                    <SignatureModal isOpen={showSignatureModal} onClose={() => setShowSignatureModal(false)} onSign={handleSignatureSave} />

                    <header className="bg-white px-4 py-2 border-b border-slate-200 flex items-center gap-3 shrink-0 shadow-sm z-30 relative h-16 w-full"><button onClick={handleOpenStats} className="p-2 text-slate-400 hover:text-blue-600 rounded-full hover:bg-blue-50 transition-colors" title="📊 Statistik (passwortgeschützt)"><Icon d={ICONS.Lock} size={18}/></button><button onClick={toggleFullScreen} className="p-2 text-slate-400 hover:text-blue-600 rounded-full hover:bg-blue-50 transition-colors" title="Vollbild umschalten (wie F11)">{isFullscreen ? <Icon d={ICONS.Minimize} size={18}/> : <Icon d={ICONS.Maximize} size={18}/>}</button><h1 className="text-3xl font-black text-[#0b1e42] tracking-tighter truncate">{view === 'situation' ? 'Ihre Aktuelle Situation' : 'Ihr Persönliches Angebot'}</h1><div className="hida-logo-screen" aria-hidden="true">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 720 190">
    <rect width="100%" height="100%" fill="transparent"/>
    <text x="360" y="55" textAnchor="middle" fontSize="36" letterSpacing="6"
          fill="#9ca3af" fontFamily="Arial, Helvetica, sans-serif">— SHOP —</text>
    <text x="360" y="120" textAnchor="middle" fontSize="96" fontWeight="600"
          fill="#9ca3af" fontFamily="Arial, Helvetica, sans-serif">HeTec</text>
    <text x="360" y="170" textAnchor="middle" fontSize="34" letterSpacing="8"
          fill="#2dd4bf" fontFamily="Arial, Helvetica, sans-serif">WIR GESTALTEN ZUKUNFT</text>
  </svg>
</div></header>

                    <div className={`flex-1 w-full overflow-hidden relative ${view === 'situation' ? 'flex' : 'hidden'} situation-view-wrapper`}>
                        <div className="flex-1 flex items-stretch p-4 gap-0 overflow-hidden w-full min-w-0">
                            <div className="flex-1 flex bg-white rounded-2xl shadow-sm border border-slate-200 overflow-hidden relative isolate flex flex-col md:flex-row h-full w-full min-w-0">
                                <div className="flex-1 relative w-full h-full flex flex-col">
                                    <div className="flex-1 flex flex-col h-full w-full">
                                           {SITUATION_ITEMS.map((item) => {
                                                const sitKey = `sit_${item.id.replace(/\s+/g, '')}`;
                                                const sitRefMap = { 
                                                    Kundenname: sitCanvasRef_Kundenname,
                                                    Rufnummer: sitCanvasRef_Rufnummer,
                                                    Anbieter: sitCanvasRef_Anbieter,
                                                    Hardware: sitCanvasRef_Hardware,
                                                    Nutzung: sitCanvasRef_Nutzung,
                                                    Haushalt: sitCanvasRef_Haushalt,
                                                    'Weitere Produkte': sitCanvasRef_WeitereProdukte,
                                                    Fernsehen: sitCanvasRef_Fernsehen,
                                                    WiFi: sitCanvasRef_WiFi,
                                                    Gesamtkosten: sitCanvasRef_Gesamtkosten
                                                };
                                                const sitRef = sitRefMap[item.id];
                                                return (
                                                    <div key={item.id} className="flex w-full flex-1 min-h-0 relative gap-0 mb-0 border-b border-slate-200 last:border-b-0">
                                                        <div className={`w-[30%] shrink-0 flex items-center px-4 gap-4 transition-colors border-r border-slate-200 ${activeCategory === item.id ? 'bg-blue-50 text-blue-800' : 'bg-slate-100 text-slate-600 hover:bg-slate-200'}`}>
                                                            <button data-print-keep="1" onClick={(e) => { e.stopPropagation(); setActiveCategory(item.id); setQuestionIndex(0); }} className="w-10 h-10 shrink-0 flex items-center justify-center rounded-full hover:bg-blue-100 text-blue-600 relative z-30" title="Fragen öffnen">
                                                                <Icon d={item.icon} size={32} />
                                                            </button>
                                                            <span className="text-xl md:text-2xl font-black truncate tracking-tight select-none pointer-events-none">
                                                                {getStaticLabel(`${item.id}_Label`)}
                                                            </span>
                                                        </div>
                                                        <div className="flex-1 bg-white relative group flex items-center w-[70%] overflow-hidden">
                                                            <input
                                                                type="text"
                                                                value={getDisplayText(item.id)}
                                                                onChange={(e) => handleTextChange(item.id, e.target.value)}
                                                                className={`${getInputClasses()} ${isMainInputReadOnly ? 'text-slate-700/0' : 'text-slate-700 relative z-30'}`}
                                                                placeholder={isMainInputReadOnly ? "Skizze aktiv..." : "Eingabe..."}
                                                                readOnly={isMainInputReadOnly}
                                                            />
                                                            <canvas
                                                                ref={sitRef}
                                                                data-sit-key={sitKey}
                                                                onPointerDown={(e) => startDrawing(e, sitRef, sitKey)}
                                                                onPointerMove={(e) => draw(e, sitRef, sitKey)}
                                                                onPointerUp={(e) => stopDrawing(e, sitRef)}
                                                                onPointerLeave={(e) => stopDrawing(e, sitRef)}
                                                                className="absolute inset-0 w-full h-full drawing-canvas"
                                                                style={{ pointerEvents: (isWritingEnabled && inputMode === 'pen') ? 'auto' : 'none', touchAction: 'none', background: 'transparent' }}
                                                            />
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                    </div>
                                    
                                </div>
                            </div>
                        </div>

                        <aside className="w-[280px] xl:w-[300px] min-w-[280px] bg-[#f0f6ff] p-3 shrink-0 hidden md:flex flex-col border-l border-slate-200 z-10 h-full overflow-hidden">
                            <div className="flex-1 flex flex-col min-h-0 gap-2 overflow-y-auto custom-scrollbar">
                                <SectionCard title="Stammdaten" className="shrink-0 flex flex-col"><div className="grid grid-cols-2 gap-2 mb-2 shrink-0"><div className="relative h-8"><select value={customerType} onChange={(e) => setCustomerType(e.target.value)} className={`w-full h-full bg-slate-50 border rounded-lg pl-2 pr-6 text-[10px] font-medium text-slate-700 focus:ring-1 outline-none border-l-4 ${customerType === "" ? "border-l-red-500" : "border-l-green-500"}`}><option value="" disabled hidden>Kundentyp *</option><option value="Neukunde">Neukunde</option><option value="Bestandskunde">Bestandskunde</option></select></div><div className="relative h-8"><select value={segment} onChange={(e) => { setSegment(e.target.value); setSegmentTouched(true); }} className={`w-full h-full bg-slate-50 border rounded-lg pl-2 pr-6 text-[10px] font-medium text-slate-700 focus:ring-1 outline-none border-l-4 ${segmentTouched ? "border-l-green-500" : "border-l-red-500"}`}><option value="" disabled hidden>Segment *</option><option value="Neuvertrag">Neuvertrag</option><option value="Vertragsverlängerung">Vertragsverlängerung</option><option value="Junge Leute">Junge Leute</option><option value="Bestes Alter">Bestes Alter</option></select></div></div><div className="relative w-full h-16 border border-slate-200 rounded-md bg-white overflow-hidden group flex items-center shrink-0 small-input-fixed"><div className="absolute right-1 top-1/2 -translate-y-1/2 z-20"><button onClick={() => setEmailMode(prev => prev === 'keyboard' ? 'pen' : 'keyboard')} className="p-1 hover:bg-slate-100 rounded text-slate-400">{emailMode === 'keyboard' ? <Icon d={ICONS.Pen} size={10}/> : <Icon d={ICONS.Keyboard} size={10}/>}</button></div>{emailMode === 'keyboard' ? (<input type="text" value={emailText} onChange={(e) => setEmailText(e.target.value)} placeholder="E-Mail Adresse" className="w-full h-full px-3 text-[10px] focus:outline-none bg-transparent pr-10" />) : (<><canvas ref={emailCanvasRef} className="absolute inset-0 w-full h-full cursor-crosshair z-10 drawing-canvas" style={{ touchAction: 'none' }} onPointerDown={(e) => startDrawing(e, emailCanvasRef, 'email')} onPointerMove={(e) => draw(e, emailCanvasRef, 'email')} onPointerUp={(e) => stopDrawing(e, emailCanvasRef)} onPointerLeave={(e) => stopDrawing(e, emailCanvasRef)} /><button onClick={() => clearCanvas(emailCanvasRef, 'email')} className="absolute top-1/2 right-1 -translate-y-1/2 p-1 hover:bg-slate-100 rounded text-slate-400 z-30" title="Löschen"><Icon d={ICONS.Trash} size={10}/></button></>)}</div></SectionCard>
                                <SectionCard title="Technische Situation" className="shrink-0 flex flex-col"><div className="relative mb-2 w-full h-8 shrink-0">{!isCustomProvider ? (<select value={providerSelect} onChange={(e) => { if (e.target.value === 'Sonstiges') { setIsCustomProvider(true); setProviderSelect('Sonstiges'); } else { setProviderSelect(e.target.value); setIsCustomProvider(false); setWlanRecommendation(''); setSpeedRecommendation(''); } }} className={`w-full h-full bg-slate-50 border rounded-md pl-2 pr-6 text-[10px] font-medium text-slate-700 focus:ring-1 outline-none border-l-4 ${providerSelect === "" ? "border-l-red-500" : "border-l-green-500"}`}><option value="" disabled hidden>Derzeitiger DSL-Anbieter *</option><option value="Telekom">Telekom</option><option value="1&1">1&1</option><option value="Vodafone">Vodafone</option><option value="O2">O2</option><option value="Sonstiges">Sonstiges / Eingabe</option></select>) : (<div className="relative w-full h-full border border-slate-200 rounded-md bg-white overflow-hidden group flex items-center border-l-4 border-l-green-500"><div className="absolute right-1 top-1/2 -translate-y-1/2 z-20 flex gap-1"><button onClick={() => setProviderMode(prev => prev === 'keyboard' ? 'pen' : 'keyboard')} className="p-1 hover:bg-slate-100 rounded text-slate-400">{providerMode === 'keyboard' ? <Icon d={ICONS.Pen} size={10}/> : <Icon d={ICONS.Keyboard} size={10}/>}</button><button onClick={() => { setIsCustomProvider(false); setWlanRecommendation(''); setSpeedRecommendation(''); setProviderSelect(''); setCustomProvider(''); }} className="p-1 hover:bg-slate-100 rounded text-slate-400" title="Zurück zur Liste"><Icon d={ICONS.List} size={10}/></button></div>{providerMode === 'keyboard' ? (<input type="text" value={customProvider} onChange={(e) => setCustomProvider(e.target.value)} placeholder="Anbieter..." className="w-full h-full px-3 text-[10px] focus:outline-none bg-transparent pr-16" autoFocus />) : (<><canvas ref={providerCanvasRef} className="absolute inset-0 w-full h-full cursor-crosshair" onPointerDown={(e) => startDrawing(e, providerCanvasRef, 'provider')} onPointerMove={(e) => draw(e, providerCanvasRef, 'provider')} onPointerUp={(e) => stopDrawing(e, providerCanvasRef)} onPointerLeave={(e) => stopDrawing(e, providerCanvasRef)} /><button onClick={() => clearCanvas(providerCanvasRef, 'provider')} className="absolute top-1/2 right-1 -translate-y-1/2 p-1 hover:bg-slate-100 rounded text-slate-400 z-30" title="Löschen"><Icon d={ICONS.Trash} size={10}/></button></>)}</div>)}</div>{wlanRecommendation && (<div className="w-full mb-2 p-2 bg-white border border-blue-100 rounded-lg"><div className="text-[9px] font-black text-slate-400 uppercase tracking-wider mb-0.5">Empfehlung (WLAN)</div><div className="text-[11px] font-bold text-slate-700 leading-snug whitespace-pre-wrap">{wlanRecommendation}</div></div>)}<button onClick={() => setShowWlanModal(true)} className="w-full h-8 bg-slate-100 text-left px-3 rounded-md text-[10px] font-bold text-slate-700 flex items-center gap-2 border border-slate-200 hover:bg-slate-200 transition-colors shrink-0"><Icon d={ICONS.Wifi} size={14} className="text-slate-500" /> WLAN-Planer öffnen</button></SectionCard>
                                <SectionCard title="Technologie & Speed" className="shrink-0 flex flex-col"><div className="space-y-1 flex flex-col justify-center h-full"><button onClick={() => setShowTechModal(true)} className="w-full h-8 bg-slate-100 text-left px-3 rounded-md text-[10px] font-bold text-slate-700 flex items-center gap-2 border border-slate-200 hover:bg-slate-200 transition-colors"><Icon d={ICONS.Zap} size={14} className="text-slate-500" /> Technologie-Check</button><button onClick={() => setShowSpeedModal(true)} className="w-full h-8 bg-slate-100 text-left px-3 rounded-md text-[10px] font-bold text-slate-700 flex items-center gap-2 border border-slate-200 hover:bg-slate-200 transition-colors"><Icon d={ICONS.Gauge} size={14} className="text-slate-500" /> Speed-Rechner</button></div>{speedRecommendation && (<div className="w-full mt-2 p-2 bg-white border border-blue-100 rounded-lg"><div className="text-[9px] font-black text-slate-400 uppercase tracking-wider mb-0.5">Empfehlung (Speed)</div><div className="text-[11px] font-bold text-slate-700 leading-snug whitespace-pre-wrap">{speedRecommendation}</div></div>)}</SectionCard>
                                <SectionCard title="Roaming" className="shrink-0 flex flex-col print-hide-roaming"><div className="flex-1 flex items-center"><button onClick={() => setShowRoamingModal(true)} className="w-full h-8 bg-slate-100 text-left px-3 rounded-md text-[10px] font-bold text-slate-700 flex items-center gap-2 border border-slate-200 hover:bg-slate-200 transition-colors"><Icon d={ICONS.Globe} size={14} className="text-slate-500" /> Roaming Check</button></div></SectionCard>
                                <SectionCard title="Kosten (Ist)" className="shrink-0 flex flex-col"><div className="flex flex-col justify-center h-full gap-1"><div className="grid grid-cols-2 gap-2"><div><input className="w-full h-7 border border-slate-200 rounded px-2 text-[10px] focus:ring-1 relative z-10 bg-transparent" placeholder="Mobil €" value={costState.mobile} onChange={(e) => handleCostChange('mobile', e)} /><CostBar val={parseCost(costState.mobile)} total={totalCost} colorClass="bg-blue-500" /></div><div><input className="w-full h-7 border border-slate-200 rounded px-2 text-[10px] focus:ring-1 relative z-10 bg-transparent" placeholder="Festnetz €" value={costState.landline} onChange={(e) => handleCostChange('landline', e)} /><CostBar val={parseCost(costState.landline)} total={totalCost} colorClass="bg-cyan-500" /></div></div><div><input className="w-full h-7 border border-slate-200 rounded px-2 text-[10px] focus:ring-1 relative z-10 bg-transparent" placeholder="TV €" value={costState.tv} onChange={(e) => handleCostChange('tv', e)} /><CostBar val={parseCost(costState.tv)} total={totalCost} colorClass="bg-purple-500" /></div></div><div className="bg-slate-100 rounded-md px-2 h-7 flex items-center justify-end text-[11px] font-bold text-slate-700 border border-slate-200 mt-1 shrink-0">{totalCost.toFixed(2)} €}</div></SectionCard>
                            </div>
                        </aside>
                    </div>

                    <div className={`flex-1 w-full relative bg-[#f0f6ff] ${view === 'offer' ? 'flex overflow-y-auto' : 'hidden'} print-offer-view`}>
                        <div className="w-full flex-1 flex flex-col space-y-6 min-h-0 p-4 md:p-8">
                            <div className="flex flex-col gap-6 w-full md:grid md:grid-cols-3 offer-print-grid"> 
                                {[{ key: 'offer1', icon: ICONS.Smartphone, labelKey: 'Offer1Title', ref: offerCanvasRef1, scaleRef: scaleRef1 }, { key: 'offer2', icon: ICONS.Users, labelKey: 'Offer2Title', ref: offerCanvasRef2, scaleRef: scaleRef2 }, { key: 'offer3', icon: ICONS.Router, labelKey: 'Offer3Title', ref: offerCanvasRef3, scaleRef: scaleRef3 }].map(({ key, icon, labelKey, ref, scaleRef }) => {
                                    const orderClass = key === 'offer1' ? 'order-1' : key === 'offer2' ? 'order-2' : 'order-3';
                                    return (
                                        <div className={orderClass}>
                                            <OfferCanvas key={key} canvasRef={ref} icon={icon} label={getStaticLabel(labelKey)} statusKey={key} status={canvasStatus[key]} setStatus={setCanvasStatus} followUpInfo={followUpsByKey[key]} inputMode={inputMode} startDrawing={startDrawing} draw={draw} stopDrawing={stopDrawing} textValue={getDisplayText(key)} handleTextChange={handleTextChange} textStyle={textStyle} textSize={textSize} imageTransform={imageTransform[key]} onUpdateImageTransform={handleUpdateImageTransform} drawnStrokes={drawnStrokes[key]} setDrawnStrokes={(newStrokes) => setDrawnStrokes(prev => ({ ...prev, [key]: newStrokes }))} scaleRef={scaleRef} triggerRedraw={redrawCounter} image={canvasImages[key]} onClearImage={() => handleClearImage(key)} onClearOverlay={() => handleClearOverlay(key)} onOpenBundleModal={openBundleModal} triggerToast={triggerToast} />
                                        </div>
                                    );
                                })}
                            </div>

                            <div className="bg-white p-6 rounded-2xl border border-slate-200 shadow-xl shrink-0 cost-overview-print">
                                <h3 className="text-lg font-black text-slate-800 mb-4 flex items-center gap-2"><Icon d={ICONS.Calculator} size={20} className="text-blue-600"/> {getStaticLabel('CostHeader')}</h3>
                                <div className="grid grid-cols-3 gap-4 mt-4 cost-grid-years">
                                    {/* 1) Einmalig */}
                                    {renderOfferInput('einmalig', 'CostEinmalig', 'text')}

                                    {/* 2) Monatlich im 1. Jahr (oder allgemein, wenn 2. Jahr aus ist) */}
                                    {renderOfferInput('monatlich1', showSecondYear ? 'CostMonatlich1' : 'CostMonatlich', 'text')}

                                    {/* 3) Monatlich im 2. Jahr: bleibt IMMER im DOM (kein Reflow), nur unsichtbar wenn aus */}
                                    <div className={`year-2-container ${!showSecondYear ? 'hidden-layer' : ''}`}>
                                        {renderOfferInput('monatlich2', 'CostMonatlich2', 'text')}
                                    </div>
                                </div>

                                {/* Toggle: Kosten im 2. Jahr (ohne Layout-Mehrhöhe, Feld bleibt in der Zeile) */}
                                <div className="mt-3">
                                    <button
                                        type="button"
                                        className="w-full flex items-center justify-between gap-2 px-3 py-2 rounded-xl bg-slate-50 border border-slate-200 hover:bg-slate-100 transition-colors select-none"
                                        onClick={() => setShowSecondYear(v => !v)}
                                    >
                                        <span className="text-xs font-bold text-slate-600 uppercase tracking-wider">
                                            {getStaticLabel('CostMonatlich2')}
                                        </span>
                                        <span className="w-7 h-7 rounded-full bg-white border border-slate-200 flex items-center justify-center text-slate-700 font-black text-lg leading-none">
                                            {showSecondYear ? '−' : '+'}
                                        </span>
                                    </button>
                                </div>
                                <div className="grid grid-cols-1 md:grid-cols-5 gap-4 items-end">{renderOfferInput('agent', 'AgentLabel', 'text')}{renderOfferInput('datum', 'DateLabel', 'text')}{renderOfferInput('gueltig', 'ValidUntilLabel', 'date')}<div className="col-span-2">
  <div className="h-12 w-full bg-white border border-slate-300 rounded-lg overflow-hidden flex items-stretch">
    {/* Shop-Stempel (fix links) */}
    <div className="shrink-0 flex items-center gap-2 px-2 bg-slate-50 border-r border-slate-200">
      <img src={SHOP_STAMP_QR} alt="QR Code" className="h-9 w-9 object-contain" />
      <div className="flex flex-col leading-tight">
        <span className="text-[10px] font-black text-slate-700 uppercase tracking-wide">Stempel</span>
        <span className="text-[11px] font-bold text-slate-800 whitespace-nowrap">{SHOP_STAMP_TEXT}</span>
      </div>
    </div>
    {/* Kunden-Unterschrift (rechts, ohne Layout-Shift) */}
    <div className="flex-1 flex items-end justify-end px-2">
      {customerSignature ? (
        <img src={customerSignature} alt="Kundenunterschrift" className="h-10 w-full object-contain object-right-bottom" />
      ) : (
        <span className="text-xs text-slate-400 font-medium">Unterschrift Kunde</span>
      )}
    </div>
  </div>
</div></div>
                                {customerSignature && (<div className="w-full flex justify-end mt-1 pr-[1.25rem]"><span className="text-xs font-bold text-slate-500 uppercase tracking-wider">Unterschrift Kunde</span></div>)}
                                <div className="mt-4 pt-4 border-t border-slate-100"><p className="text-[10px] text-slate-400 leading-tight">**Datenschutzerklärung (Platzhalter):** Mit Ihrer Unterschrift bestätigen Sie die Richtigkeit der angegebenen Kosten und nehmen die Vertragsdetails sowie die beigefügte Datenschutzerklärung zur Kenntnis. Sie stimmen der elektronischen Speicherung Ihrer Daten zum Zwecke der Vertragsabwicklung zu. Widerrufsbelehrung liegt bei.</p></div>
                            </div>
                        </div>
                    </div>

                    <div className="h-14 bg-[#f0f6ff] border-t border-slate-200 flex items-center px-4 shrink-0 z-40 justify-between shadow-sm relative w-full footer-bar">
                        {view === 'situation' ? (<><div className="flex items-center gap-3"><div className="flex gap-1 bg-white p-0.5 rounded-lg border border-slate-200 shadow-sm"><button onClick={() => setInputMode('pen')} className={`p-2 rounded-md transition-colors ${inputMode === 'pen' ? 'bg-blue-100 text-blue-600' : 'text-slate-400 hover:bg-slate-50'}`} title="Stift-Modus (Stylus Only)"><Icon d={ICONS.Pen} size={16} /></button><button onClick={() => setInputMode('keyboard')} className={`p-2 rounded-md transition-colors ${inputMode === 'keyboard' ? 'bg-blue-100 text-blue-600' : 'text-slate-400 hover:bg-slate-50'}`} title="Tastatur-Modus"><Icon d={ICONS.Keyboard} size={16} /></button></div>{inputMode === 'pen' && (<div className="flex gap-1 bg-white p-0.5 rounded-lg border border-slate-200 shadow-sm animate-in items-center relative z-50">{renderPenToolButtons()}<div className="w-px h-6 bg-slate-200 mx-1"></div><div className="flex bg-slate-50 rounded border border-slate-200 p-0.5 gap-0.5">{STROKE_SIZES.map(s => (<button key={s.id} onClick={() => setStrokeWidth(s.width)} className={`w-6 h-6 flex items-center justify-center rounded hover:bg-slate-200 ${strokeWidth === s.width ? 'bg-slate-200 shadow-inner' : ''}`}><div className="bg-slate-600 rounded-full" style={{ width: s.id * 3, height: s.id * 3 }}></div></button>))}</div>{(tool === 'pen' || tool === 'highlighter') && (<div className="flex items-center gap-2 bg-slate-50 rounded border border-slate-200 p-1.5 ml-2"><Icon d={ICONS.Sun} size={16} className="text-slate-400"/><input type="range" min="10" max="100" value={Math.round(opacity * 100)} onChange={(e) => setOpacity(parseInt(e.target.value) / 100)} className="w-20 h-1 appearance-none bg-blue-200 rounded-full [&::-webkit-slider-thumb]:appearance-none [&::-webkit-slider-thumb]:w-3.5 [&::-webkit-slider-thumb]:h-3.5 [&::-webkit-slider-thumb]:bg-blue-600 [&::-webkit-slider-thumb]:rounded-full [&::-webkit-slider-thumb]:shadow-lg" title={`Deckkraft: ${Math.round(opacity * 100)}%`}/></div>)}<div className="w-px h-6 bg-slate-200 mx-1"></div><div className="relative"><button onClick={() => setShowColorPicker(!showColorPicker)} className="w-8 h-8 rounded-full border shadow-sm flex items-center justify-center ring-offset-2 focus:ring-2" style={{ backgroundColor: color }}><Icon d={ICONS.Palette} size={12} className="text-white mix-blend-difference" /></button>{showColorPicker && (<div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-3 bg-white p-3 rounded-xl shadow-2xl border border-slate-200 grid grid-cols-4 gap-2 w-[180px] z-[100]"><div className="col-span-4 text-[10px] font-bold text-slate-400 uppercase tracking-wider text-center mb-1">Farbe wählen</div>{COLORS.map(c => <button key={c.id} onClick={() => { setColor(c.value); setShowColorPicker(false); }} className={`w-8 h-8 rounded-full border-2 transition-transform hover:scale-110 ${color === c.value ? 'border-slate-400 shadow-inner scale-110' : 'border-transparent'}`} style={{ backgroundColor: c.value }} title={c.label} />)}</div>)}</div></div>)}{inputMode === 'keyboard' && (<div className="flex gap-1 bg-white p-0.5 rounded-lg border border-slate-200 shadow-sm animate-in items-center relative z-50"><div className="flex bg-slate-50 rounded border border-slate-200 p-0.5 gap-0.5"><button onClick={() => setTextSize('small')} className={`w-8 h-8 flex items-center justify-center rounded text-xs font-bold ${textSize === 'small' ? 'bg-white shadow text-blue-600 ring-1 ring-blue-100' : 'text-slate-500 hover:bg-slate-200'}`}>A</button><button onClick={() => setTextSize('medium')} className={`w-8 h-8 flex items-center justify-center rounded text-sm font-bold ${textSize === 'medium' ? 'bg-white shadow text-blue-600 ring-1 ring-blue-100' : 'text-slate-500 hover:bg-slate-200'}`}>A</button><button onClick={() => setTextSize('large')} className={`w-8 h-8 flex items-center justify-center rounded text-lg font-bold ${textSize === 'large' ? 'bg-white shadow text-blue-600 ring-1 ring-blue-100' : 'text-slate-500 hover:bg-slate-200'}`}>A</button></div><div className="w-px h-6 bg-slate-200 mx-1"></div><div className="flex gap-1"><button onClick={() => setTextStyle(p => ({...p, bold: !p.bold}))} className={`w-8 h-8 rounded flex items-center justify-center font-black transition-colors ${textStyle.bold ? 'bg-blue-100 text-blue-600 ring-1 ring-blue-200' : 'text-slate-500 hover:bg-slate-100'}`} title="Fett"><Icon d={ICONS.Bold} size={16}/></button><button onClick={() => setTextStyle(p => ({...p, italic: !p.italic}))} className={`w-8 h-8 rounded flex items-center justify-center italic font-serif transition-colors ${textStyle.italic ? 'bg-blue-100 text-blue-600 ring-1 ring-blue-200' : 'text-slate-500 hover:bg-slate-100'}`} title="Kursiv"><Icon d={ICONS.Italic} size={16}/></button></div></div>)}</div><div className="flex items-center gap-2">
                            <button onClick={() => setShowSkipReasonModal(true)} className="px-4 py-2 text-slate-500 font-bold text-xs hover:bg-slate-100 rounded-lg transition-colors">Überspringen</button>
                            <button onClick={() => isFormValid && setView('offer')} className={`px-6 py-2 rounded-lg font-bold shadow-lg text-sm flex items-center gap-2 transition-all ${isFormValid ? 'bg-blue-600 text-white hover:bg-blue-700 cursor-pointer' : 'bg-slate-300 text-slate-500 cursor-not-allowed'}`} title={isFormValid ? "Weiter zum Angebot" : "Bitte Pflichtfelder ausfüllen (Kundentyp, Segment, Anbieter)"}>Zum Angebot <Icon d={ICONS.ArrowRight} size={18} /></button>
                        </div></>) : (<div className="w-full flex justify-between items-center"><div className="flex items-center gap-3"><div className="flex gap-1 bg-white p-0.5 rounded-lg border border-slate-200 shadow-sm"><button onClick={() => setInputMode('pen')} className={`p-2 rounded-md transition-colors ${inputMode === 'pen' ? 'bg-blue-100 text-blue-600' : 'text-slate-400 hover:bg-slate-50'}`} title="Stift-Modus (Stylus Only)"><Icon d={ICONS.Pen} size={16} /></button><button onClick={() => setInputMode('keyboard')} className={`p-2 rounded-md transition-colors ${inputMode === 'keyboard' ? 'bg-blue-100 text-blue-600' : 'text-slate-400 hover:bg-slate-50'}`} title="Tastatur-Modus"><Icon d={ICONS.Keyboard} size={16} /></button></div>{inputMode === 'pen' && (<div className="flex gap-1 bg-white p-0.5 rounded-lg border border-slate-200 shadow-sm animate-in items-center relative z-50">{renderPenToolButtons()}<div className="w-px h-6 bg-slate-200 mx-1"></div><div className="flex bg-slate-50 rounded border border-slate-200 p-0.5 gap-0.5">{STROKE_SIZES.map(s => (<button key={s.id} onClick={() => setStrokeWidth(s.width)} className={`w-6 h-6 flex items-center justify-center rounded hover:bg-slate-200 ${strokeWidth === s.width ? 'bg-slate-200 shadow-inner' : ''}`}><div className="bg-slate-600 rounded-full" style={{ width: s.id * 3, height: s.id * 3 }}></div></button>))}</div>{(tool === 'pen' || tool === 'highlighter') && (<div className="flex items-center gap-2 bg-slate-50 rounded border border-slate-200 p-1.5 ml-2"><Icon d={ICONS.Sun} size={16} className="text-slate-400"/><input type="range" min="10" max="100" value={Math.round(opacity * 100)} onChange={(e) => setOpacity(parseInt(e.target.value) / 100)} className="w-20 h-1 appearance-none bg-blue-200 rounded-full [&::-webkit-slider-thumb]:appearance-none [&::-webkit-slider-thumb]:w-3.5 [&::-webkit-slider-thumb]:h-3.5 [&::-webkit-slider-thumb]:bg-blue-600 [&::-webkit-slider-thumb]:rounded-full [&::-webkit-slider-thumb]:shadow-lg" title={`Deckkraft: ${Math.round(opacity * 100)}%`}/></div>)}<div className="w-px h-6 bg-slate-200 mx-1"></div><div className="relative"><button onClick={() => setShowColorPicker(!showColorPicker)} className="w-8 h-8 rounded-full border shadow-sm flex items-center justify-center ring-offset-2 focus:ring-2" style={{ backgroundColor: color }}><Icon d={ICONS.Palette} size={12} className="text-white mix-blend-difference" /></button>{showColorPicker && (<div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-3 bg-white p-3 rounded-xl shadow-2xl border border-slate-200 grid grid-cols-4 gap-2 w-[180px] z-[100]"><div className="col-span-4 text-[10px] font-bold text-slate-400 uppercase tracking-wider text-center mb-1">Farbe wählen</div>{COLORS.map(c => <button key={c.id} onClick={() => { setColor(c.value); setShowColorPicker(false); }} className={`w-8 h-8 rounded-full border-2 transition-transform hover:scale-110 ${color === c.value ? 'border-slate-400 shadow-inner scale-110' : 'border-transparent'}`} style={{ backgroundColor: c.value }} title={c.label} />)}</div>)}</div></div>)}{inputMode === 'keyboard' && (<div className="flex gap-1 bg-white p-0.5 rounded-lg border border-slate-200 shadow-sm animate-in items-center relative z-50"><div className="flex bg-slate-50 rounded border border-slate-200 p-0.5 gap-0.5"><button onClick={() => setTextSize('small')} className={`w-8 h-8 flex items-center justify-center rounded text-xs font-bold ${textSize === 'small' ? 'bg-white shadow text-blue-600 ring-1 ring-blue-100' : 'text-slate-500 hover:bg-slate-200'}`}>A</button><button onClick={() => setTextSize('medium')} className={`w-8 h-8 flex items-center justify-center rounded text-sm font-bold ${textSize === 'medium' ? 'bg-white shadow text-blue-600 ring-1 ring-blue-100' : 'text-slate-500 hover:bg-slate-200'}`}>A</button><button onClick={() => setTextSize('large')} className={`w-8 h-8 flex items-center justify-center rounded text-lg font-bold ${textSize === 'large' ? 'bg-white shadow text-blue-600 ring-1 ring-blue-100' : 'text-slate-500 hover:bg-slate-200'}`}>A</button></div><div className="w-px h-6 bg-slate-200 mx-1"></div><div className="flex gap-1"><button onClick={() => setTextStyle(p => ({...p, bold: !p.bold}))} className={`w-8 h-8 rounded flex items-center justify-center font-black transition-colors ${textStyle.bold ? 'bg-blue-100 text-blue-600 ring-1 ring-blue-200' : 'text-slate-500 hover:bg-slate-100'}`} title="Fett"><Icon d={ICONS.Bold} size={16}/></button><button onClick={() => setTextStyle(p => ({...p, italic: !p.italic}))} className={`w-8 h-8 rounded flex items-center justify-center italic font-serif transition-colors ${textStyle.italic ? 'bg-blue-100 text-blue-600 ring-1 ring-blue-200' : 'text-slate-500 hover:bg-slate-100'}`} title="Kursiv"><Icon d={ICONS.Italic} size={16}/></button></div></div>)}</div><div className="flex items-center gap-4"><button onClick={handleFileAdd} className="p-2 bg-white rounded-lg border border-slate-200 shadow-sm text-slate-500 hover:bg-slate-100 hover:text-blue-600 transition-colors" title="Datei hinzufügen (Kamera / Ordner)"><Icon d={ICONS.Folder} size={18}/></button><div className="relative"><button onClick={() => setShowLanguageDropdown(p => !p)} className="flex items-center gap-2 bg-white p-2 rounded-lg border border-slate-200 shadow-sm hover:bg-slate-100 transition-colors" title={`Sprache: ${SORTED_LANGUAGES.find(l => l.code === displayLanguage)?.name || 'Deutsch'}`}><div className="relative flex items-center justify-center"><Icon d={ICONS.Globe} size={18} className="text-slate-500"/>{displayLanguage !== 'de' && (<span className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-[10px] font-black text-white mix-blend-difference leading-none pointer-events-none">{displayLanguage.toUpperCase()}</span>)}</div></button>{showLanguageDropdown && (<div className="absolute bottom-full right-0 mb-2 w-48 bg-white border border-slate-200 rounded-lg shadow-xl overflow-hidden z-50 animate-in fade-in"><div className="p-2 border-b border-slate-100 text-xs font-bold text-slate-500 uppercase">Sprache wählen</div>{SORTED_LANGUAGES.map(lang => (<button key={lang.code} onClick={() => { setDisplayLanguage(lang.code); setShowLanguageDropdown(false); }} className={`w-full text-left px-3 py-2 text-sm transition-colors flex items-center gap-2 ${displayLanguage === lang.code ? 'bg-blue-50 text-blue-700 font-bold' : 'text-slate-700 hover:bg-slate-100'}`}>{lang.name}{displayLanguage === lang.code && <Icon d={ICONS.CheckCircle} size={14} className="ml-auto"/>}</button>))}</div>)}</div><div className="flex items-center">{showShareButton && (<button onClick={handlePDFShare} className="p-2 bg-white border border-slate-200 rounded-full shadow-sm hover:bg-slate-100 text-blue-600 transition-colors mr-2 flex items-center justify-center w-10 h-10" title="Angebot teilen (System)"><Icon d={ICONS.Share} size={20} className="w-5 h-5" /></button>)}<button onClick={openOneDriveLink} className="p-2 bg-blue-500 text-white rounded-lg shadow-md hover:bg-blue-600 transition-colors mr-2 flex items-center justify-center" title="Link zur Aktionsmappe (Buch)"><Icon d={ICONS.Book} size={18}/> </button><button onClick={() => setView('situation')} className="px-6 py-2 text-slate-500 font-bold text-xs hover:bg-slate-100 rounded-lg transition-colors mr-2 flex items-center gap-1"><Icon d={ICONS.ArrowLeft} size={14}/> Zurück</button><button onClick={handleFinishOfferClick} disabled={!isReadyToFinish}  className={`px-6 py-2 rounded-lg font-bold shadow-lg text-sm flex items-center gap-2 transition-all ${
                    (!isReadyToFinish)
                        ? 'bg-slate-200 text-slate-400 cursor-not-allowed'
                        : (customerSignature ? 'bg-emerald-600 hover:bg-emerald-700' : 'bg-green-600 hover:bg-green-700')
                } text-white`}>{customerSignature ? 'Vertrag abschließen' : 'Fertigstellen'}</button></div></div></div>)}</div><input type="file" ref={fileInputRef} onChange={handleFileSelect} accept="image/*, application/pdf" capture="environment" hidden aria-label="Datei auswählen oder Kamera öffnen"/></div>);
        }

            // --- PRINT: pro Seite einen eigenen Header einfügen (ohne Screen-Layout zu ändern) ---
            const ensurePrintHeaders = () => {
    // Verhindert doppelte Header
    document.querySelectorAll('.print-page-header').forEach(el => el.remove());

    const mkHeader = (titleText) => {
        const h = document.createElement('div');
        h.className = 'print-page-header';
        // Professionelles Dunkelblau #0b1e42 und sauberes Layout
        h.innerHTML = `
            <div class="title" style="color:#0b1e42;">${titleText}</div>
            <div class="print-header-right">
                <img src="${HIDA_LOGO_DATA_URI}" class="hida-logo-print" style="height:34px;" />
            </div>
        `;
        return h;
    };

    // Seite 2 Header - Umbenannt auf Wunsch
    const sit = document.querySelector('.situation-view-wrapper');
    if (sit) sit.prepend(mkHeader('Ihre Aktuelle Situation'));

    // Seite 3 Header - Umbenannt auf Wunsch
    const off = document.querySelector('.print-offer-view');
    if (off) off.prepend(mkHeader('Ihr Persönliches Angebot'));
};

            window.addEventListener('beforeprint', ensurePrintHeaders);
            window.addEventListener('afterprint', () => {
                document.querySelectorAll('.print-page-header').forEach(el => el.remove());
            });

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

      // === v24: Bundle-Laufzeit Dropdown/Badge sichtbar machen (Tailwind-Klassen fehlen im Pencil-Selling) ===
      (function(){
        function fixTermSelectStyles(scope){
          try{
            scope = scope || document;
            const nodes = Array.from(scope.querySelectorAll('select,button,div,span'));
            const candidates = nodes.filter(el=>{
              const txt = (el.innerText || '').trim();
              if (/^(24|36)\s*Monate\b/i.test(txt)) return true;
              if (el.tagName === 'SELECT'){
                const opts = Array.from(el.options || []);
                return opts.some(o => /Monat/i.test((o.textContent||'')));
              }
              return false;
            });

            candidates.forEach(el=>{
              // Grundsätzlich lesbar machen
              el.style.color = '#fff';
              el.style.textShadow = '0 1px 0 rgba(0,0,0,0.12)';

              // Für echte Controls: pill-style
              if (el.tagName === 'SELECT' || el.tagName === 'BUTTON'){
                el.style.background = 'rgba(255,255,255,0.14)';
                el.style.border = '1px solid rgba(255,255,255,0.75)';
                el.style.borderRadius = '999px';
                el.style.padding = '6px 10px';
                el.style.fontWeight = '700';
                el.style.fontSize = '12px';
                el.style.lineHeight = '1';
                el.style.outline = 'none';
                el.style.webkitAppearance = 'none';
                el.style.appearance = 'none';
              } else {
                el.style.fontWeight = '700';
              }
            });
          }catch(e){/* ignore */}
        }

        const obs = new MutationObserver(muts=>{
          for(const m of muts){
            for(const n of m.addedNodes){
              if(n && n.nodeType===1){
                fixTermSelectStyles(n);
              }
            }
          }
        });

        window.addEventListener('DOMContentLoaded', ()=>{
          fixTermSelectStyles(document);
          obs.observe(document.body, {subtree:true, childList:true});
        });
      })();

    </script>
</body>
</html>
